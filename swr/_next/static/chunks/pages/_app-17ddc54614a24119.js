(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[888], {
  1587: function (module, __unused_webpack_exports, __webpack_require__) { module = __webpack_require__.nmd(module), function _f (self) { "use strict"; let Y; try { module && (self = module) } catch (e) { } function u (e) { return void 0 === e || e } function aa (e) { let t = Array(e); for (let n = 0; n < e; n++)t[n] = v(); return t } function v () { return Object.create(null) } function ba (e, t) { return t.length - e.length } function x (e) { return "string" == typeof e } function C (e) { return "object" == typeof e } function D (e) { return "function" == typeof e } function ca (e, t) { var n = da; if (e && (t && (e = E(e, t)), this.H && (e = E(e, this.H)), this.J && 1 < e.length && (e = E(e, this.J)), n || "" === n) && (e = e.split(n), this.filter)) { t = this.filter, n = e.length; let r = []; for (let a = 0, i = 0; a < n; a++) { let n = e[a]; n && !t[n] && (r[i++] = n) } e = r } return e } self._factory = _f; let da = /[\p{Z}\p{S}\p{P}\p{C}]+/u, ea = /[\u0300-\u036f]/g; function fa (e, t) { let n = Object.keys(e), r = n.length, a = [], i = "", s = 0; for (let o = 0, l, u; o < r; o++)(u = e[l = n[o]]) ? (a[s++] = F(t ? "(?!\\b)" + l + "(\\b|_)" : l), a[s++] = u) : i += (i ? "|" : "") + l; return i && (a[s++] = F(t ? "(?!\\b)(" + i + ")(\\b|_)" : "(" + i + ")"), a[s] = ""), a } function E (e, t) { for (let n = 0, r = t.length; n < r && (e = e.replace(t[n], t[n + 1])); n += 2); return e } function F (e) { return RegExp(e, "g") } function ha (e) { let t = "", n = ""; for (let r = 0, a = e.length, i; r < a; r++)(i = e[r]) !== n && (t += n = i); return t } var t, ja = { encode: ia, F: !1, G: "" }; function ia (e) { return ca.call(this, ("" + e).toLowerCase(), !1) } let ka = {}, G = {}; function la (e) { I(e, "add"), I(e, "append"), I(e, "search"), I(e, "update"), I(e, "remove") } function I (e, t) { e[t + "Async"] = function () { let e; let n = this, r = arguments; var a = r[r.length - 1]; return D(a) && (e = a, delete r[r.length - 1]), a = new Promise(function (e) { setTimeout(function () { n.async = !0; let a = n[t].apply(n, r); n.async = !1, e(a) }) }), e ? (a.then(e), this) : a } } function ma (e, t, n, r) { let a = e.length, i = [], s, o, l = 0; r && (r = []); for (let u = a - 1; 0 <= u; u--) { let c = e[u], d = c.length, h = v(), p = !s; for (let e = 0; e < d; e++) { let d = c[e], f = d.length; if (f) for (let e = 0, c, m; e < f; e++)if (m = d[e], s) { if (s[m]) { if (!u) { if (n) n--; else if (i[l++] = m, l === t) return i } (u || r) && (h[m] = 1), p = !0 } if (r && (o[m] = (c = o[m]) ? ++c : c = 1, c < a)) { let e = r[c - 2] || (r[c - 2] = []); e[e.length] = m } } else h[m] = 1 } if (r) s || (o = h); else if (!p) return []; s = h } if (r) for (let e = r.length - 1, a, o; 0 <= e; e--) { o = (a = r[e]).length; for (let e = 0, r; e < o; e++)if (!s[r = a[e]]) { if (n) n--; else if (i[l++] = r, l === t) return i; s[r] = 1 } } return i } function na (e, t) { let n = v(), r = v(), a = []; for (let t = 0; t < e.length; t++)n[e[t]] = 1; for (let e = 0, i; e < t.length; e++) { i = t[e]; for (let e = 0, t; e < i.length; e++)n[t = i[e]] && !r[t] && (r[t] = 1, a[a.length] = t) } return a } function J (e) { this.l = !0 !== e && e, this.cache = v(), this.h = [] } function oa (e, t, n) { C(e) && (e = e.query); let r = this.cache.get(e); return r || (r = this.search(e, t, n), this.cache.set(e, r)), r } J.prototype.set = function (e, t) { if (!this.cache[e]) { var n = this.h.length; for (n === this.l ? delete this.cache[this.h[n - 1]] : n++, --n; 0 < n; n--)this.h[n] = this.h[n - 1]; this.h[0] = e } this.cache[e] = t }, J.prototype.get = function (e) { let t = this.cache[e]; if (this.l && t && (e = this.h.indexOf(e))) { let t = this.h[e - 1]; this.h[e - 1] = this.h[e], this.h[e] = t } return t }; let qa = { memory: { charset: "latin:extra", D: 3, B: 4, m: !1 }, performance: { D: 3, B: 3, s: !1, context: { depth: 2, D: 1 } }, match: { charset: "latin:extra", G: "reverse" }, score: { charset: "latin:advanced", D: 20, B: 3, context: { depth: 3, D: 9 } }, default: {} }; function ra (e, t, n, r, a, i) { setTimeout(function () { let s = e(n, JSON.stringify(i)); s && s.then ? s.then(function () { t.export(e, t, n, r, a + 1) }) : t.export(e, t, n, r, a + 1) }) } function K (e, t) { if (!(this instanceof K)) return new K(e); if (e) { x(e) ? e = qa[e] : (n = e.preset) && (e = Object.assign({}, n[n], e)), n = e.charset; var n, r = e.lang; x(n) && (-1 === n.indexOf(":") && (n += ":default"), n = G[n]), x(r) && (r = ka[r]) } else e = {}; let a, i, s = e.context || {}; if (this.encode = e.encode || n && n.encode || ia, this.register = t || v(), this.D = a = e.resolution || 9, this.G = t = n && n.G || e.tokenize || "strict", this.depth = "strict" === t && s.depth, this.l = u(s.bidirectional), this.s = i = u(e.optimize), this.m = u(e.fastupdate), this.B = e.minlength || 1, this.C = e.boost, this.map = i ? aa(a) : v(), this.A = a = s.resolution || 1, this.h = i ? aa(a) : v(), this.F = n && n.F || e.rtl, this.H = (t = e.matcher || r && r.H) && fa(t, !1), this.J = (t = e.stemmer || r && r.J) && fa(t, !0), n = t = e.filter || r && r.filter) { n = t, r = v(); for (let e = 0, t = n.length; e < t; e++)r[n[e]] = 1; n = r } this.filter = n, this.cache = (t = e.cache) && new J(t) } function L (e, t, n, r, a) { return n && 1 < e ? t + (r || 0) <= e ? n + (a || 0) : (e - 1) / (t + (r || 0)) * (n + (a || 0)) + 1 | 0 : 0 } function M (e, t, n, r, a, i, s) { let o = s ? e.h : e.map; (!t[n] || s && !t[n][s]) && (e.s && (o = o[r]), s ? ((t = t[n] || (t[n] = v()))[s] = 1, o = o[s] || (o[s] = v())) : t[n] = 1, o = o[n] || (o[n] = []), e.s || (o = o[r] || (o[r] = [])), i && -1 !== o.indexOf(a) || (o[o.length] = a, e.m && ((e = e.register[a] || (e.register[a] = []))[e.length] = o))) } function sa (e, t, n, r, a, i, s, o) { let l = [], u = o ? e.h : e.map; if (e.s || (u = ua(u, s, o, e.l)), u) { let n = 0, c = Math.min(u.length, o ? e.A : e.D); for (let t = 0, d = 0, h, p; t < c && (!(h = u[t]) || (e.s && (h = ua(h, s, o, e.l)), a && h && i && ((p = h.length) <= a ? (a -= p, h = null) : (h = h.slice(a), a = 0)), !h || (l[n++] = h, !i || !((d += h.length) >= r)))); t++); if (n) return i ? ta(l, r, 0) : void (t[t.length] = l) } return !n && l } function ta (e, t, n) { return e = 1 === e.length ? e[0] : [].concat.apply([], e), n || e.length > t ? e.slice(n, n + t) : e } function ua (e, t, n, r) { return e = n ? (e = e[(r = r && t > n) ? t : n]) && e[r ? n : t] : e[t] } function N (e, t, n, r, a) { let i = 0; if (e.constructor === Array) { if (a) -1 !== (t = e.indexOf(t)) ? 1 < e.length && (e.splice(t, 1), i++) : i++; else { a = Math.min(e.length, n); for (let s = 0, o; s < a; s++)(o = e[s]) && (i = N(o, t, n, r, a), r || i || delete e[s]) } } else for (let s in e) (i = N(e[s], t, n, r, a)) || delete e[s]; return i } function va (e) { e = e.data; var t = self._index; let n = e.args; var r = e.task; "init" === r ? (r = e.options || {}, e = e.factory, t = r.encode, r.cache = !1, t && 0 === t.indexOf("function") && (r.encode = Function("return " + t)()), e ? (Function("return " + e)()(self), self._index = new self.FlexSearch.Index(r), delete self.FlexSearch) : self._index = new K(r)) : (e = e.id, t = t[r].apply(t, n), postMessage("search" === r ? { id: e, msg: t } : { id: e })) } t = K.prototype, t.append = function (e, t) { return this.add(e, t, !0) }, t.add = function (e, t, n, r) { if (t && (e || 0 === e)) { if (!r && !n && this.register[e]) return this.update(e, t); if (r = (t = this.encode(t)).length) { let u = v(), c = v(), d = this.depth, h = this.D; for (let p = 0; p < r; p++) { let f = t[this.F ? r - 1 - p : p]; var a = f.length; if (f && a >= this.B && (d || !c[f])) { var i = L(h, r, p), s = ""; switch (this.G) { case "full": if (3 < a) { for (i = 0; i < a; i++)for (var o = a; o > i; o--)if (o - i >= this.B) { var l = L(h, r, p, a, i); M(this, c, s = f.substring(i, o), l, e, n) } break } case "reverse": if (2 < a) { for (o = a - 1; 0 < o; o--)(s = f[o] + s).length >= this.B && M(this, c, s, L(h, r, p, a, o), e, n); s = "" } case "forward": if (1 < a) { for (o = 0; o < a; o++)(s += f[o]).length >= this.B && M(this, c, s, i, e, n); break } default: if (this.C && (i = Math.min(i / this.C(t, f, p) | 0, h - 1)), M(this, c, f, i, e, n), d && 1 < r && p < r - 1) { for (a = v(), s = this.A, i = f, o = Math.min(d + 1, r - p), a[i] = 1, l = 1; l < o; l++)if ((f = t[this.F ? r - 1 - p - l : p + l]) && f.length >= this.B && !a[f]) { a[f] = 1; let t = this.l && f > i; M(this, u, t ? i : f, L(s + (r / 2 > s ? 0 : 1), r, p, o - 1, l - 1), e, n, t ? f : i) } } } } } this.m || (this.register[e] = 1) } } return this }, t.search = function (e, t, n) { let r, a, i; n || (!t && C(e) ? e = (n = e).query : C(t) && (n = t)); let s = [], o, l, u = 0; if (n) { t = n.limit, u = n.offset || 0; var c = n.context; l = n.suggest } if (e && 1 < (o = (e = this.encode(e)).length)) { n = v(); var d = []; for (let t = 0, r = 0, a; t < o; t++)if ((a = e[t]) && a.length >= this.B && !n[a]) { if (!this.s && !l && !this.map[a]) return s; d[r++] = a, n[a] = 1 } o = (e = d).length } if (!o) return s; for (t || (t = 100), c = this.depth && 1 < o && !1 !== c, n = 0, c ? (r = e[0], n = 1) : 1 < o && e.sort(ba); n < o; n++) { if (i = e[n], c ? (a = sa(this, s, l, t, u, 2 === o, i, r), l && !1 === a && s.length || (r = i)) : a = sa(this, s, l, t, u, 1 === o, i), a) return a; if (l && n === o - 1) { if (!(d = s.length)) { if (c) { c = 0, n = -1; continue } return s } if (1 === d) return ta(s[0], t, u) } } return ma(s, t, u, l) }, t.contain = function (e) { return !!this.register[e] }, t.update = function (e, t) { return this.remove(e).add(e, t) }, t.remove = function (e, t) { let n = this.register[e]; if (n) { if (this.m) for (let t = 0, r; t < n.length; t++)(r = n[t]).splice(r.indexOf(e), 1); else N(this.map, e, this.D, this.s), this.depth && N(this.h, e, this.A, this.s); if (t || delete this.register[e], this.cache) { t = this.cache; for (let n = 0, r; n < t.h.length; n++)r = t.h[n], -1 !== t.cache[r].indexOf(e) && (t.h.splice(n--, 1), delete t.cache[r]) } } return this }, t.searchCache = oa, t.export = function (e, t, n, r, a) { let i, s; switch (a || (a = 0)) { case 0: if (i = "reg", this.m) for (let e in s = v(), this.register) s[e] = 1; else s = this.register; break; case 1: i = "cfg", s = { doc: 0, opt: this.s ? 1 : 0 }; break; case 2: i = "map", s = this.map; break; case 3: i = "ctx", s = this.h; break; default: return }return ra(e, t || this, n ? n + "." + i : i, r, a, s), !0 }, t.import = function (e, t) { if (t) switch (x(t) && (t = JSON.parse(t)), e) { case "cfg": this.s = !!t.opt; break; case "reg": this.m = !1, this.register = t; break; case "map": this.map = t; break; case "ctx": this.h = t } }, la(K.prototype); let wa = 0; function O (e) { var t; if (!(this instanceof O)) return new O(e); e ? D(t = e.encode) && (e.encode = t.toString()) : e = {}, (t = (self || window)._factory) && (t = t.toString()); let n = self.exports, r = this; this.o = xa(t, n, e.worker), this.h = v(), this.o && (n ? this.o.on("message", function (e) { r.h[e.id](e.msg), delete r.h[e.id] }) : this.o.onmessage = function (e) { e = e.data, r.h[e.id](e.msg), delete r.h[e.id] }, this.o.postMessage({ task: "init", factory: t, options: e })) } function P (e) { O.prototype[e] = O.prototype[e + "Async"] = function () { let t; let n = this, r = [].slice.call(arguments); var a = r[r.length - 1]; return D(a) && (t = a, r.splice(r.length - 1, 1)), a = new Promise(function (t) { setTimeout(function () { n.h[++wa] = t, n.o.postMessage({ task: e, id: wa, args: r }) }) }), t ? (a.then(t), this) : a } } function xa (a, b, c) { let d; try { d = b ? eval('new (require("worker_threads")["Worker"])("../dist/node/node.js")') : a ? new Worker(URL.createObjectURL(new Blob(["onmessage=" + va.toString()], { type: "text/javascript" }))) : new Worker(x(c) ? c : "worker/worker.js", { type: "module" }) } catch (e) { } return d } function Q (e) { if (!(this instanceof Q)) return new Q(e); var t, n = e.document || e.doc || e; this.K = [], this.h = [], this.A = [], this.register = v(), this.key = (t = n.key || n.id) && S(t, this.A) || "id", this.m = u(e.fastupdate), this.C = (t = n.store) && !0 !== t && [], this.store = t && v(), this.I = (t = n.tag) && S(t, this.A), this.l = t && v(), this.cache = (t = e.cache) && new J(t), e.cache = !1, this.o = e.worker, this.async = !1, t = v(); let r = n.index || n.field || n; x(r) && (r = [r]); for (let n = 0, a, i; n < r.length; n++)x(a = r[n]) || (i = a, a = a.field), i = C(i) ? Object.assign({}, e, i) : e, this.o && (t[a] = new O(i), t[a].o || (this.o = !1)), this.o || (t[a] = new K(i, this.register)), this.K[n] = S(a, this.A), this.h[n] = a; if (this.C) for (x(e = n.store) && (e = [e]), n = 0; n < e.length; n++)this.C[n] = S(e[n], this.A); this.index = t } function S (e, t) { let n = e.split(":"), r = 0; for (let a = 0; a < n.length; a++)0 <= (e = n[a]).indexOf("[]") && (e = e.substring(0, e.length - 2)) && (t[r] = !0), e && (n[r++] = e); return r < n.length && (n.length = r), 1 < r ? n : n[0] } function T (e, t) { if (x(t)) e = e[t]; else for (let n = 0; e && n < t.length; n++)e = e[t[n]]; return e } function U (e, t, n, r, a) { if (e = e[a], r === n.length - 1) t[a] = e; else if (e) { if (e.constructor === Array) for (t = t[a] = Array(e.length), a = 0; a < e.length; a++)U(e, t, n, r, a); else t = t[a] || (t[a] = v()), a = n[++r], U(e, t, n, r, a) } } function V (e, t, n, r, a, i, s, o) { if (e = e[s]) { if (r === t.length - 1) { if (e.constructor === Array) { if (n[r]) { for (t = 0; t < e.length; t++)a.add(i, e[t], !0, !0); return } e = e.join(" ") } a.add(i, e, o, !0) } else if (e.constructor === Array) for (s = 0; s < e.length; s++)V(e, t, n, r, a, i, s, o); else s = t[++r], V(e, t, n, r, a, i, s, o) } } function ya (e, t, n, r) { let a = this.l[e], i = a && a.length - n; if (i && 0 < i) return (i > t || n) && (a = a.slice(n, n + t)), r && (a = za.call(this, a)), { tag: e, result: a } } function za (e) { let t = Array(e.length); for (let n = 0, r; n < e.length; n++)r = e[n], t[n] = { id: r, doc: this.store[r] }; return t } P("add"), P("append"), P("search"), P("update"), P("remove"), t = Q.prototype, t.add = function (e, t, n) { if (C(e) && (e = T(t = e, this.key)), t && (e || 0 === e)) { if (!n && this.register[e]) return this.update(e, t); for (let r = 0, a, i; r < this.h.length; r++)i = this.h[r], x(a = this.K[r]) && (a = [a]), V(t, a, this.A, 0, this.index[i], e, a[0], n); if (this.I) { let r = T(t, this.I), a = v(); x(r) && (r = [r]); for (let t = 0, i, s; t < r.length; t++)if (!a[i = r[t]] && (a[i] = 1, s = this.l[i] || (this.l[i] = []), !n || -1 === s.indexOf(e)) && (s[s.length] = e, this.m)) { let t = this.register[e] || (this.register[e] = []); t[t.length] = s } } if (this.store && (!n || !this.store[e])) { let n; if (this.C) { n = v(); for (let e = 0, r; e < this.C.length; e++)x(r = this.C[e]) ? n[r] = t[r] : U(t, n, r, 0, r[0]) } this.store[e] = n || t } } return this }, t.append = function (e, t) { return this.add(e, t, !0) }, t.update = function (e, t) { return this.remove(e).add(e, t) }, t.remove = function (e) { if (C(e) && (e = T(e, this.key)), this.register[e]) { for (var t = 0; t < this.h.length && (this.index[this.h[t]].remove(e, !this.o), !this.m); t++); if (this.I && !this.m) for (let n in this.l) { let r = (t = this.l[n]).indexOf(e); -1 !== r && (1 < t.length ? t.splice(r, 1) : delete this.l[n]) } this.store && delete this.store[e], delete this.register[e] } return this }, t.search = function (e, t, n, r) { n || (!t && C(e) ? e = (n = e).query : C(t) && (n = t, t = 0)); let a = [], i = [], s, o, l, u, c, d, h = 0; if (n) { if (n.constructor === Array) l = n, n = null; else { if (l = (s = n.pluck) || n.index || n.field, u = n.tag, o = this.store && n.enrich, c = "and" === n.bool, t = n.limit || 100, d = n.offset || 0, u && (x(u) && (u = [u]), !e)) { for (let e = 0, n; e < u.length; e++)(n = ya.call(this, u[e], t, d, o)) && (a[a.length] = n, h++); return h ? a : [] } x(l) && (l = [l]) } } l || (l = this.h), c = c && (1 < l.length || u && 1 < u.length); let p = !r && (this.o || this.async) && []; for (let s = 0, o, f, m; s < l.length; s++) { let g; if (x(f = l[s]) || (g = f, f = f.field), p) p[s] = this.index[f].searchAsync(e, t, g || n); else { if (m = (o = r ? r[s] : this.index[f].search(e, t, g || n)) && o.length, u && m) { let e = [], n = 0; c && (e[0] = [o]); for (let t = 0, r, a; t < u.length; t++)r = u[t], (m = (a = this.l[r]) && a.length) && (n++, e[e.length] = c ? [a] : a); n && (m = (o = c ? ma(e, t || 100, d || 0) : na(o, e)).length) } if (m) i[h] = f, a[h++] = o; else if (c) return [] } } if (p) { let r = this; return new Promise(function (a) { Promise.all(p).then(function (i) { a(r.search(e, t, n, i)) }) }) } if (!h) return []; if (s && (!o || !this.store)) return a[0]; for (let e = 0, t; e < i.length; e++) { if ((t = a[e]).length && o && (t = za.call(this, t)), s) return t; a[e] = { field: i[e], result: t } } return a }, t.contain = function (e) { return !!this.register[e] }, t.get = function (e) { return this.store[e] }, t.set = function (e, t) { return this.store[e] = t, this }, t.searchCache = oa, t.export = function (e, t, n, r, a) { if (a || (a = 0), r || (r = 0), r < this.h.length) { let n = this.h[r], i = this.index[n]; t = this, setTimeout(function () { i.export(e, t, a ? n.replace(":", "-") : "", r, a++) || (r++, a = 1, t.export(e, t, n, r, a)) }) } else { let t; switch (a) { case 1: n = "tag", t = this.l; break; case 2: n = "store", t = this.store; break; default: return }ra(e, this, n, r, a, t) } }, t.import = function (e, t) { if (t) switch (x(t) && (t = JSON.parse(t)), e) { case "tag": this.l = t; break; case "reg": this.m = !1, this.register = t; for (let e = 0, n; e < this.h.length; e++)(n = this.index[this.h[e]]).register = t, n.m = !1; break; case "store": this.store = t; break; default: let n = (e = e.split("."))[0]; e = e[1], n && e && this.index[n].import(e, t) } }, la(Q.prototype); var Ba = { encode: Aa, F: !1, G: "" }; let Ca = [F("[\xe0\xe1\xe2\xe3\xe4\xe5]"), "a", F("[\xe8\xe9\xea\xeb]"), "e", F("[\xec\xed\xee\xef]"), "i", F("[\xf2\xf3\xf4\xf5\xf6ő]"), "o", F("[\xf9\xfa\xfb\xfcű]"), "u", F("[\xfdŷ\xff]"), "y", F("\xf1"), "n", F("[\xe7c]"), "k", F("\xdf"), "s", F(" & "), " and "]; function Aa (e) { var t = e; return t.normalize && (t = t.normalize("NFD").replace(ea, "")), ca.call(this, t.toLowerCase(), !e.normalize && Ca) } var Ea = { encode: Da, F: !1, G: "strict" }; let Fa = /[^a-z0-9]+/, Ga = { b: "p", v: "f", w: "f", z: "s", x: "s", ß: "s", d: "t", n: "m", c: "k", g: "k", j: "k", q: "k", i: "e", y: "e", u: "o" }; function Da (e) { e = Aa.call(this, e).join(" "); let t = []; if (e) { let n = e.split(Fa), r = n.length; for (let a = 0, i, s = 0; a < r; a++)if ((e = n[a]) && (!this.filter || !this.filter[e])) { let n = Ga[i = e[0]] || i, r = n; for (let t = 1; t < e.length; t++) { let a = Ga[i = e[t]] || i; a && a !== r && (n += a, r = a) } t[s++] = n } } return t } var Ia = { encode: Ha, F: !1, G: "" }; let Ja = [F("ae"), "a", F("oe"), "o", F("sh"), "s", F("th"), "t", F("ph"), "f", F("pf"), "f", F("(?![aeo])h(?![aeo])"), "", F("(?!^[aeo])h(?!^[aeo])"), ""]; function Ha (e, t) { return e && (2 < (e = Da.call(this, e).join(" ")).length && (e = E(e, Ja)), t || (1 < e.length && (e = ha(e)), e && (e = e.split(" ")))), e } var La = { encode: Ka, F: !1, G: "" }; let Ma = F("(?!\\b)[aeo]"); function Ka (e) { return e && (1 < (e = Ha.call(this, e, !0)).length && (e = e.replace(Ma, "")), 1 < e.length && (e = ha(e)), e && (e = e.split(" "))), e } G["latin:default"] = ja, G["latin:simple"] = Ba, G["latin:balance"] = Ea, G["latin:advanced"] = Ia, G["latin:extra"] = La; let W = self, Z = { Index: K, Document: Q, Worker: O, registerCharset: function (e, t) { G[e] = t }, registerLanguage: function (e, t) { ka[e] = t } }; (Y = W.define) && Y.amd ? Y([], function () { return Z }) : W.exports ? W.exports = Z : W.FlexSearch = Z }(this) }, 2297: function () { !function (e, t) { t() }(0, function () { "use strict"; function e (e) { var t = !0, n = !1, r = null, a = { text: !0, search: !0, url: !0, tel: !0, email: !0, password: !0, number: !0, date: !0, month: !0, week: !0, time: !0, datetime: !0, "datetime-local": !0 }; function i (e) { return !!e && e !== document && "HTML" !== e.nodeName && "BODY" !== e.nodeName && "classList" in e && "contains" in e.classList } function s (e) { var t = e.type, n = e.tagName; return "INPUT" === n && !!a[t] && !e.readOnly || "TEXTAREA" === n && !e.readOnly || !!e.isContentEditable } function o (e) { e.classList.contains("focus-visible") || (e.classList.add("focus-visible"), e.setAttribute("data-focus-visible-added", "")) } function l (e) { e.hasAttribute("data-focus-visible-added") && (e.classList.remove("focus-visible"), e.removeAttribute("data-focus-visible-added")) } function u (n) { n.metaKey || n.altKey || n.ctrlKey || (i(e.activeElement) && o(e.activeElement), t = !0) } function c (e) { t = !1 } function d (e) { i(e.target) && (t || s(e.target)) && o(e.target) } function h (e) { i(e.target) && (e.target.classList.contains("focus-visible") || e.target.hasAttribute("data-focus-visible-added")) && (n = !0, window.clearTimeout(r), r = window.setTimeout(function () { n = !1 }, 100), l(e.target)) } function p (e) { "hidden" === document.visibilityState && (n && (t = !0), f()) } function f () { document.addEventListener("mousemove", x), document.addEventListener("mousedown", x), document.addEventListener("mouseup", x), document.addEventListener("pointermove", x), document.addEventListener("pointerdown", x), document.addEventListener("pointerup", x), document.addEventListener("touchmove", x), document.addEventListener("touchstart", x), document.addEventListener("touchend", x) } function m () { document.removeEventListener("mousemove", x), document.removeEventListener("mousedown", x), document.removeEventListener("mouseup", x), document.removeEventListener("pointermove", x), document.removeEventListener("pointerdown", x), document.removeEventListener("pointerup", x), document.removeEventListener("touchmove", x), document.removeEventListener("touchstart", x), document.removeEventListener("touchend", x) } function x (e) { e.target.nodeName && "html" === e.target.nodeName.toLowerCase() || (t = !1, m()) } document.addEventListener("keydown", u, !0), document.addEventListener("mousedown", c, !0), document.addEventListener("pointerdown", c, !0), document.addEventListener("touchstart", c, !0), document.addEventListener("visibilitychange", p, !0), f(), e.addEventListener("focus", d, !0), e.addEventListener("blur", h, !0), e.nodeType === Node.DOCUMENT_FRAGMENT_NODE && e.host ? e.host.setAttribute("data-js-focus-visible", "") : e.nodeType === Node.DOCUMENT_NODE && (document.documentElement.classList.add("js-focus-visible"), document.documentElement.setAttribute("data-js-focus-visible", "")) } if ("undefined" != typeof window && "undefined" != typeof document) { var t; window.applyFocusVisiblePolyfill = e; try { t = new CustomEvent("focus-visible-polyfill-ready") } catch (e) { (t = document.createEvent("CustomEvent")).initCustomEvent("focus-visible-polyfill-ready", !1, !1, {}) } window.dispatchEvent(t) } "undefined" != typeof document && e(document) }) }, 6407: function (e, t, n) { "use strict"; var r = n(8593), a = n(2895); function i (e) { var t = r(e); return t.token = "", "x-oauth-basic" === t.password ? t.token = t.user : "x-token-auth" === t.user && (t.token = t.password), a(t.protocols) || 0 === t.protocols.length && a(e) ? t.protocol = "ssh" : t.protocols.length ? t.protocol = t.protocols[0] : (t.protocol = "file", t.protocols = ["file"]), t.href = t.href.replace(/\/$/, ""), t } e.exports = i }, 4728: function (e, t, n) { "use strict"; var r = n(6407); function a (e) { if ("string" != typeof e) throw Error("The url must be a string."); /^([a-z\d-]{1,39})\/([-\.\w]{1,100})$/i.test(e) && (e = "https://github.com/" + e); var t = r(e), n = t.resource.split("."), i = null; switch (t.toString = function (e) { return a.stringify(this, e) }, t.source = n.length > 2 ? n.slice(1 - n.length).join(".") : t.source = t.resource, t.git_suffix = /\.git$/.test(t.pathname), t.name = decodeURIComponent((t.pathname || t.href).replace(/(^\/)|(\/$)/g, "").replace(/\.git$/, "")), t.owner = decodeURIComponent(t.user), t.source) { case "git.cloudforge.com": t.owner = t.user, t.organization = n[0], t.source = "cloudforge.com"; break; case "visualstudio.com": if ("vs-ssh.visualstudio.com" === t.resource) { 4 === (i = t.name.split("/")).length && (t.organization = i[1], t.owner = i[2], t.name = i[3], t.full_name = i[2] + "/" + i[3]); break } 2 === (i = t.name.split("/")).length ? (t.owner = i[1], t.name = i[1], t.full_name = "_git/" + t.name) : 3 === i.length ? (t.name = i[2], "DefaultCollection" === i[0] ? (t.owner = i[2], t.organization = i[0], t.full_name = t.organization + "/_git/" + t.name) : (t.owner = i[0], t.full_name = t.owner + "/_git/" + t.name)) : 4 === i.length && (t.organization = i[0], t.owner = i[1], t.name = i[3], t.full_name = t.organization + "/" + t.owner + "/_git/" + t.name); break; case "dev.azure.com": case "azure.com": if ("ssh.dev.azure.com" === t.resource) { 4 === (i = t.name.split("/")).length && (t.organization = i[1], t.owner = i[2], t.name = i[3]); break } 5 === (i = t.name.split("/")).length ? (t.organization = i[0], t.owner = i[1], t.name = i[4], t.full_name = "_git/" + t.name) : 3 === i.length ? (t.name = i[2], "DefaultCollection" === i[0] ? (t.owner = i[2], t.organization = i[0], t.full_name = t.organization + "/_git/" + t.name) : (t.owner = i[0], t.full_name = t.owner + "/_git/" + t.name)) : 4 === i.length && (t.organization = i[0], t.owner = i[1], t.name = i[3], t.full_name = t.organization + "/" + t.owner + "/_git/" + t.name), t.query && t.query.path && (t.filepath = t.query.path.replace(/^\/+/g, "")), t.query && t.query.version && (t.ref = t.query.version.replace(/^GB/, "")); break; default: var s = (i = t.name.split("/")).length - 1; if (i.length >= 2) { var o = i.indexOf("-", 2), l = i.indexOf("blob", 2), u = i.indexOf("tree", 2), c = i.indexOf("commit", 2), d = i.indexOf("src", 2), h = i.indexOf("raw", 2), p = i.indexOf("edit", 2); s = o > 0 ? o - 1 : l > 0 ? l - 1 : u > 0 ? u - 1 : c > 0 ? c - 1 : d > 0 ? d - 1 : h > 0 ? h - 1 : p > 0 ? p - 1 : s, t.owner = i.slice(0, s).join("/"), t.name = i[s], c && (t.commit = i[s + 2]) } t.ref = "", t.filepathtype = "", t.filepath = ""; var f = i.length > s && "-" === i[s + 1] ? s + 1 : s; i.length > f + 2 && ["raw", "src", "blob", "tree", "edit"].indexOf(i[f + 1]) >= 0 && (t.filepathtype = i[f + 1], t.ref = i[f + 2], i.length > f + 3 && (t.filepath = i.slice(f + 3).join("/"))), t.organization = t.owner }!t.full_name && (t.full_name = t.owner, t.name && (t.full_name && (t.full_name += "/"), t.full_name += t.name)), t.owner.startsWith("scm/") && (t.source = "bitbucket-server", t.owner = t.owner.replace("scm/", ""), t.organization = t.owner, t.full_name = t.owner + "/" + t.name); var m = /(projects|users)\/(.*?)\/repos\/(.*?)((\/.*$)|$)/.exec(t.pathname); return null != m && (t.source = "bitbucket-server", "users" === m[1] ? t.owner = "~" + m[2] : t.owner = m[2], t.organization = t.owner, t.name = m[3], (i = m[4].split("/")).length > 1 && (["raw", "browse"].indexOf(i[1]) >= 0 ? (t.filepathtype = i[1], i.length > 2 && (t.filepath = i.slice(2).join("/"))) : "commits" === i[1] && i.length > 2 && (t.commit = i[2])), t.full_name = t.owner + "/" + t.name, t.query.at ? t.ref = t.query.at : t.ref = ""), t } function i (e) { return "bitbucket.org" === e.source ? "x-token-auth:" + e.token + "@" : e.token + "@" } function s (e) { return "bitbucket-server" === e.source ? "scm/" + e.full_name : "" + e.full_name } a.stringify = function (e, t) { t = t || (e.protocols && e.protocols.length ? e.protocols.join("+") : e.protocol); var n = e.port ? ":" + e.port : "", r = e.user || "git", a = e.git_suffix ? ".git" : ""; switch (t) { case "ssh": if (n) return "ssh://" + r + "@" + e.resource + n + "/" + e.full_name + a; return r + "@" + e.resource + ":" + e.full_name + a; case "git+ssh": case "ssh+git": case "ftp": case "ftps": return t + "://" + r + "@" + e.resource + n + "/" + e.full_name + a; case "http": case "https": return t + "://" + (e.token ? i(e) : e.user && (e.protocols.includes("http") || e.protocols.includes("https")) ? e.user + "@" : "") + e.resource + n + "/" + s(e) + a; default: return e.href } }, e.exports = a }, 5983: function () { !function () { "use strict"; if ("object" == typeof window) { if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) { "isIntersecting" in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", { get: function () { return this.intersectionRatio > 0 } }); return } var e = function (e) { for (var t = e, n = a(t); n;)n = a(t = n.ownerDocument); return t }(window.document), t = [], n = null, r = null; s.prototype.THROTTLE_TIMEOUT = 100, s.prototype.POLL_INTERVAL = null, s.prototype.USE_MUTATION_OBSERVER = !0, s._setupCrossOriginUpdater = function () { return n || (n = function (e, n) { r = e && n ? m(e, n) : p(), t.forEach(function (e) { e._checkForIntersections() }) }), n }, s._resetCrossOriginUpdater = function () { n = null, r = null }, s.prototype.observe = function (e) { if (!this._observationTargets.some(function (t) { return t.element == e })) { if (!(e && 1 == e.nodeType)) throw Error("target must be an Element"); this._registerInstance(), this._observationTargets.push({ element: e, entry: null }), this._monitorIntersections(e.ownerDocument), this._checkForIntersections() } }, s.prototype.unobserve = function (e) { this._observationTargets = this._observationTargets.filter(function (t) { return t.element != e }), this._unmonitorIntersections(e.ownerDocument), 0 == this._observationTargets.length && this._unregisterInstance() }, s.prototype.disconnect = function () { this._observationTargets = [], this._unmonitorAllIntersections(), this._unregisterInstance() }, s.prototype.takeRecords = function () { var e = this._queuedEntries.slice(); return this._queuedEntries = [], e }, s.prototype._initThresholds = function (e) { var t = e || [0]; return Array.isArray(t) || (t = [t]), t.sort().filter(function (e, t, n) { if ("number" != typeof e || isNaN(e) || e < 0 || e > 1) throw Error("threshold must be a number between 0 and 1 inclusively"); return e !== n[t - 1] }) }, s.prototype._parseRootMargin = function (e) { var t = (e || "0px").split(/\s+/).map(function (e) { var t = /^(-?\d*\.?\d+)(px|%)$/.exec(e); if (!t) throw Error("rootMargin must be specified in pixels or percent"); return { value: parseFloat(t[1]), unit: t[2] } }); return t[1] = t[1] || t[0], t[2] = t[2] || t[0], t[3] = t[3] || t[1], t }, s.prototype._monitorIntersections = function (t) { var n = t.defaultView; if (n && -1 == this._monitoringDocuments.indexOf(t)) { var r = this._checkForIntersections, i = null, s = null; if (this.POLL_INTERVAL ? i = n.setInterval(r, this.POLL_INTERVAL) : (u(n, "resize", r, !0), u(t, "scroll", r, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in n && (s = new n.MutationObserver(r)).observe(t, { attributes: !0, childList: !0, characterData: !0, subtree: !0 })), this._monitoringDocuments.push(t), this._monitoringUnsubscribes.push(function () { var e = t.defaultView; e && (i && e.clearInterval(i), c(e, "resize", r, !0)), c(t, "scroll", r, !0), s && s.disconnect() }), t != (this.root && (this.root.ownerDocument || this.root) || e)) { var o = a(t); o && this._monitorIntersections(o.ownerDocument) } } }, s.prototype._unmonitorIntersections = function (t) { var n = this._monitoringDocuments.indexOf(t); if (-1 != n) { var r = this.root && (this.root.ownerDocument || this.root) || e; if (!this._observationTargets.some(function (e) { var n = e.element.ownerDocument; if (n == t) return !0; for (; n && n != r;) { var i = a(n); if ((n = i && i.ownerDocument) == t) return !0 } return !1 })) { var i = this._monitoringUnsubscribes[n]; if (this._monitoringDocuments.splice(n, 1), this._monitoringUnsubscribes.splice(n, 1), i(), t != r) { var s = a(t); s && this._unmonitorIntersections(s.ownerDocument) } } } }, s.prototype._unmonitorAllIntersections = function () { var e = this._monitoringUnsubscribes.slice(0); this._monitoringDocuments.length = 0, this._monitoringUnsubscribes.length = 0; for (var t = 0; t < e.length; t++)e[t]() }, s.prototype._checkForIntersections = function () { if (this.root || !n || r) { var e = this._rootIsInDom(), t = e ? this._getRootRect() : p(); this._observationTargets.forEach(function (r) { var a = r.element, s = h(a), l = this._rootContainsTarget(a), u = r.entry, c = e && l && this._computeTargetAndRootIntersection(a, s, t), d = null; this._rootContainsTarget(a) ? (!n || this.root) && (d = t) : d = p(); var f = r.entry = new i({ time: o(), target: a, boundingClientRect: s, rootBounds: d, intersectionRect: c }); u ? e && l ? this._hasCrossedThreshold(u, f) && this._queuedEntries.push(f) : u && u.isIntersecting && this._queuedEntries.push(f) : this._queuedEntries.push(f) }, this), this._queuedEntries.length && this._callback(this.takeRecords(), this) } }, s.prototype._computeTargetAndRootIntersection = function (t, a, i) { if ("none" != window.getComputedStyle(t).display) { for (var s = a, o = g(t), l = !1; !l && o;) { var u = null, c = 1 == o.nodeType ? window.getComputedStyle(o) : {}; if ("none" == c.display) return null; if (o == this.root || 9 == o.nodeType) { if (l = !0, o == this.root || o == e) n && !this.root ? r && (0 != r.width || 0 != r.height) ? u = r : (o = null, u = null, s = null) : u = i; else { var p = g(o), f = p && h(p), x = p && this._computeTargetAndRootIntersection(p, f, i); f && x ? (o = p, u = m(f, x)) : (o = null, s = null) } } else { var v = o.ownerDocument; o != v.body && o != v.documentElement && "visible" != c.overflow && (u = h(o)) } if (u && (s = d(u, s)), !s) break; o = o && g(o) } return s } }, s.prototype._getRootRect = function () { var t; if (this.root && !v(this.root)) t = h(this.root); else { var n = v(this.root) ? this.root : e, r = n.documentElement, a = n.body; t = { top: 0, left: 0, right: r.clientWidth || a.clientWidth, width: r.clientWidth || a.clientWidth, bottom: r.clientHeight || a.clientHeight, height: r.clientHeight || a.clientHeight } } return this._expandRectByRootMargin(t) }, s.prototype._expandRectByRootMargin = function (e) { var t = this._rootMarginValues.map(function (t, n) { return "px" == t.unit ? t.value : t.value * (n % 2 ? e.width : e.height) / 100 }), n = { top: e.top - t[0], right: e.right + t[1], bottom: e.bottom + t[2], left: e.left - t[3] }; return n.width = n.right - n.left, n.height = n.bottom - n.top, n }, s.prototype._hasCrossedThreshold = function (e, t) { var n = e && e.isIntersecting ? e.intersectionRatio || 0 : -1, r = t.isIntersecting ? t.intersectionRatio || 0 : -1; if (n !== r) for (var a = 0; a < this.thresholds.length; a++) { var i = this.thresholds[a]; if (i == n || i == r || i < n != i < r) return !0 } }, s.prototype._rootIsInDom = function () { return !this.root || x(e, this.root) }, s.prototype._rootContainsTarget = function (t) { var n = this.root && (this.root.ownerDocument || this.root) || e; return x(n, t) && (!this.root || n == t.ownerDocument) }, s.prototype._registerInstance = function () { 0 > t.indexOf(this) && t.push(this) }, s.prototype._unregisterInstance = function () { var e = t.indexOf(this); -1 != e && t.splice(e, 1) }, window.IntersectionObserver = s, window.IntersectionObserverEntry = i } function a (e) { try { return e.defaultView && e.defaultView.frameElement || null } catch (e) { return null } } function i (e) { this.time = e.time, this.target = e.target, this.rootBounds = f(e.rootBounds), this.boundingClientRect = f(e.boundingClientRect), this.intersectionRect = f(e.intersectionRect || p()), this.isIntersecting = !!e.intersectionRect; var t = this.boundingClientRect, n = t.width * t.height, r = this.intersectionRect, a = r.width * r.height; n ? this.intersectionRatio = Number((a / n).toFixed(4)) : this.intersectionRatio = this.isIntersecting ? 1 : 0 } function s (e, t) { var n = t || {}; if ("function" != typeof e) throw Error("callback must be a function"); if (n.root && 1 != n.root.nodeType && 9 != n.root.nodeType) throw Error("root must be a Document or Element"); this._checkForIntersections = l(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT), this._callback = e, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(n.rootMargin), this.thresholds = this._initThresholds(n.threshold), this.root = n.root || null, this.rootMargin = this._rootMarginValues.map(function (e) { return e.value + e.unit }).join(" "), this._monitoringDocuments = [], this._monitoringUnsubscribes = [] } function o () { return window.performance && performance.now && performance.now() } function l (e, t) { var n = null; return function () { n || (n = setTimeout(function () { e(), n = null }, t)) } } function u (e, t, n, r) { "function" == typeof e.addEventListener ? e.addEventListener(t, n, r || !1) : "function" == typeof e.attachEvent && e.attachEvent("on" + t, n) } function c (e, t, n, r) { "function" == typeof e.removeEventListener ? e.removeEventListener(t, n, r || !1) : "function" == typeof e.detachEvent && e.detachEvent("on" + t, n) } function d (e, t) { var n = Math.max(e.top, t.top), r = Math.min(e.bottom, t.bottom), a = Math.max(e.left, t.left), i = Math.min(e.right, t.right), s = i - a, o = r - n; return s >= 0 && o >= 0 && { top: n, bottom: r, left: a, right: i, width: s, height: o } || null } function h (e) { var t; try { t = e.getBoundingClientRect() } catch (e) { } return t ? (t.width && t.height || (t = { top: t.top, right: t.right, bottom: t.bottom, left: t.left, width: t.right - t.left, height: t.bottom - t.top }), t) : p() } function p () { return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 } } function f (e) { return !e || "x" in e ? e : { top: e.top, y: e.top, bottom: e.bottom, left: e.left, x: e.left, right: e.right, width: e.width, height: e.height } } function m (e, t) { var n = t.top - e.top, r = t.left - e.left; return { top: n, left: r, height: t.height, width: t.width, bottom: n + t.height, right: r + t.width } } function x (e, t) { for (var n = t; n;) { if (n == e) return !0; n = g(n) } return !1 } function g (t) { var n = t.parentNode; return 9 == t.nodeType && t != e ? a(t) : (n && n.assignedSlot && (n = n.assignedSlot.parentNode), n && 11 == n.nodeType && n.host) ? n.host : n } function v (e) { return e && 9 === e.nodeType } }() }, 2895: function (e, t, n) { "use strict"; var r = n(6097); function a (e) { if (Array.isArray(e)) return -1 !== e.indexOf("ssh") || -1 !== e.indexOf("rsync"); if ("string" != typeof e) return !1; var t = r(e); if (e = e.substring(e.indexOf("://") + 3), a(t)) return !0; var n = RegExp(".([a-zA-Z\\d]+):(\\d+)/"); return !e.match(n) && e.indexOf("@") < e.indexOf(":") } e.exports = a }, 2221: function (e, t, n) { "use strict"; var r, a; e.exports = (null == (r = n.g.process) ? void 0 : r.env) && "object" == typeof (null == (a = n.g.process) ? void 0 : a.env) ? n.g.process : n(2286) }, 5596: function (e, t, n) { (window.__NEXT_P = window.__NEXT_P || []).push(["/_app", function () { return n(7126) }]) }, 7126: function (e, t, n) { "use strict"; n.r(t), n.d(t, { __toc: function () { return k }, default: function () { return E } }); var r, a, i = n(2676), s = n(4894), o = n(2629); function l (e) { let { height: t } = e; return (0, i.jsx)("svg", { height: t, viewBox: "0 0 291 69", fill: "none", children: (0, i.jsx)("path", { d: "M0 36.53c.07 17.6 14.4 32.01 32.01 32.01a32.05 32.05 0 0032.01-32V32a13.2 13.2 0 0123.4-8.31h20.7A32.07 32.07 0 0077.2 0a32.05 32.05 0 00-32 32.01v4.52A13.2 13.2 0 0132 49.71a13.2 13.2 0 01-13.18-13.18 3.77 3.77 0 00-3.77-3.77H3.76A3.77 3.77 0 000 36.53zM122.49 68.54a32.14 32.14 0 01-30.89-23.7h20.67a13.16 13.16 0 0023.4-8.3V32A32.05 32.05 0 01167.68 0c17.43 0 31.64 14 32 31.33l.1 5.2a13.2 13.2 0 0023.4 8.31h20.7a32.07 32.07 0 01-30.91 23.7c-17.61 0-31.94-14.42-32.01-32l-.1-4.7v-.2a13.2 13.2 0 00-13.18-12.81 13.2 13.2 0 00-13.18 13.18v4.52a32.05 32.05 0 01-32.01 32.01zM247.94 23.7a13.16 13.16 0 0123.4 8.31 3.77 3.77 0 003.77 3.77h11.3a3.77 3.77 0 003.76-3.77A32.05 32.05 0 00258.16 0a32.07 32.07 0 00-30.92 23.7h20.7z", fill: "currentColor" }) }) } function u (e) { let { height: t = 20 } = e; return (0, i.jsx)("svg", { height: t, viewBox: "0 0 283 64", fill: "none", children: (0, i.jsx)("path", { fill: "currentColor", d: "M141.04 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.46 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM248.72 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.45 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM200.24 34c0 6 3.92 10 10 10 4.12 0 7.21-1.87 8.8-4.92l7.68 4.43c-3.18 5.3-9.14 8.49-16.48 8.49-11.05 0-19-7.2-19-18s7.96-18 19-18c7.34 0 13.29 3.19 16.48 8.49l-7.68 4.43c-1.59-3.05-4.68-4.92-8.8-4.92-6.07 0-10 4-10 10zm82.48-29v46h-9V5h9zM36.95 0L73.9 64H0L36.95 0zm92.38 5l-27.71 48L73.91 5H84.3l17.32 30 17.32-30h10.39zm58.91 12v9.69c-1-.29-2.06-.49-3.2-.49-5.81 0-10 4-10 10V51h-9V17h9v9.2c0-5.08 5.91-9.2 13.2-9.2z" }) }) } var c = n(7133), d = n(1810), h = { i18n: [{ locale: "zh-CN", text: "中文", direction: "ltr" }], defaultLocale: "zh-CN", project: { link: "https://github.com/vercel/swr" }, docsRepositoryBase: "https://github.com/vercel/swr-site/blob/main", useNextSeoProps: () => ({ titleTemplate: "%s – SWR" }), toc: { float: !0, title: () => (0, c.Z)(d.ai) }, search: { placeholder: () => (0, c.Z)(d.pH) }, editLink: { text: () => (0, c.Z)(d.x) }, feedback: { content: () => (0, c.Z)(d.w6) }, logo: () => { let e = (0, c.Z)(d.v7); return (0, i.jsxs)(i.Fragment, { children: [(0, i.jsx)(l, { height: 12 }), (0, i.jsx)("span", { className: "mx-2 font-extrabold hidden md:inline select-none", title: "SWR: ".concat(e), children: "SWR" })] }) }, head: () => { let { route: e } = (0, o.useRouter)(), { frontMatter: t, title: n } = (0, s.ZR)(), r = (0, c.Z)(d.v7), a = (0, c.Z)(d.So), l = new URL("https://swr-card.vercel.app"); /\/index\.+/.test(e) || l.searchParams.set("title", n || r); let u = ["zh-CN"], h = "zh-CN", p = u.join(", "), f = n ? "".concat(n, " – SWR") : "SWR: ".concat(r), m = t.description || a, x = t.image || l.toString(); return (0, i.jsxs)(i.Fragment, { children: [(0, i.jsx)("link", { rel: "apple-touch-icon", sizes: "180x180", href: "/favicon/apple-touch-icon.png" }), (0, i.jsx)("link", { rel: "icon", type: "image/png", sizes: "32x32", href: "/favicon/favicon-32x32.png" }), (0, i.jsx)("link", { rel: "icon", type: "image/png", sizes: "16x16", href: "/favicon/favicon-16x16.png" }), (0, i.jsx)("link", { rel: "icon", type: "image/svg+xml", href: "/favicon/favicon.svg" }), (0, i.jsx)("link", { rel: "manifest", href: "/favicon/site.webmanifest" }), (0, i.jsx)("link", { rel: "mask-icon", href: "/favicon/safari-pinned-tab.svg", color: "#000000" }), (0, i.jsx)("meta", { httpEquiv: "Content-Language", content: p }), (0, i.jsx)("meta", { name: "msapplication-TileColor", content: "#ffffff" }), (0, i.jsx)("meta", { name: "apple-mobile-web-app-title", content: "SWR" }), (0, i.jsx)("meta", { name: "description", content: m }), (0, i.jsx)("meta", { name: "twitter:card", content: "summary_large_image" }), (0, i.jsx)("meta", { name: "twitter:site", content: "@vercel" }), (0, i.jsx)("meta", { name: "twitter:image", content: x }), (0, i.jsx)("meta", { property: "og:title", content: f }), (0, i.jsx)("meta", { property: "og:description", content: m }), (0, i.jsx)("meta", { property: "og:image", content: x }), (0, i.jsx)("meta", { property: "og:locale", content: h }), u.filter(e => e !== h).map(e => (0, i.jsx)("meta", { property: "og:locale:alternate", content: e }, e))] }) }, footer: { text: () => { let { utmSource: e, text: t, suffix: n } = (0, c.Z)(d.$Q); return (0, i.jsxs)("a", { href: "https://vercel.com/?utm_source=".concat(e), target: "_blank", rel: "noopener", className: "inline-flex items-center no-underline text-current font-semibold", children: [(0, i.jsx)("span", { className: "mr-2", children: t }), (0, i.jsx)("span", { children: (0, i.jsx)(u, {}) }), n ? (0, i.jsx)("span", { className: "ml-2", children: n }) : null] }) } }, gitTimestamp (e) { let { timestamp: t } = e, { locale: n } = (0, o.useRouter)(), r = (0, c.Z)(d.qB); return (0, i.jsxs)(i.Fragment, { children: [r, " ", (0, i.jsx)("time", { dateTime: t.toISOString(), children: t.toLocaleDateString(n, { day: "numeric", month: "long", year: "numeric" }) })] }) } }; n(2477), n(9704); var p = n(5271), f = "@vercel/analytics", m = "0.1.11", x = () => { window.va || (window.va = function (...e) { (window.vaq = window.vaq || []).push(e) }) }; function g () { return "undefined" != typeof window } function v () { try { let e = "production"; return "development" === e || "test" === e } catch (e) { return !1 } } function y (e = "auto") { return "auto" === e ? v() ? "development" : "production" : e } var b = (e = { debug: !0 }) => { var t; if (!g()) return; let n = y(e.mode); x(), e.beforeSend && (null == (t = window.va) || t.call(window, "beforeSend", e.beforeSend)); let r = "development" === n ? "https://cdn.vercel-insights.com/v1/script.debug.js" : "/_vercel/insights/script.js"; if (document.head.querySelector(`script[src*="${r}"]`)) return; let a = document.createElement("script"); a.src = r, a.defer = !0, a.setAttribute("data-sdkn", f), a.setAttribute("data-sdkv", m), "development" === n && !1 === e.debug && a.setAttribute("data-debug", "false"), document.head.appendChild(a) }; function _ ({ beforeSend: e, debug: t = !0, mode: n = "auto" }) { return (0, p.useEffect)(() => { b({ beforeSend: e, debug: t, mode: n }) }, [e, t, n]), null } let w = function (e) { let { Component: t, pageProps: n } = e; return (0, i.jsxs)(i.Fragment, { children: [(0, i.jsx)(t, { ...n }), (0, i.jsx)(_, {})] }) }, k = []; function j (e) { return (0, i.jsx)(i.Fragment, {}) } var E = function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return (0, i.jsx)(w, { ...e, children: (0, i.jsx)(j, { ...e }) }) }; let O = (r = globalThis)[a = Symbol.for("__nextra_internal__")] || (r[a] = Object.create(null)); O.Layout = s.ZP, O.pageMap = [{ kind: "Folder", name: "blog", route: "/blog.html", children: [{ kind: "MdxPage", name: "swr-v1", route: "/blog/swr-v1.html", frontMatter: { image: "https://assets.vercel.com/image/upload/v1630059453/swr/v1.png", description: "大约两年前，我们开源了 SWR——广受大家喜爱的小巧 React 数据请求库。今天，我们迎来了另一个里程碑：SWR 1.0 版本发布了！", date: "August 27th, 2021" } }, { kind: "MdxPage", name: "swr-v2", route: "/blog/swr-v2.html", frontMatter: { image: "https://assets.vercel.com/image/upload/v1670542323/swr/v2.png", description: "SWR 2.0 发布：新的数据更改 API、经过优化的乐观 UI 功能、新的 DevTools、以及对并发渲染的更好支持，以及更多功能。", date: "December 9th, 2022" } }, { kind: "Meta", data: { "swr-v1": "SWR V1", "swr-v2": "SWR V2" } }] }, { kind: "MdxPage", name: "blog", route: "/blog.html", frontMatter: { title: "Blog", searchable: !1 } }, { kind: "Folder", name: "docs", route: "/docs", children: [{ kind: "Folder", name: "advanced", route: "/docs/advanced.html", children: [{ kind: "MdxPage", name: "cache", route: "/docs/advanced/cache.html" }, { kind: "MdxPage", name: "devtools", route: "/docs/advanced/devtools.html" }, { kind: "MdxPage", name: "performance", route: "/docs/advanced/performance.html" }, { kind: "MdxPage", name: "react-native", route: "/docs/advanced/react-native.html" }, { kind: "MdxPage", name: "understanding", route: "/docs/advanced/understanding.html" }, { kind: "Meta", data: { cache: "Cache", devtools: "Devtools", performance: "Performance", "react-native": "React Native", understanding: "Understanding" } }] }, { kind: "MdxPage", name: "api", route: "/docs/api.html" }, { kind: "MdxPage", name: "arguments", route: "/docs/arguments.html" }, { kind: "MdxPage", name: "conditional-fetching", route: "/docs/conditional-fetching.html" }, { kind: "MdxPage", name: "data-fetching", route: "/docs/data-fetching.html" }, { kind: "MdxPage", name: "error-handling", route: "/docs/error-handling.html" }, { kind: "MdxPage", name: "getting-started", route: "/docs/getting-started.html" }, { kind: "MdxPage", name: "global-configuration", route: "/docs/global-configuration.html" }, { kind: "MdxPage", name: "middleware", route: "/docs/middleware.html" }, { kind: "MdxPage", name: "mutation", route: "/docs/mutation.html" }, { kind: "MdxPage", name: "pagination", route: "/docs/pagination.html" }, { kind: "MdxPage", name: "prefetching", route: "/docs/prefetching.html" }, { kind: "MdxPage", name: "revalidation", route: "/docs/revalidation.html" }, { kind: "MdxPage", name: "subscription", route: "/docs/subscription.html" }, { kind: "MdxPage", name: "suspense", route: "/docs/suspense.html" }, { kind: "MdxPage", name: "typescript", route: "/docs/typescript.html" }, { kind: "MdxPage", name: "with-nextjs", route: "/docs/with-nextjs.html" }, { kind: "Meta", data: { api: "API", arguments: "Arguments", "conditional-fetching": "Conditional Fetching", "data-fetching": "Data Fetching", "error-handling": "Error Handling", "getting-started": "Getting Started", "global-configuration": "Global Configuration", middleware: "Middleware", mutation: "Mutation", pagination: "Pagination", prefetching: "Prefetching", revalidation: "Revalidation", subscription: "Subscription", suspense: "Suspense", typescript: "TypeScript", "with-nextjs": "With Nextjs" } }] }, { kind: "Folder", name: "examples", route: "/examples", children: [{ kind: "MdxPage", name: "auth", route: "/examples/auth.html", frontMatter: { title: "身份验证", full: !0 } }, { kind: "MdxPage", name: "basic", route: "/examples/basic.html", frontMatter: { title: "基本用法", full: !0 } }, { kind: "MdxPage", name: "error-handling", route: "/examples/error-handling.html", frontMatter: { title: "错误处理", full: !0 } }, { kind: "MdxPage", name: "infinite-loading", route: "/examples/infinite-loading.html", frontMatter: { title: "无限加载", full: !0 } }, { kind: "MdxPage", name: "optimistic-ui", route: "/examples/optimistic-ui.html", frontMatter: { title: "Optimistic UI", full: !0 } }, { kind: "MdxPage", name: "ssr", route: "/examples/ssr.html", frontMatter: { title: "Next.js SSR", full: !0 } }, { kind: "MdxPage", name: "subscription", route: "/examples/subscription.html", frontMatter: { title: "Subscription", full: !0 } }, { kind: "Meta", data: { "error-handling": "错误处理", basic: "基本用法", auth: "身份验证", "infinite-loading": "无限加载", ssr: "Next.js SSR", "optimistic-ui": "Optimistic UI", subscription: "Subscription" } }] }, { kind: "MdxPage", name: "index", route: "/", frontMatter: { title: "用于数据请求的 React Hooks 库" } }, { kind: "Meta", data: { index: "用于数据请求的 React Hooks 库", blog: "Blog" } }], O.flexsearch = { codeblocks: !1 }, O.themeConfig = h }, 7133: function (e, t, n) { "use strict"; n.d(t, { Z: function () { return a } }); var r = n(2629); function a (e) { (0, r.useRouter)(); let t = "zh-CN"; if (!e) throw Error("Pass a locales map as argument to useLocalesMap"); return e[t] } }, 2698: function (e, t) { "use strict"; var n, r; Object.defineProperty(t, "__esModule", { value: !0 }), function (e, t) { for (var n in t) Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }(t, { ACTION_FAST_REFRESH: function () { return u }, ACTION_NAVIGATE: function () { return i }, ACTION_PREFETCH: function () { return l }, ACTION_REFRESH: function () { return a }, ACTION_RESTORE: function () { return s }, ACTION_SERVER_ACTION: function () { return c }, ACTION_SERVER_PATCH: function () { return o }, PrefetchCacheEntryStatus: function () { return r }, PrefetchKind: function () { return n }, isThenable: function () { return d } }); let a = "refresh", i = "navigate", s = "restore", o = "server-patch", l = "prefetch", u = "fast-refresh", c = "server-action"; function d (e) { return e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then } !function (e) { e.AUTO = "auto", e.FULL = "full", e.TEMPORARY = "temporary" }(n || (n = {})), function (e) { e.fresh = "fresh", e.reusable = "reusable", e.expired = "expired", e.stale = "stale" }(r || (r = {})), ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", { value: !0 }), Object.assign(t.default, t), e.exports = t.default) }, 7878: function (e, t, n) { "use strict"; function r (e, t, n, r) { return !1 } Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "getDomainLocale", { enumerable: !0, get: function () { return r } }), n(7278), ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", { value: !0 }), Object.assign(t.default, t), e.exports = t.default) }, 1768: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "Image", { enumerable: !0, get: function () { return y } }); let r = n(2430), a = n(1778), i = n(2676), s = a._(n(5271)), o = r._(n(967)), l = r._(n(7433)), u = n(4117), c = n(837), d = n(322); n(3048); let h = n(3452), p = r._(n(4702)), f = { deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], imageSizes: [16, 32, 48, 64, 96, 128, 256, 384], path: "/_next/image", loader: "default", dangerouslyAllowSVG: !1, unoptimized: !0 }; function m (e, t, n, r, a, i, s) { let o = null == e ? void 0 : e.src; e && e["data-loaded-src"] !== o && (e["data-loaded-src"] = o, ("decode" in e ? e.decode() : Promise.resolve()).catch(() => { }).then(() => { if (e.parentElement && e.isConnected) { if ("empty" !== t && a(!0), null == n ? void 0 : n.current) { let t = new Event("load"); Object.defineProperty(t, "target", { writable: !1, value: e }); let r = !1, a = !1; n.current({ ...t, nativeEvent: t, currentTarget: e, target: e, isDefaultPrevented: () => r, isPropagationStopped: () => a, persist: () => { }, preventDefault: () => { r = !0, t.preventDefault() }, stopPropagation: () => { a = !0, t.stopPropagation() } }) } (null == r ? void 0 : r.current) && r.current(e) } })) } function x (e) { return s.use ? { fetchPriority: e } : { fetchpriority: e } } let g = (0, s.forwardRef)((e, t) => { let { src: n, srcSet: r, sizes: a, height: o, width: l, decoding: u, className: c, style: d, fetchPriority: h, placeholder: p, loading: f, unoptimized: g, fill: v, onLoadRef: y, onLoadingCompleteRef: b, setBlurComplete: _, setShowAltText: w, sizesInput: k, onLoad: j, onError: E, ...O } = e; return (0, i.jsx)("img", { ...O, ...x(h), loading: f, width: l, height: o, decoding: u, "data-nimg": v ? "fill" : "1", className: c, style: d, sizes: a, srcSet: r, src: n, ref: (0, s.useCallback)(e => { t && ("function" == typeof t ? t(e) : "object" == typeof t && (t.current = e)), e && (E && (e.src = e.src), e.complete && m(e, p, y, b, _, g, k)) }, [n, p, y, b, _, E, g, k, t]), onLoad: e => { m(e.currentTarget, p, y, b, _, g, k) }, onError: e => { w(!0), "empty" !== p && _(!0), E && E(e) } }) }); function v (e) { let { isAppRouter: t, imgAttributes: n } = e, r = { as: "image", imageSrcSet: n.srcSet, imageSizes: n.sizes, crossOrigin: n.crossOrigin, referrerPolicy: n.referrerPolicy, ...x(n.fetchPriority) }; return t && o.default.preload ? (o.default.preload(n.src, r), null) : (0, i.jsx)(l.default, { children: (0, i.jsx)("link", { rel: "preload", href: n.srcSet ? void 0 : n.src, ...r }, "__nimg-" + n.src + n.srcSet + n.sizes) }) } let y = (0, s.forwardRef)((e, t) => { let n = !(0, s.useContext)(h.RouterContext), r = (0, s.useContext)(d.ImageConfigContext), a = (0, s.useMemo)(() => { var e; let t = f || r || c.imageConfigDefault, n = [...t.deviceSizes, ...t.imageSizes].sort((e, t) => e - t), a = t.deviceSizes.sort((e, t) => e - t), i = null == (e = t.qualities) ? void 0 : e.sort((e, t) => e - t); return { ...t, allSizes: n, deviceSizes: a, qualities: i } }, [r]), { onLoad: o, onLoadingComplete: l } = e, m = (0, s.useRef)(o); (0, s.useEffect)(() => { m.current = o }, [o]); let x = (0, s.useRef)(l); (0, s.useEffect)(() => { x.current = l }, [l]); let [y, b] = (0, s.useState)(!1), [_, w] = (0, s.useState)(!1), { props: k, meta: j } = (0, u.getImgProps)(e, { defaultLoader: p.default, imgConf: a, blurComplete: y, showAltText: _ }); return (0, i.jsxs)(i.Fragment, { children: [(0, i.jsx)(g, { ...k, unoptimized: j.unoptimized, placeholder: j.placeholder, fill: j.fill, onLoadRef: m, onLoadingCompleteRef: x, setBlurComplete: b, setShowAltText: w, sizesInput: e.sizes, ref: t }), j.priority ? (0, i.jsx)(v, { isAppRouter: n, imgAttributes: k }) : null] }) }); ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", { value: !0 }), Object.assign(t.default, t), e.exports = t.default) }, 5219: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "default", { enumerable: !0, get: function () { return w } }); let r = n(2430), a = n(2676), i = r._(n(5271)), s = n(7681), o = n(6138), l = n(4057), u = n(5805), c = n(0), d = n(3452), h = n(9970), p = n(4212), f = n(7878), m = n(7631), x = n(2698), g = new Set; function v (e, t, n, r, a, i) { if (i || (0, o.isLocalURL)(t)) { if (!r.bypassPrefetchedCheck) { let a = t + "%" + n + "%" + (void 0 !== r.locale ? r.locale : "locale" in e ? e.locale : void 0); if (g.has(a)) return; g.add(a) } (async () => i ? e.prefetch(t, a) : e.prefetch(t, n, r))().catch(e => { }) } } function y (e) { let t = e.currentTarget.getAttribute("target"); return t && "_self" !== t || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey || e.nativeEvent && 2 === e.nativeEvent.which } function b (e, t, n, r, a, s, l, u, c) { let { nodeName: d } = e.currentTarget; if ("A" === d.toUpperCase() && (y(e) || !c && !(0, o.isLocalURL)(n))) return; e.preventDefault(); let h = () => { let e = null == l || l; "beforePopState" in t ? t[a ? "replace" : "push"](n, r, { shallow: s, locale: u, scroll: e }) : t[a ? "replace" : "push"](r || n, { scroll: e }) }; c ? i.default.startTransition(h) : h() } function _ (e) { return "string" == typeof e ? e : (0, l.formatUrl)(e) } let w = i.default.forwardRef(function (e, t) { let n, r; let { href: o, as: l, children: g, prefetch: y = null, passHref: w, replace: k, shallow: j, scroll: E, locale: O, onClick: T, onMouseEnter: C, onTouchStart: S, legacyBehavior: N = !1, ...I } = e; n = g, N && ("string" == typeof n || "number" == typeof n) && (n = (0, a.jsx)("a", { children: n })); let A = i.default.useContext(d.RouterContext), R = i.default.useContext(h.AppRouterContext), P = null != A ? A : R, M = !A, L = !1 !== y, Z = null === y ? x.PrefetchKind.AUTO : x.PrefetchKind.FULL, { href: D, as: F } = i.default.useMemo(() => { if (!A) { let e = _(o); return { href: e, as: l ? _(l) : e } } let [e, t] = (0, s.resolveHref)(A, o, !0); return { href: e, as: l ? (0, s.resolveHref)(A, l) : t || e } }, [A, o, l]), z = i.default.useRef(D), $ = i.default.useRef(F); N && (r = i.default.Children.only(n)); let U = N ? r && "object" == typeof r && r.ref : t, [W, H, V] = (0, p.useIntersection)({ rootMargin: "200px" }), B = i.default.useCallback(e => { ($.current !== F || z.current !== D) && (V(), $.current = F, z.current = D), W(e), U && ("function" == typeof U ? U(e) : "object" == typeof U && (U.current = e)) }, [F, U, D, V, W]); i.default.useEffect(() => { P && H && L && v(P, D, F, { locale: O }, { kind: Z }, M) }, [F, D, H, O, L, null == A ? void 0 : A.locale, P, M, Z]); let G = { ref: B, onClick (e) { N || "function" != typeof T || T(e), N && r.props && "function" == typeof r.props.onClick && r.props.onClick(e), P && !e.defaultPrevented && b(e, P, D, F, k, j, E, O, M) }, onMouseEnter (e) { N || "function" != typeof C || C(e), N && r.props && "function" == typeof r.props.onMouseEnter && r.props.onMouseEnter(e), P && (L || !M) && v(P, D, F, { locale: O, priority: !0, bypassPrefetchedCheck: !0 }, { kind: Z }, M) }, onTouchStart: function (e) { N || "function" != typeof S || S(e), N && r.props && "function" == typeof r.props.onTouchStart && r.props.onTouchStart(e), P && (L || !M) && v(P, D, F, { locale: O, priority: !0, bypassPrefetchedCheck: !0 }, { kind: Z }, M) } }; if ((0, u.isAbsoluteUrl)(F)) G.href = F; else if (!N || w || "a" === r.type && !("href" in r.props)) { let e = void 0 !== O ? O : null == A ? void 0 : A.locale, t = (null == A ? void 0 : A.isLocaleDomain) && (0, f.getDomainLocale)(F, e, null == A ? void 0 : A.locales, null == A ? void 0 : A.domainLocales); G.href = t || (0, m.addBasePath)((0, c.addLocale)(F, e, null == A ? void 0 : A.defaultLocale)) } return N ? i.default.cloneElement(r, G) : (0, a.jsx)("a", { ...I, ...G, children: n }) }); ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", { value: !0 }), Object.assign(t.default, t), e.exports = t.default) }, 4212: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "useIntersection", { enumerable: !0, get: function () { return c } }); let r = n(5271), a = n(9401), i = "function" == typeof IntersectionObserver, s = new Map, o = []; function l (e) { let t; let n = { root: e.root || null, margin: e.rootMargin || "" }, r = o.find(e => e.root === n.root && e.margin === n.margin); if (r && (t = s.get(r))) return t; let a = new Map; return t = { id: n, observer: new IntersectionObserver(e => { e.forEach(e => { let t = a.get(e.target), n = e.isIntersecting || e.intersectionRatio > 0; t && n && t(n) }) }, e), elements: a }, o.push(n), s.set(n, t), t } function u (e, t, n) { let { id: r, observer: a, elements: i } = l(n); return i.set(e, t), a.observe(e), function () { if (i.delete(e), a.unobserve(e), 0 === i.size) { a.disconnect(), s.delete(r); let e = o.findIndex(e => e.root === r.root && e.margin === r.margin); e > -1 && o.splice(e, 1) } } } function c (e) { let { rootRef: t, rootMargin: n, disabled: s } = e, o = s || !i, [l, c] = (0, r.useState)(!1), d = (0, r.useRef)(null), h = (0, r.useCallback)(e => { d.current = e }, []); return (0, r.useEffect)(() => { if (i) { if (o || l) return; let e = d.current; if (e && e.tagName) return u(e, e => e && c(e), { root: null == t ? void 0 : t.current, rootMargin: n }) } else if (!l) { let e = (0, a.requestIdleCallback)(() => c(!0)); return () => (0, a.cancelIdleCallback)(e) } }, [o, n, t, l, d.current]), [h, l, (0, r.useCallback)(() => { c(!1) }, [])] } ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", { value: !0 }), Object.assign(t.default, t), e.exports = t.default) }, 4117: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "getImgProps", { enumerable: !0, get: function () { return d } }), n(3048); let r = n(8028), a = n(837); function i (e) { return void 0 !== e.default } function s (e) { return void 0 !== e.src } function o (e) { return "object" == typeof e && (i(e) || s(e)) } function l (e) { return void 0 === e ? e : "number" == typeof e ? Number.isFinite(e) ? e : NaN : "string" == typeof e && /^[0-9]+$/.test(e) ? parseInt(e, 10) : NaN } function u (e, t, n) { let { deviceSizes: r, allSizes: a } = e; if (n) { let e = /(^|\s)(1?\d?\d)vw/g, t = []; for (let r; r = e.exec(n); r)t.push(parseInt(r[2])); if (t.length) { let e = .01 * Math.min(...t); return { widths: a.filter(t => t >= r[0] * e), kind: "w" } } return { widths: a, kind: "w" } } return "number" != typeof t ? { widths: r, kind: "w" } : { widths: [...new Set([t, 2 * t].map(e => a.find(t => t >= e) || a[a.length - 1]))], kind: "x" } } function c (e) { let { config: t, src: n, unoptimized: r, width: a, quality: i, sizes: s, loader: o } = e; if (r) return { src: n, srcSet: void 0, sizes: void 0 }; let { widths: l, kind: c } = u(t, a, s), d = l.length - 1; return { sizes: s || "w" !== c ? s : "100vw", srcSet: l.map((e, r) => o({ config: t, src: n, quality: i, width: e }) + " " + ("w" === c ? e : r + 1) + c).join(", "), src: o({ config: t, src: n, quality: i, width: l[d] }) } } function d (e, t) { let n, s, u, { src: d, sizes: h, unoptimized: p = !1, priority: f = !1, loading: m, className: x, quality: g, width: v, height: y, fill: b = !1, style: _, overrideSrc: w, onLoad: k, onLoadingComplete: j, placeholder: E = "empty", blurDataURL: O, fetchPriority: T, decoding: C = "async", layout: S, objectFit: N, objectPosition: I, lazyBoundary: A, lazyRoot: R, ...P } = e, { imgConf: M, showAltText: L, blurComplete: Z, defaultLoader: D } = t, F = M || a.imageConfigDefault; if ("allSizes" in F) n = F; else { var z; let e = [...F.deviceSizes, ...F.imageSizes].sort((e, t) => e - t), t = F.deviceSizes.sort((e, t) => e - t), r = null == (z = F.qualities) ? void 0 : z.sort((e, t) => e - t); n = { ...F, allSizes: e, deviceSizes: t, qualities: r } } if (void 0 === D) throw Error("images.loaderFile detected but the file is missing default export.\nRead more: https://nextjs.org/docs/messages/invalid-images-config.html"); let $ = P.loader || D; delete P.loader, delete P.srcSet; let U = "__next_img_default" in $; if (U) { if ("custom" === n.loader) throw Error('Image with src "' + d + '" is missing "loader" prop.\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader') } else { let e = $; $ = t => { let { config: n, ...r } = t; return e(r) } } if (S) { .html"fill" === S && (b = !0); let e = { responsive: "100vw", fill: "100vw" }, t = { intrinsic: { maxWidth: "100%", height: "auto" }, responsive: { width: "100%", height: "auto" } }[S]; t && (_ = { ..._, ...t }); let n = e[S]; n && !h && (h = n) } let W = "", H = l(v), V = l(y); if (o(d)) { let e = i(d) ? d.default : d; if (!e.src) throw Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received " + JSON.stringify(e)); if (!e.height || !e.width) throw Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received " + JSON.stringify(e)); if (s = e.blurWidth, u = e.blurHeight, O = O || e.blurDataURL, W = e.src, !b) { if (H || V) { if (H && !V) { let t = H / e.width; V = Math.round(e.height * t) } else if (!H && V) { let t = V / e.height; H = Math.round(e.width * t) } } else H = e.width, V = e.height } } let B = !f && ("lazy" === m || void 0 === m); (!(d = "string" == typeof d ? d : W) || d.startsWith("data:") || d.startsWith("blob:")) && (p = !0, B = !1), n.unoptimized && (p = !0), U && d.endsWith(".svg") && !n.dangerouslyAllowSVG && (p = !0), f && (T = "high"); let G = l(g), q = Object.assign(b ? { position: "absolute", height: "100%", width: "100%", left: 0, top: 0, right: 0, bottom: 0, objectFit: N, objectPosition: I } : {}, L ? {} : { color: "transparent" }, _), K = Z || "empty" === E ? null : "blur" === E ? 'url("data:image/svg+xml;charset=utf-8,' + (0, r.getImageBlurSvg)({ widthInt: H, heightInt: V, blurWidth: s, blurHeight: u, blurDataURL: O || "", objectFit: q.objectFit }) + '")' : 'url("' + E + '")', Q = K ? { backgroundSize: q.objectFit || "cover", backgroundPosition: q.objectPosition || "50% 50%", backgroundRepeat: "no-repeat", backgroundImage: K } : {}, Y = c({ config: n, src: d, unoptimized: p, width: H, quality: G, sizes: h, loader: $ }); return { props: { ...P, loading: B ? "lazy" : m, fetchPriority: T, width: H, height: V, decoding: C, className: x, style: { ...q, ...Q }, sizes: Y.sizes, srcSet: Y.srcSet, src: w || Y.src }, meta: { unoptimized: p, priority: f, placeholder: E, fill: b } } } }, 8028: function (e, t) { "use strict"; function n (e) { let { widthInt: t, heightInt: n, blurWidth: r, blurHeight: a, blurDataURL: i, objectFit: s } = e, o = r ? 40 * r : t, l = a ? 40 * a : n, u = o && l ? "viewBox='0 0 " + o + " " + l + "'" : "", c = u ? "none" : "contain" === s ? "xMidYMid" : "cover" === s ? "xMidYMid slice" : "none"; return "%3Csvg xmlns='http://www.w3.org/2000/svg' " + u + "%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='" + c + "' style='filter: url(%23b);' href='" + i + "'/%3E%3C/svg%3E" } Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "getImageBlurSvg", { enumerable: !0, get: function () { return n } }) }, 4513: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), function (e, t) { for (var n in t) Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }(t, { default: function () { return l }, getImageProps: function () { return o } }); let r = n(2430), a = n(4117), i = n(1768), s = r._(n(4702)); function o (e) { let { props: t } = (0, a.getImgProps)(e, { defaultLoader: s.default, imgConf: { deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], imageSizes: [16, 32, 48, 64, 96, 128, 256, 384], path: "/_next/image", loader: "default", dangerouslyAllowSVG: !1, unoptimized: !0 } }); for (let [e, n] of Object.entries(t)) void 0 === n && delete t[e]; return { props: t } } let l = i.Image }, 4702: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "default", { enumerable: !0, get: function () { return a } }); let n = 75; function r (e) { var t; let { config: r, src: a, width: i, quality: s } = e, o = s || (null == (t = r.qualities) ? void 0 : t.reduce((e, t) => Math.abs(t - n) < Math.abs(e - n) ? t : e)) || n; return r.path + "?url=" + encodeURIComponent(a) + "&w=" + i + "&q=" + o } r.__next_img_default = !0; let a = r }, 1810: function (e, t, n) { "use strict"; n.d(t, { $Q: function () { return l }, So: function () { return i }, ai: function () { return u }, pH: function () { return c }, qB: function () { return d }, v7: function () { return r }, w6: function () { return s }, x: function () { return o }, zN: function () { return a } }); let r = { "zh-CN": "用于数据请求的 React Hooks 库" }, a = { "zh-CN": { lightweight: "轻量级", realtime: "实时性", suspense: "Suspense", pagination: "分页", backendAgnostic: "后端无关", renderingStrategies: "渲染策略", typescript: "TypeScript", remoteLocal: "远程+本地" } }, i = { "zh-CN": "SWR 是一个用于数据请求的 React Hooks 库。SWR 首先从缓存中返回数据（过期的），然后发送请求（重新验证），最后携带最新数据再次更新。" }, s = { "zh-CN": "有疑问？给我们反馈 →" }, o = { "zh-CN": "在 GitHub 上编辑本页 →" }, l = { "zh-CN": { utmSource: "swr_zh-cn", text: "由", suffix: "驱动" } }, u = { "zh-CN": "本页内容" }, c = { "zh-CN": "搜索文档..." }, d = { "zh-CN": "最后更新于" } }, 2477: function () { }, 9704: function () { }, 7442: function (e) { var t = "/"; !function () { "use strict"; var n = { 114: function (e) { function t (e) { if ("string" != typeof e) throw TypeError("Path must be a string. Received " + JSON.stringify(e)) } function n (e, t) { for (var n, r = "", a = 0, i = -1, s = 0, o = 0; o <= e.length; ++o) { if (o < e.length) n = e.charCodeAt(o); else if (47 === n) break; else n = 47; if (47 === n) { if (i === o - 1 || 1 === s); else if (i !== o - 1 && 2 === s) { if (r.length < 2 || 2 !== a || 46 !== r.charCodeAt(r.length - 1) || 46 !== r.charCodeAt(r.length - 2)) { if (r.length > 2) { var l = r.lastIndexOf("/"); if (l !== r.length - 1) { -1 === l ? (r = "", a = 0) : a = (r = r.slice(0, l)).length - 1 - r.lastIndexOf("/"), i = o, s = 0; continue } } else if (2 === r.length || 1 === r.length) { r = "", a = 0, i = o, s = 0; continue } } t && (r.length > 0 ? r += "/.." : r = "..", a = 2) } else r.length > 0 ? r += "/" + e.slice(i + 1, o) : r = e.slice(i + 1, o), a = o - i - 1; i = o, s = 0 } else 46 === n && -1 !== s ? ++s : s = -1 } return r } function r (e, t) { var n = t.dir || t.root, r = t.base || (t.name || "") + (t.ext || ""); return n ? n === t.root ? n + r : n + e + r : r } var a = { resolve: function () { for (var e, r, a = "", i = !1, s = arguments.length - 1; s >= -1 && !i; s--)s >= 0 ? r = arguments[s] : (void 0 === e && (e = ""), r = e), t(r), 0 !== r.length && (a = r + "/" + a, i = 47 === r.charCodeAt(0)); return (a = n(a, !i), i) ? a.length > 0 ? "/" + a : "/" : a.length > 0 ? a : "." }, normalize: function (e) { if (t(e), 0 === e.length) return "."; var r = 47 === e.charCodeAt(0), a = 47 === e.charCodeAt(e.length - 1); return (0 !== (e = n(e, !r)).length || r || (e = "."), e.length > 0 && a && (e += "/"), r) ? "/" + e : e }, isAbsolute: function (e) { return t(e), e.length > 0 && 47 === e.charCodeAt(0) }, join: function () { if (0 == arguments.length) return "."; for (var e, n = 0; n < arguments.length; ++n) { var r = arguments[n]; t(r), r.length > 0 && (void 0 === e ? e = r : e += "/" + r) } return void 0 === e ? "." : a.normalize(e) }, relative: function (e, n) { if (t(e), t(n), e === n || (e = a.resolve(e)) === (n = a.resolve(n))) return ""; for (var r = 1; r < e.length && 47 === e.charCodeAt(r); ++r); for (var i = e.length, s = i - r, o = 1; o < n.length && 47 === n.charCodeAt(o); ++o); for (var l = n.length - o, u = s < l ? s : l, c = -1, d = 0; d <= u; ++d) { if (d === u) { if (l > u) { if (47 === n.charCodeAt(o + d)) return n.slice(o + d + 1); if (0 === d) return n.slice(o + d) } else s > u && (47 === e.charCodeAt(r + d) ? c = d : 0 === d && (c = 0)); break } var h = e.charCodeAt(r + d); if (h !== n.charCodeAt(o + d)) break; 47 === h && (c = d) } var p = ""; for (d = r + c + 1; d <= i; ++d)(d === i || 47 === e.charCodeAt(d)) && (0 === p.length ? p += ".." : p += "/.."); return p.length > 0 ? p + n.slice(o + c) : (o += c, 47 === n.charCodeAt(o) && ++o, n.slice(o)) }, _makeLong: function (e) { return e }, dirname: function (e) { if (t(e), 0 === e.length) return "."; for (var n = e.charCodeAt(0), r = 47 === n, a = -1, i = !0, s = e.length - 1; s >= 1; --s)if (47 === (n = e.charCodeAt(s))) { if (!i) { a = s; break } } else i = !1; return -1 === a ? r ? "/" : "." : r && 1 === a ? "//" : e.slice(0, a) }, basename: function (e, n) { if (void 0 !== n && "string" != typeof n) throw TypeError('"ext" argument must be a string'); t(e); var r, a = 0, i = -1, s = !0; if (void 0 !== n && n.length > 0 && n.length <= e.length) { if (n.length === e.length && n === e) return ""; var o = n.length - 1, l = -1; for (r = e.length - 1; r >= 0; --r) { var u = e.charCodeAt(r); if (47 === u) { if (!s) { a = r + 1; break } } else -1 === l && (s = !1, l = r + 1), o >= 0 && (u === n.charCodeAt(o) ? -1 == --o && (i = r) : (o = -1, i = l)) } return a === i ? i = l : -1 === i && (i = e.length), e.slice(a, i) } for (r = e.length - 1; r >= 0; --r)if (47 === e.charCodeAt(r)) { if (!s) { a = r + 1; break } } else -1 === i && (s = !1, i = r + 1); return -1 === i ? "" : e.slice(a, i) }, extname: function (e) { t(e); for (var n = -1, r = 0, a = -1, i = !0, s = 0, o = e.length - 1; o >= 0; --o) { var l = e.charCodeAt(o); if (47 === l) { if (!i) { r = o + 1; break } continue } -1 === a && (i = !1, a = o + 1), 46 === l ? -1 === n ? n = o : 1 !== s && (s = 1) : -1 !== n && (s = -1) } return -1 === n || -1 === a || 0 === s || 1 === s && n === a - 1 && n === r + 1 ? "" : e.slice(n, a) }, format: function (e) { if (null === e || "object" != typeof e) throw TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e); return r("/", e) }, parse: function (e) { t(e); var n, r = { root: "", dir: "", base: "", ext: "", name: "" }; if (0 === e.length) return r; var a = e.charCodeAt(0), i = 47 === a; i ? (r.root = "/", n = 1) : n = 0; for (var s = -1, o = 0, l = -1, u = !0, c = e.length - 1, d = 0; c >= n; --c) { if (47 === (a = e.charCodeAt(c))) { if (!u) { o = c + 1; break } continue } -1 === l && (u = !1, l = c + 1), 46 === a ? -1 === s ? s = c : 1 !== d && (d = 1) : -1 !== s && (d = -1) } return -1 === s || -1 === l || 0 === d || 1 === d && s === l - 1 && s === o + 1 ? -1 !== l && (0 === o && i ? r.base = r.name = e.slice(1, l) : r.base = r.name = e.slice(o, l)) : (0 === o && i ? (r.name = e.slice(1, s), r.base = e.slice(1, l)) : (r.name = e.slice(o, s), r.base = e.slice(o, l)), r.ext = e.slice(s, l)), o > 0 ? r.dir = e.slice(0, o - 1) : i && (r.dir = "/"), r }, sep: "/", delimiter: ":", win32: null, posix: null }; a.posix = a, e.exports = a } }, r = {}; function a (e) { var t = r[e]; if (void 0 !== t) return t.exports; var i = r[e] = { exports: {} }, s = !0; try { n[e](i, i.exports, a), s = !1 } finally { s && delete r[e] } return i.exports } a.ab = t + "/"; var i = a(114); e.exports = i }() }, 2286: function (e) { var t = "/"; !function () { var n = { 229: function (e) { var t, n, r, a = e.exports = {}; function i () { throw Error("setTimeout has not been defined") } function s () { throw Error("clearTimeout has not been defined") } function o (e) { if (t === setTimeout) return setTimeout(e, 0); if ((t === i || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0); try { return t(e, 0) } catch (n) { try { return t.call(null, e, 0) } catch (n) { return t.call(this, e, 0) } } } function l (e) { if (n === clearTimeout) return clearTimeout(e); if ((n === s || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e); try { return n(e) } catch (t) { try { return n.call(null, e) } catch (t) { return n.call(this, e) } } } !function () { try { t = "function" == typeof setTimeout ? setTimeout : i } catch (e) { t = i } try { n = "function" == typeof clearTimeout ? clearTimeout : s } catch (e) { n = s } }(); var u = [], c = !1, d = -1; function h () { c && r && (c = !1, r.length ? u = r.concat(u) : d = -1, u.length && p()) } function p () { if (!c) { var e = o(h); c = !0; for (var t = u.length; t;) { for (r = u, u = []; ++d < t;)r && r[d].run(); d = -1, t = u.length } r = null, c = !1, l(e) } } function f (e, t) { this.fun = e, this.array = t } function m () { } a.nextTick = function (e) { var t = Array(arguments.length - 1); if (arguments.length > 1) for (var n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; u.push(new f(e, t)), 1 !== u.length || c || o(p) }, f.prototype.run = function () { this.fun.apply(null, this.array) }, a.title = "browser", a.browser = !0, a.env = {}, a.argv = [], a.version = "", a.versions = {}, a.on = m, a.addListener = m, a.once = m, a.off = m, a.removeListener = m, a.removeAllListeners = m, a.emit = m, a.prependListener = m, a.prependOnceListener = m, a.listeners = function (e) { return [] }, a.binding = function (e) { throw Error("process.binding is not supported") }, a.cwd = function () { return "/" }, a.chdir = function (e) { throw Error("process.chdir is not supported") }, a.umask = function () { return 0 } } }, r = {}; function a (e) { var t = r[e]; if (void 0 !== t) return t.exports; var i = r[e] = { exports: {} }, s = !0; try { n[e](i, i.exports, a), s = !1 } finally { s && delete r[e] } return i.exports } a.ab = t + "/"; var i = a(229); e.exports = i }() }, 8225: function (e, t, n) { e.exports = n(7433) }, 9263: function (e, t, n) { e.exports = n(4513) }, 1530: function (e, t, n) { e.exports = n(5219) }, 2629: function (e, t, n) { e.exports = n(8040) }, 4894: function (e, t, n) {
    "use strict"; let r, a, i, s, o, l, u, c, d, h, p, f, m, x, g, v, y, b, _, w, k, j, E, O, T, C, S, N, I, A, R, P, M, L; n.d(t, { zu: function () { return dl }, UW: function () { return dh }, OK: function () { return d2 }, mQ: function () { return d1 }, ZP: function () { return hv }, ZR: function () { return c3 } }); var Z, D, F, z, $, U, W, H, V, B, G, q, K, Q = n(5271), Y = n.t(Q, 2), J = n(2629); function X (e) { var t, n, r = ""; if ("string" == typeof e || "number" == typeof e) r += e; else if ("object" == typeof e) { if (Array.isArray(e)) for (t = 0; t < e.length; t++)e[t] && (n = X(e[t])) && (r && (r += " "), r += n); else for (t in e) e[t] && (r && (r += " "), r += t) } return r } n(2297); var ee = function () { for (var e, t, n = 0, r = ""; n < arguments.length;)(e = arguments[n++]) && (t = X(e)) && (r && (r += " "), r += t); return r }, et = n(6952); function en () { let [e, t] = (0, Q.useState)(!1); return (0, Q.useEffect)(() => { t(!0) }, []), e } var er = n(7441), ea = "https://nextra.vercel.app", ei = () => { let { locale: e = er.ZW, asPath: t, route: n } = (0, J.useRouter)(); return (0, Q.useMemo)(() => { let { pathname: r } = new URL(er.hV.has(n) ? n : t, ea); return (e ? r.replace(RegExp(`\\.${e}(\\/|$)`), "$1") : r).replace(/\.html$/, "").replace(/\/index(\/|$)/, "$1").replace(/\/$/, "") || "/" }, [t, e, n]) }, es = "14.2.24", eo = n(1530), el = n.n(eo); n(5983); var eu = n(2676); let ec = ["light", "dark"], ed = "(prefers-color-scheme: dark)", eh = "undefined" == typeof window, ep = (0, Q.createContext)(void 0), ef = { setTheme: e => { }, themes: [] }, em = () => { var e; return null !== (e = (0, Q.useContext)(ep)) && void 0 !== e ? e : ef }, ex = e => (0, Q.useContext)(ep) ? Q.createElement(Q.Fragment, null, e.children) : Q.createElement(ev, e), eg = ["light", "dark"], ev = ({ forcedTheme: e, disableTransitionOnChange: t = !1, enableSystem: n = !0, enableColorScheme: r = !0, storageKey: a = "theme", themes: i = eg, defaultTheme: s = n ? "system" : "light", attribute: o = "data-theme", value: l, children: u, nonce: c }) => { let [d, h] = (0, Q.useState)(() => eb(a, s)), [p, f] = (0, Q.useState)(() => eb(a)), m = l ? Object.values(l) : i, x = (0, Q.useCallback)(e => { let a = e; if (!a) return; "system" === e && n && (a = ew()); let i = l ? l[a] : a, u = t ? e_() : null, c = document.documentElement; if ("class" === o ? (c.classList.remove(...m), i && c.classList.add(i)) : i ? c.setAttribute(o, i) : c.removeAttribute(o), r) { let e = ec.includes(s) ? s : null, t = ec.includes(a) ? a : e; c.style.colorScheme = t } null == u || u() }, []), g = (0, Q.useCallback)(e => { h(e); try { localStorage.setItem(a, e) } catch (e) { } }, [e]), v = (0, Q.useCallback)(t => { f(ew(t)), "system" === d && n && !e && x("system") }, [d, e]); (0, Q.useEffect)(() => { let e = window.matchMedia(ed); return e.addListener(v), v(e), () => e.removeListener(v) }, [v]), (0, Q.useEffect)(() => { let e = e => { e.key === a && g(e.newValue || s) }; return window.addEventListener("storage", e), () => window.removeEventListener("storage", e) }, [g]), (0, Q.useEffect)(() => { x(null != e ? e : d) }, [e, d]); let y = (0, Q.useMemo)(() => ({ theme: d, setTheme: g, forcedTheme: e, resolvedTheme: "system" === d ? p : d, themes: n ? [...i, "system"] : i, systemTheme: n ? p : void 0 }), [d, g, e, p, n, i]); return Q.createElement(ep.Provider, { value: y }, Q.createElement(ey, { forcedTheme: e, disableTransitionOnChange: t, enableSystem: n, enableColorScheme: r, storageKey: a, themes: i, defaultTheme: s, attribute: o, value: l, children: u, attrs: m, nonce: c }), u) }, ey = (0, Q.memo)(({ forcedTheme: e, storageKey: t, attribute: n, enableSystem: r, enableColorScheme: a, defaultTheme: i, value: s, attrs: o, nonce: l }) => { let u = "system" === i, c = "class" === n ? `var d=document.documentElement,c=d.classList;c.remove(${o.map(e => `'${e}'`).join(",")});` : `var d=document.documentElement,n='${n}',s='setAttribute';`, d = a ? ec.includes(i) && i ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${i}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "", h = (e, t = !1, r = !0) => { let i = s ? s[e] : e, o = t ? e + "|| ''" : `'${i}'`, l = ""; return a && r && !t && ec.includes(e) && (l += `d.style.colorScheme = '${e}';`), "class" === n ? l += t || i ? `c.add(${o})` : "null" : i && (l += `d[s](n,${o})`), l }, p = e ? `!function(){${c}${h(e)}}()` : r ? `!function(){try{${c}var e=localStorage.getItem('${t}');if('system'===e||(!e&&${u})){var t='${ed}',m=window.matchMedia(t);if(m.media!==t||m.matches){${h("dark")}}else{${h("light")}}}else if(e){${s ? `var x=${JSON.stringify(s)};` : ""}${h(s ? "x[e]" : "e", !0)}}${u ? "" : "else{" + h(i, !1, !1) + "}"}${d}}catch(e){}}()` : `!function(){try{${c}var e=localStorage.getItem('${t}');if(e){${s ? `var x=${JSON.stringify(s)};` : ""}${h(s ? "x[e]" : "e", !0)}}else{${h(i, !1, !1)};}${d}}catch(t){}}();`; return Q.createElement("script", { nonce: l, dangerouslySetInnerHTML: { __html: p } }) }, () => !0), eb = (e, t) => { let n; if (!eh) { try { n = localStorage.getItem(e) || void 0 } catch (e) { } return n || t } }, e_ = () => { let e = document.createElement("style"); return e.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), document.head.appendChild(e), () => { window.getComputedStyle(document.body), setTimeout(() => { document.head.removeChild(e) }, 1) } }, ew = e => (e || (e = window.matchMedia(ed)), e.matches ? "dark" : "light"); !function (e) { function t (e) { } function n (e) { throw Error() } function r (e, t = " | ") { return e.map(e => "string" == typeof e ? `'${e}'` : e).join(t) } e.assertEqual = e => e, e.assertIs = t, e.assertNever = n, e.arrayToEnum = e => { let t = {}; for (let n of e) t[n] = n; return t }, e.getValidEnumValues = t => { let n = e.objectKeys(t).filter(e => "number" != typeof t[t[e]]), r = {}; for (let e of n) r[e] = t[e]; return e.objectValues(r) }, e.objectValues = t => e.objectKeys(t).map(function (e) { return t[e] }), e.objectKeys = "function" == typeof Object.keys ? e => Object.keys(e) : e => { let t = []; for (let n in e) Object.prototype.hasOwnProperty.call(e, n) && t.push(n); return t }, e.find = (e, t) => { for (let n of e) if (t(n)) return n }, e.isInteger = "function" == typeof Number.isInteger ? e => Number.isInteger(e) : e => "number" == typeof e && isFinite(e) && Math.floor(e) === e, e.joinValues = r, e.jsonStringifyReplacer = (e, t) => "bigint" == typeof t ? t.toString() : t }(Z || (Z = {})), function (e) { e.mergeShapes = (e, t) => ({ ...e, ...t }) }(D || (D = {})); let ek = Z.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), ej = e => { switch (typeof e) { case "undefined": return ek.undefined; case "string": return ek.string; case "number": return isNaN(e) ? ek.nan : ek.number; case "boolean": return ek.boolean; case "function": return ek.function; case "bigint": return ek.bigint; case "symbol": return ek.symbol; case "object": if (Array.isArray(e)) return ek.array; if (null === e) return ek.null; if (e.then && "function" == typeof e.then && e.catch && "function" == typeof e.catch) return ek.promise; if ("undefined" != typeof Map && e instanceof Map) return ek.map; if ("undefined" != typeof Set && e instanceof Set) return ek.set; if ("undefined" != typeof Date && e instanceof Date) return ek.date; return ek.object; default: return ek.unknown } }, eE = Z.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]), eO = e => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"); class eT extends Error { get errors () { return this.issues } constructor(e) { super(), this.issues = [], this.addIssue = e => { this.issues = [...this.issues, e] }, this.addIssues = (e = []) => { this.issues = [...this.issues, ...e] }; let t = new.target.prototype; Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e } format (e) { let t = e || function (e) { return e.message }, n = { _errors: [] }, r = e => { for (let a of e.issues) if ("invalid_union" === a.code) a.unionErrors.map(r); else if ("invalid_return_type" === a.code) r(a.returnTypeError); else if ("invalid_arguments" === a.code) r(a.argumentsError); else if (0 === a.path.length) n._errors.push(t(a)); else { let e = n, r = 0; for (; r < a.path.length;) { let n = a.path[r]; r === a.path.length - 1 ? (e[n] = e[n] || { _errors: [] }, e[n]._errors.push(t(a))) : e[n] = e[n] || { _errors: [] }, e = e[n], r++ } } }; return r(this), n } static assert (e) { if (!(e instanceof eT)) throw Error(`Not a ZodError: ${e}`) } toString () { return this.message } get message () { return JSON.stringify(this.issues, Z.jsonStringifyReplacer, 2) } get isEmpty () { return 0 === this.issues.length } flatten (e = e => e.message) { let t = {}, n = []; for (let r of this.issues) r.path.length > 0 ? (t[r.path[0]] = t[r.path[0]] || [], t[r.path[0]].push(e(r))) : n.push(e(r)); return { formErrors: n, fieldErrors: t } } get formErrors () { return this.flatten() } } eT.create = e => new eT(e); let eC = (e, t) => { let n; switch (e.code) { case eE.invalid_type: n = e.received === ek.undefined ? "Required" : `Expected ${e.expected}, received ${e.received}`; break; case eE.invalid_literal: n = `Invalid literal value, expected ${JSON.stringify(e.expected, Z.jsonStringifyReplacer)}`; break; case eE.unrecognized_keys: n = `Unrecognized key(s) in object: ${Z.joinValues(e.keys, ", ")}`; break; case eE.invalid_union: n = "Invalid input"; break; case eE.invalid_union_discriminator: n = `Invalid discriminator value. Expected ${Z.joinValues(e.options)}`; break; case eE.invalid_enum_value: n = `Invalid enum value. Expected ${Z.joinValues(e.options)}, received '${e.received}'`; break; case eE.invalid_arguments: n = "Invalid function arguments"; break; case eE.invalid_return_type: n = "Invalid function return type"; break; case eE.invalid_date: n = "Invalid date"; break; case eE.invalid_string: "object" == typeof e.validation ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, "number" == typeof e.validation.position && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : Z.assertNever(e.validation) : n = "regex" !== e.validation ? `Invalid ${e.validation}` : "Invalid"; break; case eE.too_small: n = "array" === e.type ? `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : "string" === e.type ? `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : "number" === e.type ? `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : "date" === e.type ? `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : "Invalid input"; break; case eE.too_big: n = "array" === e.type ? `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : "string" === e.type ? `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : "number" === e.type ? `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : "bigint" === e.type ? `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : "date" === e.type ? `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : "Invalid input"; break; case eE.custom: n = "Invalid input"; break; case eE.invalid_intersection_types: n = "Intersection results could not be merged"; break; case eE.not_multiple_of: n = `Number must be a multiple of ${e.multipleOf}`; break; case eE.not_finite: n = "Number must be finite"; break; default: n = t.defaultError, Z.assertNever(e) }return { message: n } }, eS = eC; function eN (e) { eS = e } function eI () { return eS } let eA = e => { let { data: t, path: n, errorMaps: r, issueData: a } = e, i = [...n, ...a.path || []], s = { ...a, path: i }; if (void 0 !== a.message) return { ...a, path: i, message: a.message }; let o = ""; for (let e of r.filter(e => !!e).slice().reverse()) o = e(s, { data: t, defaultError: o }).message; return { ...a, path: i, message: o } }, eR = []; function eP (e, t) { let n = eI(), r = eA({ issueData: t, data: e.data, path: e.path, errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, n, n === eC ? void 0 : eC].filter(e => !!e) }); e.common.issues.push(r) } class eM { constructor() { this.value = "valid" } dirty () { "valid" === this.value && (this.value = "dirty") } abort () { "aborted" !== this.value && (this.value = "aborted") } static mergeArray (e, t) { let n = []; for (let r of t) { if ("aborted" === r.status) return eL; "dirty" === r.status && e.dirty(), n.push(r.value) } return { status: e.value, value: n } } static async mergeObjectAsync (e, t) { let n = []; for (let e of t) { let t = await e.key, r = await e.value; n.push({ key: t, value: r }) } return eM.mergeObjectSync(e, n) } static mergeObjectSync (e, t) { let n = {}; for (let r of t) { let { key: t, value: a } = r; if ("aborted" === t.status || "aborted" === a.status) return eL; "dirty" === t.status && e.dirty(), "dirty" === a.status && e.dirty(), "__proto__" !== t.value && (void 0 !== a.value || r.alwaysSet) && (n[t.value] = a.value) } return { status: e.value, value: n } } } let eL = Object.freeze({ status: "aborted" }), eZ = e => ({ status: "dirty", value: e }), eD = e => ({ status: "valid", value: e }), eF = e => "aborted" === e.status, ez = e => "dirty" === e.status, e$ = e => "valid" === e.status, eU = e => "undefined" != typeof Promise && e instanceof Promise; function eW (e, t, n, r) { if ("a" === n && !r) throw TypeError("Private accessor was defined without a getter"); if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e) } function eH (e, t, n, r, a) { if ("m" === r) throw TypeError("Private method is not writable"); if ("a" === r && !a) throw TypeError("Private accessor was defined without a setter"); if ("function" == typeof t ? e !== t || !a : !t.has(e)) throw TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === r ? a.call(e, n) : a ? a.value = n : t.set(e, n), n } "function" == typeof SuppressedError && SuppressedError, function (e) { e.errToObj = e => "string" == typeof e ? { message: e } : e || {}, e.toString = e => "string" == typeof e ? e : null == e ? void 0 : e.message }(F || (F = {})); class eV { constructor(e, t, n, r) { this._cachedPath = [], this.parent = e, this.data = t, this._path = n, this._key = r } get path () { return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath } } let eB = (e, t) => { if (e$(t)) return { success: !0, data: t.value }; if (!e.common.issues.length) throw Error("Validation failed but no issues detected."); return { success: !1, get error () { if (this._error) return this._error; let t = new eT(e.common.issues); return this._error = t, this._error } } }; function eG (e) { if (!e) return {}; let { errorMap: t, invalid_type_error: n, required_error: r, description: a } = e; if (t && (n || r)) throw Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.'); return t ? { errorMap: t, description: a } : { errorMap: (t, a) => { var i, s; let { message: o } = e; return "invalid_enum_value" === t.code ? { message: null != o ? o : a.defaultError } : void 0 === a.data ? { message: null !== (i = null != o ? o : r) && void 0 !== i ? i : a.defaultError } : "invalid_type" !== t.code ? { message: a.defaultError } : { message: null !== (s = null != o ? o : n) && void 0 !== s ? s : a.defaultError } }, description: a } } class eq { get description () { return this._def.description } _getType (e) { return ej(e.data) } _getOrReturnCtx (e, t) { return t || { common: e.parent.common, data: e.data, parsedType: ej(e.data), schemaErrorMap: this._def.errorMap, path: e.path, parent: e.parent } } _processInputParams (e) { return { status: new eM, ctx: { common: e.parent.common, data: e.data, parsedType: ej(e.data), schemaErrorMap: this._def.errorMap, path: e.path, parent: e.parent } } } _parseSync (e) { let t = this._parse(e); if (eU(t)) throw Error("Synchronous parse encountered promise."); return t } _parseAsync (e) { return Promise.resolve(this._parse(e)) } parse (e, t) { let n = this.safeParse(e, t); if (n.success) return n.data; throw n.error } safeParse (e, t) { var n; let r = { common: { issues: [], async: null !== (n = null == t ? void 0 : t.async) && void 0 !== n && n, contextualErrorMap: null == t ? void 0 : t.errorMap }, path: (null == t ? void 0 : t.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e, parsedType: ej(e) }, a = this._parseSync({ data: e, path: r.path, parent: r }); return eB(r, a) } "~validate" (e) { var t, n; let r = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: e, parsedType: ej(e) }; if (!this["~standard"].async) try { let t = this._parseSync({ data: e, path: [], parent: r }); return e$(t) ? { value: t.value } : { issues: r.common.issues } } catch (e) { (null === (n = null === (t = null == e ? void 0 : e.message) || void 0 === t ? void 0 : t.toLowerCase()) || void 0 === n ? void 0 : n.includes("encountered")) && (this["~standard"].async = !0), r.common = { issues: [], async: !0 } } return this._parseAsync({ data: e, path: [], parent: r }).then(e => e$(e) ? { value: e.value } : { issues: r.common.issues }) } async parseAsync (e, t) { let n = await this.safeParseAsync(e, t); if (n.success) return n.data; throw n.error } async safeParseAsync (e, t) { let n = { common: { issues: [], contextualErrorMap: null == t ? void 0 : t.errorMap, async: !0 }, path: (null == t ? void 0 : t.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e, parsedType: ej(e) }, r = this._parse({ data: e, path: n.path, parent: n }); return eB(n, await (eU(r) ? r : Promise.resolve(r))) } refine (e, t) { let n = e => "string" == typeof t || void 0 === t ? { message: t } : "function" == typeof t ? t(e) : t; return this._refinement((t, r) => { let a = e(t), i = () => r.addIssue({ code: eE.custom, ...n(t) }); return "undefined" != typeof Promise && a instanceof Promise ? a.then(e => !!e || (i(), !1)) : !!a || (i(), !1) }) } refinement (e, t) { return this._refinement((n, r) => !!e(n) || (r.addIssue("function" == typeof t ? t(n, r) : t), !1)) } _refinement (e) { return new tz({ schema: this, typeName: U.ZodEffects, effect: { type: "refinement", refinement: e } }) } superRefine (e) { return this._refinement(e) } constructor(e) { this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: e => this["~validate"](e) } } optional () { return t$.create(this, this._def) } nullable () { return tU.create(this, this._def) } nullish () { return this.nullable().optional() } array () { return t_.create(this) } promise () { return tF.create(this, this._def) } or (e) { return tj.create([this, e], this._def) } and (e) { return tC.create(this, e, this._def) } transform (e) { return new tz({ ...eG(this._def), schema: this, typeName: U.ZodEffects, effect: { type: "transform", transform: e } }) } default (e) { let t = "function" == typeof e ? e : () => e; return new tW({ ...eG(this._def), innerType: this, defaultValue: t, typeName: U.ZodDefault }) } brand () { return new tG({ typeName: U.ZodBranded, type: this, ...eG(this._def) }) } catch (e) { let t = "function" == typeof e ? e : () => e; return new tH({ ...eG(this._def), innerType: this, catchValue: t, typeName: U.ZodCatch }) } describe (e) { return new this.constructor({ ...this._def, description: e }) } pipe (e) { return tq.create(this, e) } readonly () { return tK.create(this) } isOptional () { return this.safeParse(void 0).success } isNullable () { return this.safeParse(null).success } } let eK = /^c[^\s-]{8,}$/i, eQ = /^[0-9a-z]+$/, eY = /^[0-9A-HJKMNP-TV-Z]{26}$/i, eJ = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, eX = /^[a-z0-9_-]{21}$/i, e0 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, e1 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, e2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, e4 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", e3 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, e5 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, e7 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, e9 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, e6 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, e8 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, te = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", tt = RegExp(`^${te}$`); function tn (e) { let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d"; return e.precision ? t = `${t}\\.\\d{${e.precision}}` : null == e.precision && (t = `${t}(\\.\\d+)?`), t } function tr (e) { return RegExp(`^${tn(e)}$`) } function ta (e) { let t = `${te}T${tn(e)}`, n = []; return n.push(e.local ? "Z?" : "Z"), e.offset && n.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${n.join("|")})`, RegExp(`^${t}$`) } function ti (e, t) { return !!(("v4" === t || !t) && e3.test(e) || ("v6" === t || !t) && e7.test(e)) } function ts (e, t) { if (!e0.test(e)) return !1; try { let [n] = e.split("."), r = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), a = JSON.parse(atob(r)); if ("object" != typeof a || null === a || !a.typ || !a.alg || t && a.alg !== t) return !1; return !0 } catch (e) { return !1 } } function to (e, t) { return !!(("v4" === t || !t) && e5.test(e) || ("v6" === t || !t) && e9.test(e)) } class tl extends eq { _parse (e) { let t; if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== ek.string) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.string, received: t.parsedType }), eL } let n = new eM; for (let a of this._def.checks) if ("min" === a.kind) e.data.length < a.value && (eP(t = this._getOrReturnCtx(e, t), { code: eE.too_small, minimum: a.value, type: "string", inclusive: !0, exact: !1, message: a.message }), n.dirty()); else if ("max" === a.kind) e.data.length > a.value && (eP(t = this._getOrReturnCtx(e, t), { code: eE.too_big, maximum: a.value, type: "string", inclusive: !0, exact: !1, message: a.message }), n.dirty()); else if ("length" === a.kind) { let r = e.data.length > a.value, i = e.data.length < a.value; (r || i) && (t = this._getOrReturnCtx(e, t), r ? eP(t, { code: eE.too_big, maximum: a.value, type: "string", inclusive: !0, exact: !0, message: a.message }) : i && eP(t, { code: eE.too_small, minimum: a.value, type: "string", inclusive: !0, exact: !0, message: a.message }), n.dirty()) } else if ("email" === a.kind) e2.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { validation: "email", code: eE.invalid_string, message: a.message }), n.dirty()); else if ("emoji" === a.kind) r || (r = RegExp(e4, "u")), r.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { validation: "emoji", code: eE.invalid_string, message: a.message }), n.dirty()); else if ("uuid" === a.kind) eJ.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { validation: "uuid", code: eE.invalid_string, message: a.message }), n.dirty()); else if ("nanoid" === a.kind) eX.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { validation: "nanoid", code: eE.invalid_string, message: a.message }), n.dirty()); else if ("cuid" === a.kind) eK.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { validation: "cuid", code: eE.invalid_string, message: a.message }), n.dirty()); else if ("cuid2" === a.kind) eQ.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { validation: "cuid2", code: eE.invalid_string, message: a.message }), n.dirty()); else if ("ulid" === a.kind) eY.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { validation: "ulid", code: eE.invalid_string, message: a.message }), n.dirty()); else if ("url" === a.kind) try { new URL(e.data) } catch (r) { eP(t = this._getOrReturnCtx(e, t), { validation: "url", code: eE.invalid_string, message: a.message }), n.dirty() } else "regex" === a.kind ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { validation: "regex", code: eE.invalid_string, message: a.message }), n.dirty())) : "trim" === a.kind ? e.data = e.data.trim() : "includes" === a.kind ? e.data.includes(a.value, a.position) || (eP(t = this._getOrReturnCtx(e, t), { code: eE.invalid_string, validation: { includes: a.value, position: a.position }, message: a.message }), n.dirty()) : "toLowerCase" === a.kind ? e.data = e.data.toLowerCase() : "toUpperCase" === a.kind ? e.data = e.data.toUpperCase() : "startsWith" === a.kind ? e.data.startsWith(a.value) || (eP(t = this._getOrReturnCtx(e, t), { code: eE.invalid_string, validation: { startsWith: a.value }, message: a.message }), n.dirty()) : "endsWith" === a.kind ? e.data.endsWith(a.value) || (eP(t = this._getOrReturnCtx(e, t), { code: eE.invalid_string, validation: { endsWith: a.value }, message: a.message }), n.dirty()) : "datetime" === a.kind ? ta(a).test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { code: eE.invalid_string, validation: "datetime", message: a.message }), n.dirty()) : "date" === a.kind ? tt.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { code: eE.invalid_string, validation: "date", message: a.message }), n.dirty()) : "time" === a.kind ? tr(a).test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { code: eE.invalid_string, validation: "time", message: a.message }), n.dirty()) : "duration" === a.kind ? e1.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { validation: "duration", code: eE.invalid_string, message: a.message }), n.dirty()) : "ip" === a.kind ? ti(e.data, a.version) || (eP(t = this._getOrReturnCtx(e, t), { validation: "ip", code: eE.invalid_string, message: a.message }), n.dirty()) : "jwt" === a.kind ? ts(e.data, a.alg) || (eP(t = this._getOrReturnCtx(e, t), { validation: "jwt", code: eE.invalid_string, message: a.message }), n.dirty()) : "cidr" === a.kind ? to(e.data, a.version) || (eP(t = this._getOrReturnCtx(e, t), { validation: "cidr", code: eE.invalid_string, message: a.message }), n.dirty()) : "base64" === a.kind ? e6.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { validation: "base64", code: eE.invalid_string, message: a.message }), n.dirty()) : "base64url" === a.kind ? e8.test(e.data) || (eP(t = this._getOrReturnCtx(e, t), { validation: "base64url", code: eE.invalid_string, message: a.message }), n.dirty()) : Z.assertNever(a); return { status: n.value, value: e.data } } _regex (e, t, n) { return this.refinement(t => e.test(t), { validation: t, code: eE.invalid_string, ...F.errToObj(n) }) } _addCheck (e) { return new tl({ ...this._def, checks: [...this._def.checks, e] }) } email (e) { return this._addCheck({ kind: "email", ...F.errToObj(e) }) } url (e) { return this._addCheck({ kind: "url", ...F.errToObj(e) }) } emoji (e) { return this._addCheck({ kind: "emoji", ...F.errToObj(e) }) } uuid (e) { return this._addCheck({ kind: "uuid", ...F.errToObj(e) }) } nanoid (e) { return this._addCheck({ kind: "nanoid", ...F.errToObj(e) }) } cuid (e) { return this._addCheck({ kind: "cuid", ...F.errToObj(e) }) } cuid2 (e) { return this._addCheck({ kind: "cuid2", ...F.errToObj(e) }) } ulid (e) { return this._addCheck({ kind: "ulid", ...F.errToObj(e) }) } base64 (e) { return this._addCheck({ kind: "base64", ...F.errToObj(e) }) } base64url (e) { return this._addCheck({ kind: "base64url", ...F.errToObj(e) }) } jwt (e) { return this._addCheck({ kind: "jwt", ...F.errToObj(e) }) } ip (e) { return this._addCheck({ kind: "ip", ...F.errToObj(e) }) } cidr (e) { return this._addCheck({ kind: "cidr", ...F.errToObj(e) }) } datetime (e) { var t, n; return "string" == typeof e ? this._addCheck({ kind: "datetime", precision: null, offset: !1, local: !1, message: e }) : this._addCheck({ kind: "datetime", precision: void 0 === (null == e ? void 0 : e.precision) ? null : null == e ? void 0 : e.precision, offset: null !== (t = null == e ? void 0 : e.offset) && void 0 !== t && t, local: null !== (n = null == e ? void 0 : e.local) && void 0 !== n && n, ...F.errToObj(null == e ? void 0 : e.message) }) } date (e) { return this._addCheck({ kind: "date", message: e }) } time (e) { return "string" == typeof e ? this._addCheck({ kind: "time", precision: null, message: e }) : this._addCheck({ kind: "time", precision: void 0 === (null == e ? void 0 : e.precision) ? null : null == e ? void 0 : e.precision, ...F.errToObj(null == e ? void 0 : e.message) }) } duration (e) { return this._addCheck({ kind: "duration", ...F.errToObj(e) }) } regex (e, t) { return this._addCheck({ kind: "regex", regex: e, ...F.errToObj(t) }) } includes (e, t) { return this._addCheck({ kind: "includes", value: e, position: null == t ? void 0 : t.position, ...F.errToObj(null == t ? void 0 : t.message) }) } startsWith (e, t) { return this._addCheck({ kind: "startsWith", value: e, ...F.errToObj(t) }) } endsWith (e, t) { return this._addCheck({ kind: "endsWith", value: e, ...F.errToObj(t) }) } min (e, t) { return this._addCheck({ kind: "min", value: e, ...F.errToObj(t) }) } max (e, t) { return this._addCheck({ kind: "max", value: e, ...F.errToObj(t) }) } length (e, t) { return this._addCheck({ kind: "length", value: e, ...F.errToObj(t) }) } nonempty (e) { return this.min(1, F.errToObj(e)) } trim () { return new tl({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] }) } toLowerCase () { return new tl({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] }) } toUpperCase () { return new tl({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] }) } get isDatetime () { return !!this._def.checks.find(e => "datetime" === e.kind) } get isDate () { return !!this._def.checks.find(e => "date" === e.kind) } get isTime () { return !!this._def.checks.find(e => "time" === e.kind) } get isDuration () { return !!this._def.checks.find(e => "duration" === e.kind) } get isEmail () { return !!this._def.checks.find(e => "email" === e.kind) } get isURL () { return !!this._def.checks.find(e => "url" === e.kind) } get isEmoji () { return !!this._def.checks.find(e => "emoji" === e.kind) } get isUUID () { return !!this._def.checks.find(e => "uuid" === e.kind) } get isNANOID () { return !!this._def.checks.find(e => "nanoid" === e.kind) } get isCUID () { return !!this._def.checks.find(e => "cuid" === e.kind) } get isCUID2 () { return !!this._def.checks.find(e => "cuid2" === e.kind) } get isULID () { return !!this._def.checks.find(e => "ulid" === e.kind) } get isIP () { return !!this._def.checks.find(e => "ip" === e.kind) } get isCIDR () { return !!this._def.checks.find(e => "cidr" === e.kind) } get isBase64 () { return !!this._def.checks.find(e => "base64" === e.kind) } get isBase64url () { return !!this._def.checks.find(e => "base64url" === e.kind) } get minLength () { let e = null; for (let t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value); return e } get maxLength () { let e = null; for (let t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value); return e } } function tu (e, t) { let n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, a = n > r ? n : r; return parseInt(e.toFixed(a).replace(".", "")) % parseInt(t.toFixed(a).replace(".", "")) / Math.pow(10, a) } tl.create = e => { var t; return new tl({ checks: [], typeName: U.ZodString, coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t, ...eG(e) }) }; class tc extends eq { constructor() { super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf } _parse (e) { let t; if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== ek.number) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.number, received: t.parsedType }), eL } let n = new eM; for (let r of this._def.checks) "int" === r.kind ? Z.isInteger(e.data) || (eP(t = this._getOrReturnCtx(e, t), { code: eE.invalid_type, expected: "integer", received: "float", message: r.message }), n.dirty()) : "min" === r.kind ? (r.inclusive ? e.data < r.value : e.data <= r.value) && (eP(t = this._getOrReturnCtx(e, t), { code: eE.too_small, minimum: r.value, type: "number", inclusive: r.inclusive, exact: !1, message: r.message }), n.dirty()) : "max" === r.kind ? (r.inclusive ? e.data > r.value : e.data >= r.value) && (eP(t = this._getOrReturnCtx(e, t), { code: eE.too_big, maximum: r.value, type: "number", inclusive: r.inclusive, exact: !1, message: r.message }), n.dirty()) : "multipleOf" === r.kind ? 0 !== tu(e.data, r.value) && (eP(t = this._getOrReturnCtx(e, t), { code: eE.not_multiple_of, multipleOf: r.value, message: r.message }), n.dirty()) : "finite" === r.kind ? Number.isFinite(e.data) || (eP(t = this._getOrReturnCtx(e, t), { code: eE.not_finite, message: r.message }), n.dirty()) : Z.assertNever(r); return { status: n.value, value: e.data } } gte (e, t) { return this.setLimit("min", e, !0, F.toString(t)) } gt (e, t) { return this.setLimit("min", e, !1, F.toString(t)) } lte (e, t) { return this.setLimit("max", e, !0, F.toString(t)) } lt (e, t) { return this.setLimit("max", e, !1, F.toString(t)) } setLimit (e, t, n, r) { return new tc({ ...this._def, checks: [...this._def.checks, { kind: e, value: t, inclusive: n, message: F.toString(r) }] }) } _addCheck (e) { return new tc({ ...this._def, checks: [...this._def.checks, e] }) } int (e) { return this._addCheck({ kind: "int", message: F.toString(e) }) } positive (e) { return this._addCheck({ kind: "min", value: 0, inclusive: !1, message: F.toString(e) }) } negative (e) { return this._addCheck({ kind: "max", value: 0, inclusive: !1, message: F.toString(e) }) } nonpositive (e) { return this._addCheck({ kind: "max", value: 0, inclusive: !0, message: F.toString(e) }) } nonnegative (e) { return this._addCheck({ kind: "min", value: 0, inclusive: !0, message: F.toString(e) }) } multipleOf (e, t) { return this._addCheck({ kind: "multipleOf", value: e, message: F.toString(t) }) } finite (e) { return this._addCheck({ kind: "finite", message: F.toString(e) }) } safe (e) { return this._addCheck({ kind: "min", inclusive: !0, value: Number.MIN_SAFE_INTEGER, message: F.toString(e) })._addCheck({ kind: "max", inclusive: !0, value: Number.MAX_SAFE_INTEGER, message: F.toString(e) }) } get minValue () { let e = null; for (let t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value); return e } get maxValue () { let e = null; for (let t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value); return e } get isInt () { return !!this._def.checks.find(e => "int" === e.kind || "multipleOf" === e.kind && Z.isInteger(e.value)) } get isFinite () { let e = null, t = null; for (let n of this._def.checks) { if ("finite" === n.kind || "int" === n.kind || "multipleOf" === n.kind) return !0; "min" === n.kind ? (null === t || n.value > t) && (t = n.value) : "max" === n.kind && (null === e || n.value < e) && (e = n.value) } return Number.isFinite(t) && Number.isFinite(e) } } tc.create = e => new tc({ checks: [], typeName: U.ZodNumber, coerce: (null == e ? void 0 : e.coerce) || !1, ...eG(e) }); class td extends eq { constructor() { super(...arguments), this.min = this.gte, this.max = this.lte } _parse (e) { let t; if (this._def.coerce) try { e.data = BigInt(e.data) } catch (t) { return this._getInvalidInput(e) } if (this._getType(e) !== ek.bigint) return this._getInvalidInput(e); let n = new eM; for (let r of this._def.checks) "min" === r.kind ? (r.inclusive ? e.data < r.value : e.data <= r.value) && (eP(t = this._getOrReturnCtx(e, t), { code: eE.too_small, type: "bigint", minimum: r.value, inclusive: r.inclusive, message: r.message }), n.dirty()) : "max" === r.kind ? (r.inclusive ? e.data > r.value : e.data >= r.value) && (eP(t = this._getOrReturnCtx(e, t), { code: eE.too_big, type: "bigint", maximum: r.value, inclusive: r.inclusive, message: r.message }), n.dirty()) : "multipleOf" === r.kind ? e.data % r.value !== BigInt(0) && (eP(t = this._getOrReturnCtx(e, t), { code: eE.not_multiple_of, multipleOf: r.value, message: r.message }), n.dirty()) : Z.assertNever(r); return { status: n.value, value: e.data } } _getInvalidInput (e) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.bigint, received: t.parsedType }), eL } gte (e, t) { return this.setLimit("min", e, !0, F.toString(t)) } gt (e, t) { return this.setLimit("min", e, !1, F.toString(t)) } lte (e, t) { return this.setLimit("max", e, !0, F.toString(t)) } lt (e, t) { return this.setLimit("max", e, !1, F.toString(t)) } setLimit (e, t, n, r) { return new td({ ...this._def, checks: [...this._def.checks, { kind: e, value: t, inclusive: n, message: F.toString(r) }] }) } _addCheck (e) { return new td({ ...this._def, checks: [...this._def.checks, e] }) } positive (e) { return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !1, message: F.toString(e) }) } negative (e) { return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !1, message: F.toString(e) }) } nonpositive (e) { return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !0, message: F.toString(e) }) } nonnegative (e) { return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !0, message: F.toString(e) }) } multipleOf (e, t) { return this._addCheck({ kind: "multipleOf", value: e, message: F.toString(t) }) } get minValue () { let e = null; for (let t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value); return e } get maxValue () { let e = null; for (let t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value); return e } } td.create = e => { var t; return new td({ checks: [], typeName: U.ZodBigInt, coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t, ...eG(e) }) }; class th extends eq { _parse (e) { if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== ek.boolean) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.boolean, received: t.parsedType }), eL } return eD(e.data) } } th.create = e => new th({ typeName: U.ZodBoolean, coerce: (null == e ? void 0 : e.coerce) || !1, ...eG(e) }); class tp extends eq { _parse (e) { let t; if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== ek.date) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.date, received: t.parsedType }), eL } if (isNaN(e.data.getTime())) return eP(this._getOrReturnCtx(e), { code: eE.invalid_date }), eL; let n = new eM; for (let r of this._def.checks) "min" === r.kind ? e.data.getTime() < r.value && (eP(t = this._getOrReturnCtx(e, t), { code: eE.too_small, message: r.message, inclusive: !0, exact: !1, minimum: r.value, type: "date" }), n.dirty()) : "max" === r.kind ? e.data.getTime() > r.value && (eP(t = this._getOrReturnCtx(e, t), { code: eE.too_big, message: r.message, inclusive: !0, exact: !1, maximum: r.value, type: "date" }), n.dirty()) : Z.assertNever(r); return { status: n.value, value: new Date(e.data.getTime()) } } _addCheck (e) { return new tp({ ...this._def, checks: [...this._def.checks, e] }) } min (e, t) { return this._addCheck({ kind: "min", value: e.getTime(), message: F.toString(t) }) } max (e, t) { return this._addCheck({ kind: "max", value: e.getTime(), message: F.toString(t) }) } get minDate () { let e = null; for (let t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value); return null != e ? new Date(e) : null } get maxDate () { let e = null; for (let t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value); return null != e ? new Date(e) : null } } tp.create = e => new tp({ checks: [], coerce: (null == e ? void 0 : e.coerce) || !1, typeName: U.ZodDate, ...eG(e) }); class tf extends eq { _parse (e) { if (this._getType(e) !== ek.symbol) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.symbol, received: t.parsedType }), eL } return eD(e.data) } } tf.create = e => new tf({ typeName: U.ZodSymbol, ...eG(e) }); class tm extends eq { _parse (e) { if (this._getType(e) !== ek.undefined) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.undefined, received: t.parsedType }), eL } return eD(e.data) } } tm.create = e => new tm({ typeName: U.ZodUndefined, ...eG(e) }); class tx extends eq { _parse (e) { if (this._getType(e) !== ek.null) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.null, received: t.parsedType }), eL } return eD(e.data) } } tx.create = e => new tx({ typeName: U.ZodNull, ...eG(e) }); class tg extends eq { constructor() { super(...arguments), this._any = !0 } _parse (e) { return eD(e.data) } } tg.create = e => new tg({ typeName: U.ZodAny, ...eG(e) }); class tv extends eq { constructor() { super(...arguments), this._unknown = !0 } _parse (e) { return eD(e.data) } } tv.create = e => new tv({ typeName: U.ZodUnknown, ...eG(e) }); class ty extends eq { _parse (e) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.never, received: t.parsedType }), eL } } ty.create = e => new ty({ typeName: U.ZodNever, ...eG(e) }); class tb extends eq { _parse (e) { if (this._getType(e) !== ek.undefined) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.void, received: t.parsedType }), eL } return eD(e.data) } } tb.create = e => new tb({ typeName: U.ZodVoid, ...eG(e) }); class t_ extends eq { _parse (e) { let { ctx: t, status: n } = this._processInputParams(e), r = this._def; if (t.parsedType !== ek.array) return eP(t, { code: eE.invalid_type, expected: ek.array, received: t.parsedType }), eL; if (null !== r.exactLength) { let e = t.data.length > r.exactLength.value, a = t.data.length < r.exactLength.value; (e || a) && (eP(t, { code: e ? eE.too_big : eE.too_small, minimum: a ? r.exactLength.value : void 0, maximum: e ? r.exactLength.value : void 0, type: "array", inclusive: !0, exact: !0, message: r.exactLength.message }), n.dirty()) } if (null !== r.minLength && t.data.length < r.minLength.value && (eP(t, { code: eE.too_small, minimum: r.minLength.value, type: "array", inclusive: !0, exact: !1, message: r.minLength.message }), n.dirty()), null !== r.maxLength && t.data.length > r.maxLength.value && (eP(t, { code: eE.too_big, maximum: r.maxLength.value, type: "array", inclusive: !0, exact: !1, message: r.maxLength.message }), n.dirty()), t.common.async) return Promise.all([...t.data].map((e, n) => r.type._parseAsync(new eV(t, e, t.path, n)))).then(e => eM.mergeArray(n, e)); let a = [...t.data].map((e, n) => r.type._parseSync(new eV(t, e, t.path, n))); return eM.mergeArray(n, a) } get element () { return this._def.type } min (e, t) { return new t_({ ...this._def, minLength: { value: e, message: F.toString(t) } }) } max (e, t) { return new t_({ ...this._def, maxLength: { value: e, message: F.toString(t) } }) } length (e, t) { return new t_({ ...this._def, exactLength: { value: e, message: F.toString(t) } }) } nonempty (e) { return this.min(1, e) } } function tw (e) { if (e instanceof tk) { let t = {}; for (let n in e.shape) { let r = e.shape[n]; t[n] = t$.create(tw(r)) } return new tk({ ...e._def, shape: () => t }) } return e instanceof t_ ? new t_({ ...e._def, type: tw(e.element) }) : e instanceof t$ ? t$.create(tw(e.unwrap())) : e instanceof tU ? tU.create(tw(e.unwrap())) : e instanceof tS ? tS.create(e.items.map(e => tw(e))) : e } t_.create = (e, t) => new t_({ type: e, minLength: null, maxLength: null, exactLength: null, typeName: U.ZodArray, ...eG(t) }); class tk extends eq { constructor() { super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend } _getCached () { if (null !== this._cached) return this._cached; let e = this._def.shape(), t = Z.objectKeys(e); return this._cached = { shape: e, keys: t } } _parse (e) { if (this._getType(e) !== ek.object) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.object, received: t.parsedType }), eL } let { status: t, ctx: n } = this._processInputParams(e), { shape: r, keys: a } = this._getCached(), i = []; if (!(this._def.catchall instanceof ty && "strip" === this._def.unknownKeys)) for (let e in n.data) a.includes(e) || i.push(e); let s = []; for (let e of a) { let t = r[e], a = n.data[e]; s.push({ key: { status: "valid", value: e }, value: t._parse(new eV(n, a, n.path, e)), alwaysSet: e in n.data }) } if (this._def.catchall instanceof ty) { let e = this._def.unknownKeys; if ("passthrough" === e) for (let e of i) s.push({ key: { status: "valid", value: e }, value: { status: "valid", value: n.data[e] } }); else if ("strict" === e) i.length > 0 && (eP(n, { code: eE.unrecognized_keys, keys: i }), t.dirty()); else if ("strip" === e); else throw Error("Internal ZodObject error: invalid unknownKeys value.") } else { let e = this._def.catchall; for (let t of i) { let r = n.data[t]; s.push({ key: { status: "valid", value: t }, value: e._parse(new eV(n, r, n.path, t)), alwaysSet: t in n.data }) } } return n.common.async ? Promise.resolve().then(async () => { let e = []; for (let t of s) { let n = await t.key, r = await t.value; e.push({ key: n, value: r, alwaysSet: t.alwaysSet }) } return e }).then(e => eM.mergeObjectSync(t, e)) : eM.mergeObjectSync(t, s) } get shape () { return this._def.shape() } strict (e) { return F.errToObj, new tk({ ...this._def, unknownKeys: "strict", ...void 0 !== e ? { errorMap: (t, n) => { var r, a, i, s; let o = null !== (i = null === (a = (r = this._def).errorMap) || void 0 === a ? void 0 : a.call(r, t, n).message) && void 0 !== i ? i : n.defaultError; return "unrecognized_keys" === t.code ? { message: null !== (s = F.errToObj(e).message) && void 0 !== s ? s : o } : { message: o } } } : {} }) } strip () { return new tk({ ...this._def, unknownKeys: "strip" }) } passthrough () { return new tk({ ...this._def, unknownKeys: "passthrough" }) } extend (e) { return new tk({ ...this._def, shape: () => ({ ...this._def.shape(), ...e }) }) } merge (e) { return new tk({ unknownKeys: e._def.unknownKeys, catchall: e._def.catchall, shape: () => ({ ...this._def.shape(), ...e._def.shape() }), typeName: U.ZodObject }) } setKey (e, t) { return this.augment({ [e]: t }) } catchall (e) { return new tk({ ...this._def, catchall: e }) } pick (e) { let t = {}; return Z.objectKeys(e).forEach(n => { e[n] && this.shape[n] && (t[n] = this.shape[n]) }), new tk({ ...this._def, shape: () => t }) } omit (e) { let t = {}; return Z.objectKeys(this.shape).forEach(n => { e[n] || (t[n] = this.shape[n]) }), new tk({ ...this._def, shape: () => t }) } deepPartial () { return tw(this) } partial (e) { let t = {}; return Z.objectKeys(this.shape).forEach(n => { let r = this.shape[n]; e && !e[n] ? t[n] = r : t[n] = r.optional() }), new tk({ ...this._def, shape: () => t }) } required (e) { let t = {}; return Z.objectKeys(this.shape).forEach(n => { if (e && !e[n]) t[n] = this.shape[n]; else { let e = this.shape[n]; for (; e instanceof t$;)e = e._def.innerType; t[n] = e } }), new tk({ ...this._def, shape: () => t }) } keyof () { return tL(Z.objectKeys(this.shape)) } } tk.create = (e, t) => new tk({ shape: () => e, unknownKeys: "strip", catchall: ty.create(), typeName: U.ZodObject, ...eG(t) }), tk.strictCreate = (e, t) => new tk({ shape: () => e, unknownKeys: "strict", catchall: ty.create(), typeName: U.ZodObject, ...eG(t) }), tk.lazycreate = (e, t) => new tk({ shape: e, unknownKeys: "strip", catchall: ty.create(), typeName: U.ZodObject, ...eG(t) }); class tj extends eq { _parse (e) { let { ctx: t } = this._processInputParams(e), n = this._def.options; function r (e) { for (let t of e) if ("valid" === t.result.status) return t.result; for (let n of e) if ("dirty" === n.result.status) return t.common.issues.push(...n.ctx.common.issues), n.result; let n = e.map(e => new eT(e.ctx.common.issues)); return eP(t, { code: eE.invalid_union, unionErrors: n }), eL } if (t.common.async) return Promise.all(n.map(async e => { let n = { ...t, common: { ...t.common, issues: [] }, parent: null }; return { result: await e._parseAsync({ data: t.data, path: t.path, parent: n }), ctx: n } })).then(r); { let e; let r = []; for (let a of n) { let n = { ...t, common: { ...t.common, issues: [] }, parent: null }, i = a._parseSync({ data: t.data, path: t.path, parent: n }); if ("valid" === i.status) return i; "dirty" !== i.status || e || (e = { result: i, ctx: n }), n.common.issues.length && r.push(n.common.issues) } if (e) return t.common.issues.push(...e.ctx.common.issues), e.result; let a = r.map(e => new eT(e)); return eP(t, { code: eE.invalid_union, unionErrors: a }), eL } } get options () { return this._def.options } } tj.create = (e, t) => new tj({ options: e, typeName: U.ZodUnion, ...eG(t) }); let tE = e => { if (e instanceof tP) return tE(e.schema); if (e instanceof tz) return tE(e.innerType()); if (e instanceof tM) return [e.value]; if (e instanceof tZ) return e.options; if (e instanceof tD) return Z.objectValues(e.enum); if (e instanceof tW) return tE(e._def.innerType); if (e instanceof tm) return [void 0]; else if (e instanceof tx) return [null]; else if (e instanceof t$) return [void 0, ...tE(e.unwrap())]; else if (e instanceof tU) return [null, ...tE(e.unwrap())]; else if (e instanceof tG) return tE(e.unwrap()); else if (e instanceof tK) return tE(e.unwrap()); else if (e instanceof tH) return tE(e._def.innerType); else return [] }; class tO extends eq { _parse (e) { let { ctx: t } = this._processInputParams(e); if (t.parsedType !== ek.object) return eP(t, { code: eE.invalid_type, expected: ek.object, received: t.parsedType }), eL; let n = this.discriminator, r = t.data[n], a = this.optionsMap.get(r); return a ? t.common.async ? a._parseAsync({ data: t.data, path: t.path, parent: t }) : a._parseSync({ data: t.data, path: t.path, parent: t }) : (eP(t, { code: eE.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [n] }), eL) } get discriminator () { return this._def.discriminator } get options () { return this._def.options } get optionsMap () { return this._def.optionsMap } static create (e, t, n) { let r = new Map; for (let n of t) { let t = tE(n.shape[e]); if (!t.length) throw Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`); for (let a of t) { if (r.has(a)) throw Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`); r.set(a, n) } } return new tO({ typeName: U.ZodDiscriminatedUnion, discriminator: e, options: t, optionsMap: r, ...eG(n) }) } } function tT (e, t) { let n = ej(e), r = ej(t); if (e === t) return { valid: !0, data: e }; if (n === ek.object && r === ek.object) { let n = Z.objectKeys(t), r = Z.objectKeys(e).filter(e => -1 !== n.indexOf(e)), a = { ...e, ...t }; for (let n of r) { let r = tT(e[n], t[n]); if (!r.valid) return { valid: !1 }; a[n] = r.data } return { valid: !0, data: a } } if (n === ek.array && r === ek.array) { if (e.length !== t.length) return { valid: !1 }; let n = []; for (let r = 0; r < e.length; r++) { let a = tT(e[r], t[r]); if (!a.valid) return { valid: !1 }; n.push(a.data) } return { valid: !0, data: n } } return n === ek.date && r === ek.date && +e == +t ? { valid: !0, data: e } : { valid: !1 } } class tC extends eq { _parse (e) { let { status: t, ctx: n } = this._processInputParams(e), r = (e, r) => { if (eF(e) || eF(r)) return eL; let a = tT(e.value, r.value); return a.valid ? ((ez(e) || ez(r)) && t.dirty(), { status: t.value, value: a.data }) : (eP(n, { code: eE.invalid_intersection_types }), eL) }; return n.common.async ? Promise.all([this._def.left._parseAsync({ data: n.data, path: n.path, parent: n }), this._def.right._parseAsync({ data: n.data, path: n.path, parent: n })]).then(([e, t]) => r(e, t)) : r(this._def.left._parseSync({ data: n.data, path: n.path, parent: n }), this._def.right._parseSync({ data: n.data, path: n.path, parent: n })) } } tC.create = (e, t, n) => new tC({ left: e, right: t, typeName: U.ZodIntersection, ...eG(n) }); class tS extends eq { _parse (e) { let { status: t, ctx: n } = this._processInputParams(e); if (n.parsedType !== ek.array) return eP(n, { code: eE.invalid_type, expected: ek.array, received: n.parsedType }), eL; if (n.data.length < this._def.items.length) return eP(n, { code: eE.too_small, minimum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), eL; !this._def.rest && n.data.length > this._def.items.length && (eP(n, { code: eE.too_big, maximum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), t.dirty()); let r = [...n.data].map((e, t) => { let r = this._def.items[t] || this._def.rest; return r ? r._parse(new eV(n, e, n.path, t)) : null }).filter(e => !!e); return n.common.async ? Promise.all(r).then(e => eM.mergeArray(t, e)) : eM.mergeArray(t, r) } get items () { return this._def.items } rest (e) { return new tS({ ...this._def, rest: e }) } } tS.create = (e, t) => { if (!Array.isArray(e)) throw Error("You must pass an array of schemas to z.tuple([ ... ])"); return new tS({ items: e, typeName: U.ZodTuple, rest: null, ...eG(t) }) }; class tN extends eq { get keySchema () { return this._def.keyType } get valueSchema () { return this._def.valueType } _parse (e) { let { status: t, ctx: n } = this._processInputParams(e); if (n.parsedType !== ek.object) return eP(n, { code: eE.invalid_type, expected: ek.object, received: n.parsedType }), eL; let r = [], a = this._def.keyType, i = this._def.valueType; for (let e in n.data) r.push({ key: a._parse(new eV(n, e, n.path, e)), value: i._parse(new eV(n, n.data[e], n.path, e)), alwaysSet: e in n.data }); return n.common.async ? eM.mergeObjectAsync(t, r) : eM.mergeObjectSync(t, r) } get element () { return this._def.valueType } static create (e, t, n) { return new tN(t instanceof eq ? { keyType: e, valueType: t, typeName: U.ZodRecord, ...eG(n) } : { keyType: tl.create(), valueType: e, typeName: U.ZodRecord, ...eG(t) }) } } class tI extends eq { get keySchema () { return this._def.keyType } get valueSchema () { return this._def.valueType } _parse (e) { let { status: t, ctx: n } = this._processInputParams(e); if (n.parsedType !== ek.map) return eP(n, { code: eE.invalid_type, expected: ek.map, received: n.parsedType }), eL; let r = this._def.keyType, a = this._def.valueType, i = [...n.data.entries()].map(([e, t], i) => ({ key: r._parse(new eV(n, e, n.path, [i, "key"])), value: a._parse(new eV(n, t, n.path, [i, "value"])) })); if (n.common.async) { let e = new Map; return Promise.resolve().then(async () => { for (let n of i) { let r = await n.key, a = await n.value; if ("aborted" === r.status || "aborted" === a.status) return eL; ("dirty" === r.status || "dirty" === a.status) && t.dirty(), e.set(r.value, a.value) } return { status: t.value, value: e } }) } { let e = new Map; for (let n of i) { let r = n.key, a = n.value; if ("aborted" === r.status || "aborted" === a.status) return eL; ("dirty" === r.status || "dirty" === a.status) && t.dirty(), e.set(r.value, a.value) } return { status: t.value, value: e } } } } tI.create = (e, t, n) => new tI({ valueType: t, keyType: e, typeName: U.ZodMap, ...eG(n) }); class tA extends eq { _parse (e) { let { status: t, ctx: n } = this._processInputParams(e); if (n.parsedType !== ek.set) return eP(n, { code: eE.invalid_type, expected: ek.set, received: n.parsedType }), eL; let r = this._def; null !== r.minSize && n.data.size < r.minSize.value && (eP(n, { code: eE.too_small, minimum: r.minSize.value, type: "set", inclusive: !0, exact: !1, message: r.minSize.message }), t.dirty()), null !== r.maxSize && n.data.size > r.maxSize.value && (eP(n, { code: eE.too_big, maximum: r.maxSize.value, type: "set", inclusive: !0, exact: !1, message: r.maxSize.message }), t.dirty()); let a = this._def.valueType; function i (e) { let n = new Set; for (let r of e) { if ("aborted" === r.status) return eL; "dirty" === r.status && t.dirty(), n.add(r.value) } return { status: t.value, value: n } } let s = [...n.data.values()].map((e, t) => a._parse(new eV(n, e, n.path, t))); return n.common.async ? Promise.all(s).then(e => i(e)) : i(s) } min (e, t) { return new tA({ ...this._def, minSize: { value: e, message: F.toString(t) } }) } max (e, t) { return new tA({ ...this._def, maxSize: { value: e, message: F.toString(t) } }) } size (e, t) { return this.min(e, t).max(e, t) } nonempty (e) { return this.min(1, e) } } tA.create = (e, t) => new tA({ valueType: e, minSize: null, maxSize: null, typeName: U.ZodSet, ...eG(t) }); class tR extends eq { constructor() { super(...arguments), this.validate = this.implement } _parse (e) { let { ctx: t } = this._processInputParams(e); if (t.parsedType !== ek.function) return eP(t, { code: eE.invalid_type, expected: ek.function, received: t.parsedType }), eL; function n (e, n) { return eA({ data: e, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, eI(), eC].filter(e => !!e), issueData: { code: eE.invalid_arguments, argumentsError: n } }) } function r (e, n) { return eA({ data: e, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, eI(), eC].filter(e => !!e), issueData: { code: eE.invalid_return_type, returnTypeError: n } }) } let a = { errorMap: t.common.contextualErrorMap }, i = t.data; if (this._def.returns instanceof tF) { let e = this; return eD(async function (...t) { let s = new eT([]), o = await e._def.args.parseAsync(t, a).catch(e => { throw s.addIssue(n(t, e)), s }), l = await Reflect.apply(i, this, o); return await e._def.returns._def.type.parseAsync(l, a).catch(e => { throw s.addIssue(r(l, e)), s }) }) } { let e = this; return eD(function (...t) { let s = e._def.args.safeParse(t, a); if (!s.success) throw new eT([n(t, s.error)]); let o = Reflect.apply(i, this, s.data), l = e._def.returns.safeParse(o, a); if (!l.success) throw new eT([r(o, l.error)]); return l.data }) } } parameters () { return this._def.args } returnType () { return this._def.returns } args (...e) { return new tR({ ...this._def, args: tS.create(e).rest(tv.create()) }) } returns (e) { return new tR({ ...this._def, returns: e }) } implement (e) { return this.parse(e) } strictImplement (e) { return this.parse(e) } static create (e, t, n) { return new tR({ args: e || tS.create([]).rest(tv.create()), returns: t || tv.create(), typeName: U.ZodFunction, ...eG(n) }) } } class tP extends eq { get schema () { return this._def.getter() } _parse (e) { let { ctx: t } = this._processInputParams(e); return this._def.getter()._parse({ data: t.data, path: t.path, parent: t }) } } tP.create = (e, t) => new tP({ getter: e, typeName: U.ZodLazy, ...eG(t) }); class tM extends eq { _parse (e) { if (e.data !== this._def.value) { let t = this._getOrReturnCtx(e); return eP(t, { received: t.data, code: eE.invalid_literal, expected: this._def.value }), eL } return { status: "valid", value: e.data } } get value () { return this._def.value } } function tL (e, t) { return new tZ({ values: e, typeName: U.ZodEnum, ...eG(t) }) } tM.create = (e, t) => new tM({ value: e, typeName: U.ZodLiteral, ...eG(t) }); class tZ extends eq { constructor() { super(...arguments), z.set(this, void 0) } _parse (e) { if ("string" != typeof e.data) { let t = this._getOrReturnCtx(e), n = this._def.values; return eP(t, { expected: Z.joinValues(n), received: t.parsedType, code: eE.invalid_type }), eL } if (eW(this, z, "f") || eH(this, z, new Set(this._def.values), "f"), !eW(this, z, "f").has(e.data)) { let t = this._getOrReturnCtx(e), n = this._def.values; return eP(t, { received: t.data, code: eE.invalid_enum_value, options: n }), eL } return eD(e.data) } get options () { return this._def.values } get enum () { let e = {}; for (let t of this._def.values) e[t] = t; return e } get Values () { let e = {}; for (let t of this._def.values) e[t] = t; return e } get Enum () { let e = {}; for (let t of this._def.values) e[t] = t; return e } extract (e, t = this._def) { return tZ.create(e, { ...this._def, ...t }) } exclude (e, t = this._def) { return tZ.create(this.options.filter(t => !e.includes(t)), { ...this._def, ...t }) } } z = new WeakMap, tZ.create = tL; class tD extends eq { constructor() { super(...arguments), $.set(this, void 0) } _parse (e) { let t = Z.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e); if (n.parsedType !== ek.string && n.parsedType !== ek.number) { let e = Z.objectValues(t); return eP(n, { expected: Z.joinValues(e), received: n.parsedType, code: eE.invalid_type }), eL } if (eW(this, $, "f") || eH(this, $, new Set(Z.getValidEnumValues(this._def.values)), "f"), !eW(this, $, "f").has(e.data)) { let e = Z.objectValues(t); return eP(n, { received: n.data, code: eE.invalid_enum_value, options: e }), eL } return eD(e.data) } get enum () { return this._def.values } } $ = new WeakMap, tD.create = (e, t) => new tD({ values: e, typeName: U.ZodNativeEnum, ...eG(t) }); class tF extends eq { unwrap () { return this._def.type } _parse (e) { let { ctx: t } = this._processInputParams(e); return t.parsedType !== ek.promise && !1 === t.common.async ? (eP(t, { code: eE.invalid_type, expected: ek.promise, received: t.parsedType }), eL) : eD((t.parsedType === ek.promise ? t.data : Promise.resolve(t.data)).then(e => this._def.type.parseAsync(e, { path: t.path, errorMap: t.common.contextualErrorMap }))) } } tF.create = (e, t) => new tF({ type: e, typeName: U.ZodPromise, ...eG(t) }); class tz extends eq { innerType () { return this._def.schema } sourceType () { return this._def.schema._def.typeName === U.ZodEffects ? this._def.schema.sourceType() : this._def.schema } _parse (e) { let { status: t, ctx: n } = this._processInputParams(e), r = this._def.effect || null, a = { addIssue: e => { eP(n, e), e.fatal ? t.abort() : t.dirty() }, get path () { return n.path } }; if (a.addIssue = a.addIssue.bind(a), "preprocess" === r.type) { let e = r.transform(n.data, a); if (n.common.async) return Promise.resolve(e).then(async e => { if ("aborted" === t.value) return eL; let r = await this._def.schema._parseAsync({ data: e, path: n.path, parent: n }); return "aborted" === r.status ? eL : "dirty" === r.status || "dirty" === t.value ? eZ(r.value) : r }); { if ("aborted" === t.value) return eL; let r = this._def.schema._parseSync({ data: e, path: n.path, parent: n }); return "aborted" === r.status ? eL : "dirty" === r.status || "dirty" === t.value ? eZ(r.value) : r } } if ("refinement" === r.type) { let e = e => { let t = r.refinement(e, a); if (n.common.async) return Promise.resolve(t); if (t instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead."); return e }; if (!1 !== n.common.async) return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then(n => "aborted" === n.status ? eL : ("dirty" === n.status && t.dirty(), e(n.value).then(() => ({ status: t.value, value: n.value })))); { let r = this._def.schema._parseSync({ data: n.data, path: n.path, parent: n }); return "aborted" === r.status ? eL : ("dirty" === r.status && t.dirty(), e(r.value), { status: t.value, value: r.value }) } } if ("transform" === r.type) { if (!1 !== n.common.async) return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then(e => e$(e) ? Promise.resolve(r.transform(e.value, a)).then(e => ({ status: t.value, value: e })) : e); { let e = this._def.schema._parseSync({ data: n.data, path: n.path, parent: n }); if (!e$(e)) return e; let i = r.transform(e.value, a); if (i instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."); return { status: t.value, value: i } } } Z.assertNever(r) } } tz.create = (e, t, n) => new tz({ schema: e, typeName: U.ZodEffects, effect: t, ...eG(n) }), tz.createWithPreprocess = (e, t, n) => new tz({ schema: t, effect: { type: "preprocess", transform: e }, typeName: U.ZodEffects, ...eG(n) }); class t$ extends eq { _parse (e) { return this._getType(e) === ek.undefined ? eD(void 0) : this._def.innerType._parse(e) } unwrap () { return this._def.innerType } } t$.create = (e, t) => new t$({ innerType: e, typeName: U.ZodOptional, ...eG(t) }); class tU extends eq { _parse (e) { return this._getType(e) === ek.null ? eD(null) : this._def.innerType._parse(e) } unwrap () { return this._def.innerType } } tU.create = (e, t) => new tU({ innerType: e, typeName: U.ZodNullable, ...eG(t) }); class tW extends eq { _parse (e) { let { ctx: t } = this._processInputParams(e), n = t.data; return t.parsedType === ek.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({ data: n, path: t.path, parent: t }) } removeDefault () { return this._def.innerType } } tW.create = (e, t) => new tW({ innerType: e, typeName: U.ZodDefault, defaultValue: "function" == typeof t.default ? t.default : () => t.default, ...eG(t) }); class tH extends eq { _parse (e) { let { ctx: t } = this._processInputParams(e), n = { ...t, common: { ...t.common, issues: [] } }, r = this._def.innerType._parse({ data: n.data, path: n.path, parent: { ...n } }); return eU(r) ? r.then(e => ({ status: "valid", value: "valid" === e.status ? e.value : this._def.catchValue({ get error () { return new eT(n.common.issues) }, input: n.data }) })) : { status: "valid", value: "valid" === r.status ? r.value : this._def.catchValue({ get error () { return new eT(n.common.issues) }, input: n.data }) } } removeCatch () { return this._def.innerType } } tH.create = (e, t) => new tH({ innerType: e, typeName: U.ZodCatch, catchValue: "function" == typeof t.catch ? t.catch : () => t.catch, ...eG(t) }); class tV extends eq { _parse (e) { if (this._getType(e) !== ek.nan) { let t = this._getOrReturnCtx(e); return eP(t, { code: eE.invalid_type, expected: ek.nan, received: t.parsedType }), eL } return { status: "valid", value: e.data } } } tV.create = e => new tV({ typeName: U.ZodNaN, ...eG(e) }); let tB = Symbol("zod_brand"); class tG extends eq { _parse (e) { let { ctx: t } = this._processInputParams(e), n = t.data; return this._def.type._parse({ data: n, path: t.path, parent: t }) } unwrap () { return this._def.type } } class tq extends eq { _parse (e) { let { status: t, ctx: n } = this._processInputParams(e); if (n.common.async) return (async () => { let e = await this._def.in._parseAsync({ data: n.data, path: n.path, parent: n }); return "aborted" === e.status ? eL : "dirty" === e.status ? (t.dirty(), eZ(e.value)) : this._def.out._parseAsync({ data: e.value, path: n.path, parent: n }) })(); { let e = this._def.in._parseSync({ data: n.data, path: n.path, parent: n }); return "aborted" === e.status ? eL : "dirty" === e.status ? (t.dirty(), { status: "dirty", value: e.value }) : this._def.out._parseSync({ data: e.value, path: n.path, parent: n }) } } static create (e, t) { return new tq({ in: e, out: t, typeName: U.ZodPipeline }) } } class tK extends eq { _parse (e) { let t = this._def.innerType._parse(e), n = e => (e$(e) && (e.value = Object.freeze(e.value)), e); return eU(t) ? t.then(e => n(e)) : n(t) } unwrap () { return this._def.innerType } } function tQ (e, t) { let n = "function" == typeof e ? e(t) : "string" == typeof e ? { message: e } : e; return "string" == typeof n ? { message: n } : n } function tY (e, t = {}, n) { return e ? tg.create().superRefine((r, a) => { var i, s; let o = e(r); if (o instanceof Promise) return o.then(e => { var i, s; if (!e) { let e = tQ(t, r), o = null === (s = null !== (i = e.fatal) && void 0 !== i ? i : n) || void 0 === s || s; a.addIssue({ code: "custom", ...e, fatal: o }) } }); if (!o) { let e = tQ(t, r), o = null === (s = null !== (i = e.fatal) && void 0 !== i ? i : n) || void 0 === s || s; a.addIssue({ code: "custom", ...e, fatal: o }) } }) : tg.create() } tK.create = (e, t) => new tK({ innerType: e, typeName: U.ZodReadonly, ...eG(t) }); let tJ = { object: tk.lazycreate }; !function (e) { e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly" }(U || (U = {})); let tX = (e, t = { message: `Input not instance of ${e.name}` }) => tY(t => t instanceof e, t), t0 = tl.create, t1 = tc.create, t2 = tV.create, t4 = td.create, t3 = th.create, t5 = tp.create, t7 = tf.create, t9 = tm.create, t6 = tx.create, t8 = tg.create, ne = tv.create, nt = ty.create, nn = tb.create, nr = t_.create, na = tk.create, ni = tk.strictCreate, ns = tj.create, no = tO.create, nl = tC.create, nu = tS.create, nc = tN.create, nd = tI.create, nh = tA.create, np = tR.create, nf = tP.create, nm = tM.create, nx = tZ.create, ng = tD.create, nv = tF.create, ny = tz.create, nb = t$.create, n_ = tU.create, nw = tz.createWithPreprocess, nk = tq.create, nj = () => t1().optional(), nE = () => t3().optional(), nO = { string: e => tl.create({ ...e, coerce: !0 }), number: e => tc.create({ ...e, coerce: !0 }), boolean: e => th.create({ ...e, coerce: !0 }), bigint: e => td.create({ ...e, coerce: !0 }), date: e => tp.create({ ...e, coerce: !0 }) }, nT = eL; var nC = Object.freeze({ __proto__: null, defaultErrorMap: eC, setErrorMap: eN, getErrorMap: eI, makeIssue: eA, EMPTY_PATH: eR, addIssueToContext: eP, ParseStatus: eM, INVALID: eL, DIRTY: eZ, OK: eD, isAborted: eF, isDirty: ez, isValid: e$, isAsync: eU, get util () { return Z }, get objectUtil () { return D }, ZodParsedType: ek, getParsedType: ej, ZodType: eq, datetimeRegex: ta, ZodString: tl, ZodNumber: tc, ZodBigInt: td, ZodBoolean: th, ZodDate: tp, ZodSymbol: tf, ZodUndefined: tm, ZodNull: tx, ZodAny: tg, ZodUnknown: tv, ZodNever: ty, ZodVoid: tb, ZodArray: t_, ZodObject: tk, ZodUnion: tj, ZodDiscriminatedUnion: tO, ZodIntersection: tC, ZodTuple: tS, ZodRecord: tN, ZodMap: tI, ZodSet: tA, ZodFunction: tR, ZodLazy: tP, ZodLiteral: tM, ZodEnum: tZ, ZodNativeEnum: tD, ZodPromise: tF, ZodEffects: tz, ZodTransformer: tz, ZodOptional: t$, ZodNullable: tU, ZodDefault: tW, ZodCatch: tH, ZodNaN: tV, BRAND: tB, ZodBranded: tG, ZodPipeline: tq, ZodReadonly: tK, custom: tY, Schema: eq, ZodSchema: eq, late: tJ, get ZodFirstPartyTypeKind () { return U }, coerce: nO, any: t8, array: nr, bigint: t4, boolean: t3, date: t5, discriminatedUnion: no, effect: ny, enum: nx, function: np, instanceof: tX, intersection: nl, lazy: nf, literal: nm, map: nd, nan: t2, nativeEnum: ng, never: nt, null: t6, nullable: n_, number: t1, object: na, oboolean: nE, onumber: nj, optional: nb, ostring: () => t0().optional(), pipeline: nk, preprocess: nw, promise: nv, record: nc, set: nh, strictObject: ni, string: t0, symbol: t7, transformer: ny, tuple: nu, undefined: t9, union: ns, unknown: ne, void: nn, NEVER: nT, ZodIssueCode: eE, quotelessJson: eO, ZodError: eT }), nS = { breadcrumb: !0, collapsed: !1, footer: !0, layout: "default", navbar: !0, pagination: !0, sidebar: !0, timestamp: !0, toc: !0, typesetting: "default" }, nN = nC.strictObject({ breadcrumb: nC.boolean(), collapsed: nC.boolean(), footer: nC.boolean(), layout: nC.enum(["default", "full", "raw"]), navbar: nC.boolean(), pagination: nC.boolean(), sidebar: nC.boolean(), timestamp: nC.boolean(), toc: nC.boolean(), typesetting: nC.enum(["default", "article"]) }), nI = nC.enum(["normal", "hidden", "children"]), nA = nC.string(), nR = nC.strictObject({ href: nC.string(), newWindow: nC.boolean(), title: nA }), nP = nC.strictObject({ display: nI.optional(), items: nC.record(nR.partial({ href: !0, newWindow: !0 })), title: nA, type: nC.literal("menu") }), nM = nC.strictObject({ title: nA.optional(), type: nC.literal("separator") }), nL = nR.extend({ display: nI, theme: nN, title: nA, type: nC.enum(["page", "doc"]) }).deepPartial(); function nZ (e = {}, t) { "string" == typeof e && (e = { title: e }); let n = Object.assign({}, t.theme, e.theme); return Object.assign({}, t, e, { theme: n }) } function nD (e) { for (let t of e) { if (t.route) return t.route; if (t.children) { let e = nD(t.children); if (e) return e } } } function nF ({ list: e, locale: t, defaultLocale: n, route: r, docsRoot: a = "", underCurrentDocsRoot: i = !1, pageThemeContext: s = nS }) { let o, l; for (let n of e) if ("Meta" === n.kind) { if (n.locale === t) { o = n.data; break } o || (o = n.data) } let u = o || {}, c = Object.keys(u); for (let e of c) "string" == typeof u[e] && (u[e] = { title: u[e] }); let d = [], h = [], p = [], f = [], m = [], x = 0, g = s, v = [], y = -1, b = u["*"] || {}; delete b.title, delete b.href; let _ = e.filter(e => "Meta" !== e.kind && !e.name.startsWith("_") && (!("locale" in e) || !e.locale || [t, n].includes(e.locale))).sort((e, t) => { let n = c.indexOf(e.name), r = c.indexOf(t.name); return -1 === n && -1 === r ? e.name < t.name ? -1 : 1 : -1 === n ? 1 : -1 === r ? -1 : n - r }).flatMap(e => { let t; let n = [], r = c.indexOf(e.name); if (-1 !== r) { for (let e = y + 1; e < r; e++) { let t = c[e]; "*" !== t && n.push({ name: t, route: "", ...u[t] }) } y = r, t = { ...u[e.name], ...e } } return n.push(t || e), n }); for (let e = y + 1; e < c.length; e++) { let t = c[e]; "*" !== t && _.push({ name: t, route: "#", ...u[t] }) } for (let e = 0; e < _.length; e++) { let o = _[e]; if (e + 1 < _.length && o.name === _[e + 1].name) { _[e + 1] = { ..._[e + 1], withIndexPage: !0 }, o.children && !_[e + 1].children && (_[e + 1].children = o.children); continue } let c = nZ(u[o.name], b), { display: y, type: w = "doc" } = c, k = { ...s, ...c.theme }, j = r.startsWith(a), E = o.children && nF({ list: o.children, locale: t, defaultLocale: n, route: r, docsRoot: "page" === w || "menu" === w ? o.route : a, underCurrentDocsRoot: i || j, pageThemeContext: k }), O = c.title || "separator" !== w && o.name, T = () => ({ ...o, type: w, ...O && { title: O }, ...y && { display: y }, ...E && { children: [] } }), C = T(), S = T(), N = T(); if (S.isUnderCurrentDocsTree = j, "separator" === w && (C.isUnderCurrentDocsTree = j), o.route === r) switch (v = [C], l = w, g = { ...g, ...k }, w) { case "page": case "menu": x = m.length; break; case "doc": x = f.length }if (!("hidden" === y && "Folder" !== C.kind || er.hV.has(o.route))) { if (E) { if (void 0 !== E.activeIndex && void 0 !== E.activeType) { switch (g = E.activeThemeContext, l = E.activeType, v = [C, ...E.activePath], l) { case "page": case "menu": x = m.length + E.activeIndex; break; case "doc": x = f.length + E.activeIndex }o.withIndexPage && "doc" === w && x++ } switch (w) { case "page": case "menu": N.children.push(...E.directories), p.push(...E.docsDirectories), E.flatDirectories.length ? (N.firstChildRoute = nD(E.flatDirectories), m.push(N)) : N.withIndexPage && m.push(N); break; case "doc": Array.isArray(S.children) && S.children.push(...E.docsDirectories), C.withIndexPage && "children" !== y && f.push(S) }h.push(...E.flatDirectories), f.push(...E.flatDocsDirectories), Array.isArray(C.children) && C.children.push(...E.directories) } else switch (h.push(C), w) { case "page": case "menu": m.push(N); break; case "doc": f.push(S) }switch ("doc" === w && "children" === y ? S.children && (d.push(...S.children), p.push(...S.children)) : d.push(C), w) { case "page": case "menu": p.push(N); break; case "doc": "children" !== y && p.push(S); break; case "separator": p.push(C) } } } return { activeType: l, activeIndex: x, activeThemeContext: g, activePath: v, directories: d, flatDirectories: h, docsDirectories: p, flatDocsDirectories: f, topLevelNavbarItems: m } } function nz ({ pathClassName: e, ...t }) { return (0, eu.jsx)("svg", { fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", ...t, children: (0, eu.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 5l7 7-7 7", className: e }) }) } function n$ (e) { return (0, eu.jsx)("svg", { viewBox: "0 0 20 20", width: "1em", height: "1em", fill: "currentColor", ...e, children: (0, eu.jsx)("path", { fillRule: "evenodd", d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z", clipRule: "evenodd" }) }) } function nU (e) { return (0, eu.jsxs)("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", stroke: "currentColor", ...e, children: [(0, eu.jsx)("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }), (0, eu.jsx)("path", { d: "M5 15H4C2.89543 15 2 14.1046 2 13V4C2 2.89543 2.89543 2 4 2H13C14.1046 2 15 2.89543 15 4V5", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" })] }) } function nW (e) { return (0, eu.jsxs)("svg", { width: "24", height: "24", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 5 30.67 23.25", ...e, children: [(0, eu.jsx)("title", { children: "Discord" }), (0, eu.jsx)("path", { d: "M26.0015 6.9529C24.0021 6.03845 21.8787 5.37198 19.6623 5C19.3833 5.48048 19.0733 6.13144 18.8563 6.64292C16.4989 6.30193 14.1585 6.30193 11.8336 6.64292C11.6166 6.13144 11.2911 5.48048 11.0276 5C8.79575 5.37198 6.67235 6.03845 4.6869 6.9529C0.672601 12.8736 -0.41235 18.6548 0.130124 24.3585C2.79599 26.2959 5.36889 27.4739 7.89682 28.2489C8.51679 27.4119 9.07477 26.5129 9.55525 25.5675C8.64079 25.2265 7.77283 24.808 6.93587 24.312C7.15286 24.1571 7.36986 23.9866 7.57135 23.8161C12.6241 26.1255 18.0969 26.1255 23.0876 23.8161C23.3046 23.9866 23.5061 24.1571 23.7231 24.312C22.8861 24.808 22.0182 25.2265 21.1037 25.5675C21.5842 26.5129 22.1422 27.4119 22.7621 28.2489C25.2885 27.4739 27.8769 26.2959 30.5288 24.3585C31.1952 17.7559 29.4733 12.0212 26.0015 6.9529ZM10.2527 20.8402C8.73376 20.8402 7.49382 19.4608 7.49382 17.7714C7.49382 16.082 8.70276 14.7025 10.2527 14.7025C11.7871 14.7025 13.0425 16.082 13.0115 17.7714C13.0115 19.4608 11.7871 20.8402 10.2527 20.8402ZM20.4373 20.8402C18.9183 20.8402 17.6768 19.4608 17.6768 17.7714C17.6768 16.082 18.8873 14.7025 20.4373 14.7025C21.9717 14.7025 23.2271 16.082 23.1961 17.7714C23.1961 19.4608 21.9872 20.8402 20.4373 20.8402Z" })] }) } function nH ({ isOpen: e, ...t }) { return (0, eu.jsxs)("svg", { height: "12", width: "12", viewBox: "0 0 16 16", fill: "currentColor", ...t, children: [(0, eu.jsx)("path", { fillRule: "evenodd", d: "M4.177 7.823l2.396-2.396A.25.25 0 017 5.604v4.792a.25.25 0 01-.427.177L4.177 8.177a.25.25 0 010-.354z", className: e ? "" : "nx-origin-[35%] nx-rotate-180" }), (0, eu.jsx)("path", { fillRule: "evenodd", d: "M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v12.5A1.75 1.75 0 0114.25 16H1.75A1.75 1.75 0 010 14.25V1.75zm1.75-.25a.25.25 0 00-.25.25v12.5c0 .138.112.25.25.25H9.5v-13H1.75zm12.5 13H11v-13h3.25a.25.25 0 01.25.25v12.5a.25.25 0 01-.25.25z" })] }) } function nV (e) { return (0, eu.jsxs)("svg", { width: "24", height: "24", fill: "currentColor", viewBox: "3 3 18 18", ...e, children: [(0, eu.jsx)("title", { children: "GitHub" }), (0, eu.jsx)("path", { d: "M12 3C7.0275 3 3 7.12937 3 12.2276C3 16.3109 5.57625 19.7597 9.15374 20.9824C9.60374 21.0631 9.77249 20.7863 9.77249 20.5441C9.77249 20.3249 9.76125 19.5982 9.76125 18.8254C7.5 19.2522 6.915 18.2602 6.735 17.7412C6.63375 17.4759 6.19499 16.6569 5.8125 16.4378C5.4975 16.2647 5.0475 15.838 5.80124 15.8264C6.51 15.8149 7.01625 16.4954 7.18499 16.7723C7.99499 18.1679 9.28875 17.7758 9.80625 17.5335C9.885 16.9337 10.1212 16.53 10.38 16.2993C8.3775 16.0687 6.285 15.2728 6.285 11.7432C6.285 10.7397 6.63375 9.9092 7.20749 9.26326C7.1175 9.03257 6.8025 8.08674 7.2975 6.81794C7.2975 6.81794 8.05125 6.57571 9.77249 7.76377C10.4925 7.55615 11.2575 7.45234 12.0225 7.45234C12.7875 7.45234 13.5525 7.55615 14.2725 7.76377C15.9937 6.56418 16.7475 6.81794 16.7475 6.81794C17.2424 8.08674 16.9275 9.03257 16.8375 9.26326C17.4113 9.9092 17.76 10.7281 17.76 11.7432C17.76 15.2843 15.6563 16.0687 13.6537 16.2993C13.98 16.5877 14.2613 17.1414 14.2613 18.0065C14.2613 19.2407 14.25 20.2326 14.25 20.5441C14.25 20.7863 14.4188 21.0746 14.8688 20.9824C16.6554 20.364 18.2079 19.1866 19.3078 17.6162C20.4077 16.0457 20.9995 14.1611 21 12.2276C21 7.12937 16.9725 3 12 3Z" })] }) } function nB (e) { return (0, eu.jsx)("svg", { viewBox: "2 2 16 16", width: "12", height: "12", fill: "currentColor", ...e, children: (0, eu.jsx)("path", { fillRule: "evenodd", d: "M4.083 9h1.946c.089-1.546.383-2.97.837-4.118A6.004 6.004 0 004.083 9zM10 2a8 8 0 100 16 8 8 0 000-16zm0 2c-.076 0-.232.032-.465.262-.238.234-.497.623-.737 1.182-.389.907-.673 2.142-.766 3.556h3.936c-.093-1.414-.377-2.649-.766-3.556-.24-.56-.5-.948-.737-1.182C10.232 4.032 10.076 4 10 4zm3.971 5c-.089-1.546-.383-2.97-.837-4.118A6.004 6.004 0 0115.917 9h-1.946zm-2.003 2H8.032c.093 1.414.377 2.649.766 3.556.24.56.5.948.737 1.182.233.23.389.262.465.262.076 0 .232-.032.465-.262.238-.234.498-.623.737-1.182.389-.907.673-2.142.766-3.556zm1.166 4.118c.454-1.147.748-2.572.837-4.118h1.946a6.004 6.004 0 01-2.783 4.118zm-6.268 0C6.412 13.97 6.118 12.546 6.03 11H4.083a6.004 6.004 0 002.783 4.118z", clipRule: "evenodd" }) }) } function nG (e) { return (0, eu.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", width: "20", height: "20", ...e, children: (0, eu.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" }) }) } function nq (e) { return (0, eu.jsxs)("svg", { fill: "none", width: "24", height: "24", viewBox: "0 0 24 24", stroke: "currentColor", ...e, children: [(0, eu.jsx)("g", { children: (0, eu.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M4 6h16" }) }), (0, eu.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M4 12h16" }), (0, eu.jsx)("g", { children: (0, eu.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M4 18h16" }) })] }) } function nK (e) { return (0, eu.jsx)("svg", { fill: "none", viewBox: "2 2 20 20", width: "12", height: "12", stroke: "currentColor", ...e, children: (0, eu.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", fill: "currentColor", d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" }) }) } function nQ (e) { return (0, eu.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", width: "24", height: "24", ...e, children: [(0, eu.jsx)("circle", { className: "nx-opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), (0, eu.jsx)("path", { className: "nx-opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })] }) } function nY (e) { return (0, eu.jsx)("svg", { fill: "none", viewBox: "3 3 18 18", width: "12", height: "12", stroke: "currentColor", ...e, children: (0, eu.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", fill: "currentColor", d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" }) }) } function nJ (e) { return (0, eu.jsx)("svg", { viewBox: "0 0 24 24", width: "24", height: "24", ...e, children: (0, eu.jsx)("path", { fill: "currentColor", d: "M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3l3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z" }) }) } function nX (e) { return (0, eu.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 20 20", fill: "currentColor", ...e, children: (0, eu.jsx)("path", { fillRule: "evenodd", d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z", clipRule: "evenodd" }) }) } nC.string().or(nP).or(nM).or(nL); var n0 = n(4728), n1 = n.n(n0); function n2 (e) { if (null == e) return window; if ("[object Window]" !== e.toString()) { var t = e.ownerDocument; return t && t.defaultView || window } return e } function n4 (e) { var t = n2(e).Element; return e instanceof t || e instanceof Element } function n3 (e) { var t = n2(e).HTMLElement; return e instanceof t || e instanceof HTMLElement } function n5 (e) { if ("undefined" == typeof ShadowRoot) return !1; var t = n2(e).ShadowRoot; return e instanceof t || e instanceof ShadowRoot } var n7 = Math.max, n9 = Math.min, n6 = Math.round; function n8 () { var e = navigator.userAgentData; return null != e && e.brands ? e.brands.map(function (e) { return e.brand + "/" + e.version }).join(" ") : navigator.userAgent } function re () { return !/^((?!chrome|android).)*safari/i.test(n8()) } function rt (e, t, n) { void 0 === t && (t = !1), void 0 === n && (n = !1); var r = e.getBoundingClientRect(), a = 1, i = 1; t && n3(e) && (a = e.offsetWidth > 0 && n6(r.width) / e.offsetWidth || 1, i = e.offsetHeight > 0 && n6(r.height) / e.offsetHeight || 1); var s = (n4(e) ? n2(e) : window).visualViewport, o = !re() && n, l = (r.left + (o && s ? s.offsetLeft : 0)) / a, u = (r.top + (o && s ? s.offsetTop : 0)) / i, c = r.width / a, d = r.height / i; return { width: c, height: d, top: u, right: l + c, bottom: u + d, left: l, x: l, y: u } } function rn (e) { var t = n2(e); return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset } } function rr (e) { return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } } function ra (e) { return e !== n2(e) && n3(e) ? rr(e) : rn(e) } function ri (e) { return e ? (e.nodeName || "").toLowerCase() : null } function rs (e) { return ((n4(e) ? e.ownerDocument : e.document) || window.document).documentElement } function ro (e) { return rt(rs(e)).left + rn(e).scrollLeft } function rl (e) { return n2(e).getComputedStyle(e) } function ru (e) { var t = rl(e), n = t.overflow, r = t.overflowX, a = t.overflowY; return /auto|scroll|overlay|hidden/.test(n + a + r) } function rc (e) { var t = e.getBoundingClientRect(), n = n6(t.width) / e.offsetWidth || 1, r = n6(t.height) / e.offsetHeight || 1; return 1 !== n || 1 !== r } function rd (e, t, n) { void 0 === n && (n = !1); var r = n3(t), a = n3(t) && rc(t), i = rs(t), s = rt(e, a, n), o = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 }; return (r || !r && !n) && (("body" !== ri(t) || ru(i)) && (o = ra(t)), n3(t) ? (l = rt(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : i && (l.x = ro(i))), { x: s.left + o.scrollLeft - l.x, y: s.top + o.scrollTop - l.y, width: s.width, height: s.height } } function rh (e) { var t = rt(e), n = e.offsetWidth, r = e.offsetHeight; return 1 >= Math.abs(t.width - n) && (n = t.width), 1 >= Math.abs(t.height - r) && (r = t.height), { x: e.offsetLeft, y: e.offsetTop, width: n, height: r } } function rp (e) { return "html" === ri(e) ? e : e.assignedSlot || e.parentNode || (n5(e) ? e.host : null) || rs(e) } function rf (e) { return ["html", "body", "#document"].indexOf(ri(e)) >= 0 ? e.ownerDocument.body : n3(e) && ru(e) ? e : rf(rp(e)) } function rm (e, t) { void 0 === t && (t = []); var n, r = rf(e), a = r === (null == (n = e.ownerDocument) ? void 0 : n.body), i = n2(r), s = a ? [i].concat(i.visualViewport || [], ru(r) ? r : []) : r, o = t.concat(s); return a ? o : o.concat(rm(rp(s))) } function rx (e) { return ["table", "td", "th"].indexOf(ri(e)) >= 0 } function rg (e) { return n3(e) && "fixed" !== rl(e).position ? e.offsetParent : null } function rv (e) { var t = /firefox/i.test(n8()); if (/Trident/i.test(n8()) && n3(e) && "fixed" === rl(e).position) return null; var n = rp(e); for (n5(n) && (n = n.host); n3(n) && 0 > ["html", "body"].indexOf(ri(n));) { var r = rl(n); if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || t && "filter" === r.willChange || t && r.filter && "none" !== r.filter) return n; n = n.parentNode } return null } function ry (e) { for (var t = n2(e), n = rg(e); n && rx(n) && "static" === rl(n).position;)n = rg(n); return n && ("html" === ri(n) || "body" === ri(n) && "static" === rl(n).position) ? t : n || rv(e) || t } var rb = "top", r_ = "bottom", rw = "right", rk = "left", rj = "auto", rE = [rb, r_, rw, rk], rO = "start", rT = "end", rC = "clippingParents", rS = "viewport", rN = "popper", rI = "reference", rA = rE.reduce(function (e, t) { return e.concat([t + "-" + rO, t + "-" + rT]) }, []), rR = [].concat(rE, [rj]).reduce(function (e, t) { return e.concat([t, t + "-" + rO, t + "-" + rT]) }, []), rP = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"]; function rM (e) { var t = new Map, n = new Set, r = []; function a (e) { n.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) { if (!n.has(e)) { var r = t.get(e); r && a(r) } }), r.push(e) } return e.forEach(function (e) { t.set(e.name, e) }), e.forEach(function (e) { n.has(e.name) || a(e) }), r } function rL (e) { var t = rM(e); return rP.reduce(function (e, n) { return e.concat(t.filter(function (e) { return e.phase === n })) }, []) } function rZ (e) { var t; return function () { return t || (t = new Promise(function (n) { Promise.resolve().then(function () { t = void 0, n(e()) }) })), t } } function rD (e) { var t = e.reduce(function (e, t) { var n = e[t.name]; return e[t.name] = n ? Object.assign({}, n, t, { options: Object.assign({}, n.options, t.options), data: Object.assign({}, n.data, t.data) }) : t, e }, {}); return Object.keys(t).map(function (e) { return t[e] }) } var rF = { placement: "bottom", modifiers: [], strategy: "absolute" }; function rz () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return !t.some(function (e) { return !(e && "function" == typeof e.getBoundingClientRect) }) } var r$ = { passive: !0 }; function rU (e) { return e.split("-")[0] } function rW (e) { return e.split("-")[1] } function rH (e) { return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y" } function rV (e) { var t, n = e.reference, r = e.element, a = e.placement, i = a ? rU(a) : null, s = a ? rW(a) : null, o = n.x + n.width / 2 - r.width / 2, l = n.y + n.height / 2 - r.height / 2; switch (i) { case rb: t = { x: o, y: n.y - r.height }; break; case r_: t = { x: o, y: n.y + n.height }; break; case rw: t = { x: n.x + n.width, y: l }; break; case rk: t = { x: n.x - r.width, y: l }; break; default: t = { x: n.x, y: n.y } }var u = i ? rH(i) : null; if (null != u) { var c = "y" === u ? "height" : "width"; switch (s) { case rO: t[u] = t[u] - (n[c] / 2 - r[c] / 2); break; case rT: t[u] = t[u] + (n[c] / 2 - r[c] / 2) } } return t } var rB = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function rG (e) { var t = e.x, n = e.y, r = window.devicePixelRatio || 1; return { x: n6(t * r) / r || 0, y: n6(n * r) / r || 0 } } function rq (e) { var t, n, r = e.popper, a = e.popperRect, i = e.placement, s = e.variation, o = e.offsets, l = e.position, u = e.gpuAcceleration, c = e.adaptive, d = e.roundOffsets, h = e.isFixed, p = o.x, f = void 0 === p ? 0 : p, m = o.y, x = void 0 === m ? 0 : m, g = "function" == typeof d ? d({ x: f, y: x }) : { x: f, y: x }; f = g.x, x = g.y; var v = o.hasOwnProperty("x"), y = o.hasOwnProperty("y"), b = rk, _ = rb, w = window; if (c) { var k = ry(r), j = "clientHeight", E = "clientWidth"; k === n2(r) && "static" !== rl(k = rs(r)).position && "absolute" === l && (j = "scrollHeight", E = "scrollWidth"), (i === rb || (i === rk || i === rw) && s === rT) && (_ = r_, x -= (h && k === w && w.visualViewport ? w.visualViewport.height : k[j]) - a.height, x *= u ? 1 : -1), (i === rk || (i === rb || i === r_) && s === rT) && (b = rw, f -= (h && k === w && w.visualViewport ? w.visualViewport.width : k[E]) - a.width, f *= u ? 1 : -1) } var O = Object.assign({ position: l }, c && rB), T = !0 === d ? rG({ x: f, y: x }) : { x: f, y: x }; return (f = T.x, x = T.y, u) ? Object.assign({}, O, ((n = {})[_] = y ? "0" : "", n[b] = v ? "0" : "", n.transform = 1 >= (w.devicePixelRatio || 1) ? "translate(" + f + "px, " + x + "px)" : "translate3d(" + f + "px, " + x + "px, 0)", n)) : Object.assign({}, O, ((t = {})[_] = y ? x + "px" : "", t[b] = v ? f + "px" : "", t.transform = "", t)) } function rK (e, t, n) { var r = rU(e), a = [rk, rb].indexOf(r) >= 0 ? -1 : 1, i = "function" == typeof n ? n(Object.assign({}, t, { placement: e })) : n, s = i[0], o = i[1]; return s = s || 0, o = (o || 0) * a, [rk, rw].indexOf(r) >= 0 ? { x: o, y: s } : { x: s, y: o } } var rQ = { left: "right", right: "left", bottom: "top", top: "bottom" }; function rY (e) { return e.replace(/left|right|bottom|top/g, function (e) { return rQ[e] }) } var rJ = { start: "end", end: "start" }; function rX (e) { return e.replace(/start|end/g, function (e) { return rJ[e] }) } function r0 (e, t) { var n = n2(e), r = rs(e), a = n.visualViewport, i = r.clientWidth, s = r.clientHeight, o = 0, l = 0; if (a) { i = a.width, s = a.height; var u = re(); (u || !u && "fixed" === t) && (o = a.offsetLeft, l = a.offsetTop) } return { width: i, height: s, x: o + ro(e), y: l } } function r1 (e) { var t, n = rs(e), r = rn(e), a = null == (t = e.ownerDocument) ? void 0 : t.body, i = n7(n.scrollWidth, n.clientWidth, a ? a.scrollWidth : 0, a ? a.clientWidth : 0), s = n7(n.scrollHeight, n.clientHeight, a ? a.scrollHeight : 0, a ? a.clientHeight : 0), o = -r.scrollLeft + ro(e), l = -r.scrollTop; return "rtl" === rl(a || n).direction && (o += n7(n.clientWidth, a ? a.clientWidth : 0) - i), { width: i, height: s, x: o, y: l } } function r2 (e, t) { var n = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (n && n5(n)) { var r = t; do { if (r && e.isSameNode(r)) return !0; r = r.parentNode || r.host } while (r) } return !1 } function r4 (e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function r3 (e, t) { var n = rt(e, !1, "fixed" === t); return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n } function r5 (e, t, n) { return t === rS ? r4(r0(e, n)) : n4(t) ? r3(t, n) : r4(r1(rs(e))) } function r7 (e) { var t = rm(rp(e)), n = ["absolute", "fixed"].indexOf(rl(e).position) >= 0 && n3(e) ? ry(e) : e; return n4(n) ? t.filter(function (e) { return n4(e) && r2(e, n) && "body" !== ri(e) }) : [] } function r9 (e, t, n, r) { var a = [].concat("clippingParents" === t ? r7(e) : [].concat(t), [n]), i = a[0], s = a.reduce(function (t, n) { var a = r5(e, n, r); return t.top = n7(a.top, t.top), t.right = n9(a.right, t.right), t.bottom = n9(a.bottom, t.bottom), t.left = n7(a.left, t.left), t }, r5(e, i, r)); return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s } function r6 () { return { top: 0, right: 0, bottom: 0, left: 0 } } function r8 (e) { return Object.assign({}, r6(), e) } function ae (e, t) { return t.reduce(function (t, n) { return t[n] = e, t }, {}) } function at (e, t) { void 0 === t && (t = {}); var n = t, r = n.placement, a = void 0 === r ? e.placement : r, i = n.strategy, s = void 0 === i ? e.strategy : i, o = n.boundary, l = void 0 === o ? rC : o, u = n.rootBoundary, c = void 0 === u ? rS : u, d = n.elementContext, h = void 0 === d ? rN : d, p = n.altBoundary, f = void 0 !== p && p, m = n.padding, x = void 0 === m ? 0 : m, g = r8("number" != typeof x ? x : ae(x, rE)), v = h === rN ? rI : rN, y = e.rects.popper, b = e.elements[f ? v : h], _ = r9(n4(b) ? b : b.contextElement || rs(e.elements.popper), l, c, s), w = rt(e.elements.reference), k = rV({ reference: w, element: y, strategy: "absolute", placement: a }), j = r4(Object.assign({}, y, k)), E = h === rN ? j : w, O = { top: _.top - E.top + g.top, bottom: E.bottom - _.bottom + g.bottom, left: _.left - E.left + g.left, right: E.right - _.right + g.right }, T = e.modifiersData.offset; if (h === rN && T) { var C = T[a]; Object.keys(O).forEach(function (e) { var t = [rw, r_].indexOf(e) >= 0 ? 1 : -1, n = [rb, r_].indexOf(e) >= 0 ? "y" : "x"; O[e] += C[n] * t }) } return O } function an (e, t) { void 0 === t && (t = {}); var n = t, r = n.placement, a = n.boundary, i = n.rootBoundary, s = n.padding, o = n.flipVariations, l = n.allowedAutoPlacements, u = void 0 === l ? rR : l, c = rW(r), d = c ? o ? rA : rA.filter(function (e) { return rW(e) === c }) : rE, h = d.filter(function (e) { return u.indexOf(e) >= 0 }); 0 === h.length && (h = d); var p = h.reduce(function (t, n) { return t[n] = at(e, { placement: n, boundary: a, rootBoundary: i, padding: s })[rU(n)], t }, {}); return Object.keys(p).sort(function (e, t) { return p[e] - p[t] }) } function ar (e) { if (rU(e) === rj) return []; var t = rY(e); return [rX(e), t, rX(t)] } function aa (e) { return "x" === e ? "y" : "x" } function ai (e, t, n) { return n7(e, n9(t, n)) } function as (e, t, n) { var r = ai(e, t, n); return r > n ? n : r } var ao = function (e, t) { return r8("number" != typeof (e = "function" == typeof e ? e(Object.assign({}, t.rects, { placement: t.placement })) : e) ? e : ae(e, rE)) }; function al (e, t, n) { return void 0 === n && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x } } function au (e) { return [rb, rw, r_, rk].some(function (t) { return e[t] >= 0 }) } var ac = function (e) { void 0 === e && (e = {}); var t = e, n = t.defaultModifiers, r = void 0 === n ? [] : n, a = t.defaultOptions, i = void 0 === a ? rF : a; return function (e, t, n) { void 0 === n && (n = i); var a = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, rF, i), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }, s = [], o = !1, l = { state: a, setOptions: function (n) { var s = "function" == typeof n ? n(a.options) : n; c(), a.options = Object.assign({}, i, a.options, s), a.scrollParents = { reference: n4(e) ? rm(e) : e.contextElement ? rm(e.contextElement) : [], popper: rm(t) }; var o = rL(rD([].concat(r, a.options.modifiers))); return a.orderedModifiers = o.filter(function (e) { return e.enabled }), u(), l.update() }, forceUpdate: function () { if (!o) { var e = a.elements, t = e.reference, n = e.popper; if (rz(t, n)) { a.rects = { reference: rd(t, ry(n), "fixed" === a.options.strategy), popper: rh(n) }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function (e) { return a.modifiersData[e.name] = Object.assign({}, e.data) }); for (var r = 0; r < a.orderedModifiers.length; r++) { if (!0 === a.reset) { a.reset = !1, r = -1; continue } var i = a.orderedModifiers[r], s = i.fn, u = i.options, c = void 0 === u ? {} : u, d = i.name; "function" == typeof s && (a = s({ state: a, options: c, name: d, instance: l }) || a) } } } }, update: rZ(function () { return new Promise(function (e) { l.forceUpdate(), e(a) }) }), destroy: function () { c(), o = !0 } }; if (!rz(e, t)) return l; function u () { a.orderedModifiers.forEach(function (e) { var t = e.name, n = e.options, r = void 0 === n ? {} : n, i = e.effect; if ("function" == typeof i) { var o = i({ state: a, name: t, instance: l, options: r }), u = function () { }; s.push(o || u) } }) } function c () { s.forEach(function (e) { return e() }), s = [] } return l.setOptions(n).then(function (e) { !o && n.onFirstUpdate && n.onFirstUpdate(e) }), l } }({ defaultModifiers: [{ name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (e) { var t = e.state, n = e.instance, r = e.options, a = r.scroll, i = void 0 === a || a, s = r.resize, o = void 0 === s || s, l = n2(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper); return i && u.forEach(function (e) { e.addEventListener("scroll", n.update, r$) }), o && l.addEventListener("resize", n.update, r$), function () { i && u.forEach(function (e) { e.removeEventListener("scroll", n.update, r$) }), o && l.removeEventListener("resize", n.update, r$) } }, data: {} }, { name: "popperOffsets", enabled: !0, phase: "read", fn: function (e) { var t = e.state, n = e.name; t.modifiersData[n] = rV({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) }, data: {} }, { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (e) { var t = e.state, n = e.options, r = n.gpuAcceleration, a = void 0 === r || r, i = n.adaptive, s = void 0 === i || i, o = n.roundOffsets, l = void 0 === o || o, u = { placement: rU(t.placement), variation: rW(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: a, isFixed: "fixed" === t.options.strategy }; null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, rq(Object.assign({}, u, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: s, roundOffsets: l })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, rq(Object.assign({}, u, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }) }, data: {} }, { name: "applyStyles", enabled: !0, phase: "write", fn: function (e) { var t = e.state; Object.keys(t.elements).forEach(function (e) { var n = t.styles[e] || {}, r = t.attributes[e] || {}, a = t.elements[e]; n3(a) && ri(a) && (Object.assign(a.style, n), Object.keys(r).forEach(function (e) { var t = r[e]; !1 === t ? a.removeAttribute(e) : a.setAttribute(e, !0 === t ? "" : t) })) }) }, effect: function (e) { var t = e.state, n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () { Object.keys(t.elements).forEach(function (e) { var r = t.elements[e], a = t.attributes[e] || {}, i = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce(function (e, t) { return e[t] = "", e }, {}); n3(r) && ri(r) && (Object.assign(r.style, i), Object.keys(a).forEach(function (e) { r.removeAttribute(e) })) }) } }, requires: ["computeStyles"] }, { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) { var t = e.state, n = e.options, r = e.name, a = n.offset, i = void 0 === a ? [0, 0] : a, s = rR.reduce(function (e, n) { return e[n] = rK(n, t.rects, i), e }, {}), o = s[t.placement], l = o.x, u = o.y; null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += u), t.modifiersData[r] = s } }, { name: "flip", enabled: !0, phase: "main", fn: function (e) { var t = e.state, n = e.options, r = e.name; if (!t.modifiersData[r]._skip) { for (var a = n.mainAxis, i = void 0 === a || a, s = n.altAxis, o = void 0 === s || s, l = n.fallbackPlacements, u = n.padding, c = n.boundary, d = n.rootBoundary, h = n.altBoundary, p = n.flipVariations, f = void 0 === p || p, m = n.allowedAutoPlacements, x = t.options.placement, g = rU(x) === x, v = l || (g || !f ? [rY(x)] : ar(x)), y = [x].concat(v).reduce(function (e, n) { return e.concat(rU(n) === rj ? an(t, { placement: n, boundary: c, rootBoundary: d, padding: u, flipVariations: f, allowedAutoPlacements: m }) : n) }, []), b = t.rects.reference, _ = t.rects.popper, w = new Map, k = !0, j = y[0], E = 0; E < y.length; E++) { var O = y[E], T = rU(O), C = rW(O) === rO, S = [rb, r_].indexOf(T) >= 0, N = S ? "width" : "height", I = at(t, { placement: O, boundary: c, rootBoundary: d, altBoundary: h, padding: u }), A = S ? C ? rw : rk : C ? r_ : rb; b[N] > _[N] && (A = rY(A)); var R = rY(A), P = []; if (i && P.push(I[T] <= 0), o && P.push(I[A] <= 0, I[R] <= 0), P.every(function (e) { return e })) { j = O, k = !1; break } w.set(O, P) } if (k) for (var M = f ? 3 : 1, L = function (e) { var t = y.find(function (t) { var n = w.get(t); if (n) return n.slice(0, e).every(function (e) { return e }) }); if (t) return j = t, "break" }, Z = M; Z > 0 && "break" !== L(Z); Z--); t.placement !== j && (t.modifiersData[r]._skip = !0, t.placement = j, t.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }, { name: "preventOverflow", enabled: !0, phase: "main", fn: function (e) { var t = e.state, n = e.options, r = e.name, a = n.mainAxis, i = void 0 === a || a, s = n.altAxis, o = void 0 !== s && s, l = n.boundary, u = n.rootBoundary, c = n.altBoundary, d = n.padding, h = n.tether, p = void 0 === h || h, f = n.tetherOffset, m = void 0 === f ? 0 : f, x = at(t, { boundary: l, rootBoundary: u, padding: d, altBoundary: c }), g = rU(t.placement), v = rW(t.placement), y = !v, b = rH(g), _ = aa(b), w = t.modifiersData.popperOffsets, k = t.rects.reference, j = t.rects.popper, E = "function" == typeof m ? m(Object.assign({}, t.rects, { placement: t.placement })) : m, O = "number" == typeof E ? { mainAxis: E, altAxis: E } : Object.assign({ mainAxis: 0, altAxis: 0 }, E), T = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, C = { x: 0, y: 0 }; if (w) { if (i) { var S, N = "y" === b ? rb : rk, I = "y" === b ? r_ : rw, A = "y" === b ? "height" : "width", R = w[b], P = R + x[N], M = R - x[I], L = p ? -j[A] / 2 : 0, Z = v === rO ? k[A] : j[A], D = v === rO ? -j[A] : -k[A], F = t.elements.arrow, z = p && F ? rh(F) : { width: 0, height: 0 }, $ = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : r6(), U = $[N], W = $[I], H = ai(0, k[A], z[A]), V = y ? k[A] / 2 - L - H - U - O.mainAxis : Z - H - U - O.mainAxis, B = y ? -k[A] / 2 + L + H + W + O.mainAxis : D + H + W + O.mainAxis, G = t.elements.arrow && ry(t.elements.arrow), q = G ? "y" === b ? G.clientTop || 0 : G.clientLeft || 0 : 0, K = null != (S = null == T ? void 0 : T[b]) ? S : 0, Q = R + V - K - q, Y = R + B - K, J = ai(p ? n9(P, Q) : P, R, p ? n7(M, Y) : M); w[b] = J, C[b] = J - R } if (o) { var X, ee = "x" === b ? rb : rk, et = "x" === b ? r_ : rw, en = w[_], er = "y" === _ ? "height" : "width", ea = en + x[ee], ei = en - x[et], es = -1 !== [rb, rk].indexOf(g), eo = null != (X = null == T ? void 0 : T[_]) ? X : 0, el = es ? ea : en - k[er] - j[er] - eo + O.altAxis, eu = es ? en + k[er] + j[er] - eo - O.altAxis : ei, ec = p && es ? as(el, en, eu) : ai(p ? el : ea, en, p ? eu : ei); w[_] = ec, C[_] = ec - en } t.modifiersData[r] = C } }, requiresIfExists: ["offset"] }, { name: "arrow", enabled: !0, phase: "main", fn: function (e) { var t, n = e.state, r = e.name, a = e.options, i = n.elements.arrow, s = n.modifiersData.popperOffsets, o = rU(n.placement), l = rH(o), u = [rk, rw].indexOf(o) >= 0 ? "height" : "width"; if (i && s) { var c = ao(a.padding, n), d = rh(i), h = "y" === l ? rb : rk, p = "y" === l ? r_ : rw, f = n.rects.reference[u] + n.rects.reference[l] - s[l] - n.rects.popper[u], m = s[l] - n.rects.reference[l], x = ry(i), g = x ? "y" === l ? x.clientHeight || 0 : x.clientWidth || 0 : 0, v = f / 2 - m / 2, y = c[h], b = g - d[u] - c[p], _ = g / 2 - d[u] / 2 + v, w = ai(y, _, b), k = l; n.modifiersData[r] = ((t = {})[k] = w, t.centerOffset = w - _, t) } }, effect: function (e) { var t = e.state, n = e.options.element, r = void 0 === n ? "[data-popper-arrow]" : n; null != r && ("string" != typeof r || (r = t.elements.popper.querySelector(r))) && r2(t.elements.popper, r) && (t.elements.arrow = r) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }, { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (e) { var t = e.state, n = e.name, r = t.rects.reference, a = t.rects.popper, i = t.modifiersData.preventOverflow, s = at(t, { elementContext: "reference" }), o = at(t, { altBoundary: !0 }), l = al(s, r), u = al(o, a, i), c = au(l), d = au(u); t.modifiersData[n] = { referenceClippingOffsets: l, popperEscapeOffsets: u, isReferenceHidden: c, hasPopperEscaped: d }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": c, "data-popper-escaped": d }) } }] }), ad = n(1587), ah = n.n(ad); function ap () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return t.filter(Boolean).join(" ") } function af (e, t) { for (var n = arguments.length, r = Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)r[a - 2] = arguments[a]; if (e in t) { let n = t[e]; return "function" == typeof n ? n(...r) : n } let i = Error('Tried to handle "'.concat(e, '" but there is no handler defined. Only defined handlers are: ').concat(Object.keys(t).map(e => '"'.concat(e, '"')).join(", "), ".")); throw Error.captureStackTrace && Error.captureStackTrace(i, af), i } var am = ((a = am || {})[a.None = 0] = "None", a[a.RenderStrategy = 1] = "RenderStrategy", a[a.Static = 2] = "Static", a), ax = ((i = ax || {})[i.Unmount = 0] = "Unmount", i[i.Hidden = 1] = "Hidden", i); function ag (e) { let { ourProps: t, theirProps: n, slot: r, defaultTag: a, features: i, visible: s = !0, name: o } = e, l = ab(n, t); if (s) return av(l, r, a, o); let u = null != i ? i : 0; if (2 & u) { let { static: e = !1, ...t } = l; if (e) return av(t, r, a, o) } if (1 & u) { let { unmount: e = !0, ...t } = l; return af(e ? 0 : 1, { 0: () => null, 1: () => av({ ...t, hidden: !0, style: { display: "none" } }, r, a, o) }) } return av(l, r, a, o) } function av (e) { var t; let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = arguments.length > 2 ? arguments[2] : void 0, a = arguments.length > 3 ? arguments[3] : void 0, { as: i = r, children: s, refName: o = "ref", ...l } = ak(e, ["unmount", "static"]), u = void 0 !== e.ref ? { [o]: e.ref } : {}, c = "function" == typeof s ? s(n) : s; "className" in l && l.className && "function" == typeof l.className && (l.className = l.className(n)); let d = {}; if (n) { let e = !1, t = []; for (let [r, a] of Object.entries(n)) "boolean" == typeof a && (e = !0), !0 === a && t.push(r); e && (d["data-headlessui-state"] = t.join(" ")) } if (i === Q.Fragment && Object.keys(aw(l)).length > 0) { if (!(0, Q.isValidElement)(c) || Array.isArray(c) && c.length > 1) throw Error(['Passing props on "Fragment"!', "", "The current component <".concat(a, ' /> is rendering a "Fragment".'), "However we need to passthrough the following props:", Object.keys(l).map(e => "  - ".concat(e)).join("\n"), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map(e => "  - ".concat(e)).join("\n")].join("\n")); let e = ap(null == (t = c.props) ? void 0 : t.className, l.className), n = e ? { className: e } : {}; return (0, Q.cloneElement)(c, Object.assign({}, ab(c.props, aw(ak(l, ["ref"]))), d, u, ay(c.ref, u.ref), n)) } return (0, Q.createElement)(i, Object.assign({}, ak(l, ["ref"]), i !== Q.Fragment && u, i !== Q.Fragment && d), c) } function ay () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return { ref: t.every(e => null == e) ? void 0 : e => { for (let n of t) null != n && ("function" == typeof n ? n(e) : n.current = e) } } } function ab () { for (var e, t = arguments.length, n = Array(t), r = 0; r < t; r++)n[r] = arguments[r]; if (0 === n.length) return {}; if (1 === n.length) return n[0]; let a = {}, i = {}; for (let t of n) for (let n in t) n.startsWith("on") && "function" == typeof t[n] ? (null != (e = i[n]) || (i[n] = []), i[n].push(t[n])) : a[n] = t[n]; if (a.disabled || a["aria-disabled"]) return Object.assign(a, Object.fromEntries(Object.keys(i).map(e => [e, void 0]))); for (let e in i) Object.assign(a, { [e] (t) { for (var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)r[a - 1] = arguments[a]; for (let n of i[e]) { if ((t instanceof Event || (null == t ? void 0 : t.nativeEvent) instanceof Event) && t.defaultPrevented) return; n(t, ...r) } } }); return a } function a_ (e) { var t; return Object.assign((0, Q.forwardRef)(e), { displayName: null != (t = e.displayName) ? t : e.name }) } function aw (e) { let t = Object.assign({}, e); for (let e in t) void 0 === t[e] && delete t[e]; return t } function ak (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n = Object.assign({}, e); for (let e of t) e in n && delete n[e]; return n } let aj = (0, Q.createContext)(null); aj.displayName = "OpenClosedContext"; var aE = ((s = aE || {})[s.Open = 1] = "Open", s[s.Closed = 2] = "Closed", s[s.Closing = 4] = "Closing", s[s.Opening = 8] = "Opening", s); function aO () { return (0, Q.useContext)(aj) } function aT (e) { let { value: t, children: n } = e; return Q.createElement(aj.Provider, { value: t }, n) } var aC = Object.defineProperty, aS = (e, t, n) => t in e ? aC(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, aN = (e, t, n) => (aS(e, "symbol" != typeof t ? t + "" : t, n), n); class aI { set (e) { this.current !== e && (this.handoffState = "pending", this.currentId = 0, this.current = e) } reset () { this.set(this.detect()) } nextId () { return ++this.currentId } get isServer () { return "server" === this.current } get isClient () { return "client" === this.current } detect () { return "undefined" == typeof document ? "server" : "client" } handoff () { "pending" === this.handoffState && (this.handoffState = "complete") } get isHandoffComplete () { return "complete" === this.handoffState } constructor() { aN(this, "current", this.detect()), aN(this, "handoffState", "pending"), aN(this, "currentId", 0) } } let aA = new aI, aR = (e, t) => { aA.isServer ? (0, Q.useEffect)(e, t) : (0, Q.useLayoutEffect)(e, t) }; function aP () { let e = (0, Q.useRef)(!1); return aR(() => (e.current = !0, () => { e.current = !1 }), []), e } function aM (e) { let t = (0, Q.useRef)(e); return aR(() => { t.current = e }, [e]), t } function aL () { let [e, t] = (0, Q.useState)(aA.isHandoffComplete); return e && !1 === aA.isHandoffComplete && t(!1), (0, Q.useEffect)(() => { !0 !== e && t(!0) }, [e]), (0, Q.useEffect)(() => aA.handoff(), []), e } let aZ = function (e) { let t = aM(e); return Q.useCallback(function () { for (var e = arguments.length, n = Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return t.current(...n) }, [t]) }, aD = Symbol(); function aF () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; let r = (0, Q.useRef)(t); (0, Q.useEffect)(() => { r.current = t }, [t]); let a = aZ(e => { for (let t of r.current) null != t && ("function" == typeof t ? t(e) : t.current = e) }); return t.every(e => null == e || (null == e ? void 0 : e[aD])) ? void 0 : a } function az (e) { let t = { called: !1 }; return function () { for (var n = arguments.length, r = Array(n), a = 0; a < n; a++)r[a] = arguments[a]; if (!t.called) return t.called = !0, e(...r) } } function a$ (e) { "function" == typeof queueMicrotask ? queueMicrotask(e) : Promise.resolve().then(e).catch(e => setTimeout(() => { throw e })) } function aU () { let e = [], t = { addEventListener: (e, n, r, a) => (e.addEventListener(n, r, a), t.add(() => e.removeEventListener(n, r, a))), requestAnimationFrame () { for (var e = arguments.length, n = Array(e), r = 0; r < e; r++)n[r] = arguments[r]; let a = requestAnimationFrame(...n); return t.add(() => cancelAnimationFrame(a)) }, nextFrame () { for (var e = arguments.length, n = Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return t.requestAnimationFrame(() => t.requestAnimationFrame(...n)) }, setTimeout () { for (var e = arguments.length, n = Array(e), r = 0; r < e; r++)n[r] = arguments[r]; let a = setTimeout(...n); return t.add(() => clearTimeout(a)) }, microTask () { for (var e = arguments.length, n = Array(e), r = 0; r < e; r++)n[r] = arguments[r]; let a = { current: !0 }; return a$(() => { a.current && n[0]() }), t.add(() => { a.current = !1 }) }, style (e, t, n) { let r = e.style.getPropertyValue(t); return Object.assign(e.style, { [t]: n }), this.add(() => { Object.assign(e.style, { [t]: r }) }) }, group (e) { let t = aU(); return e(t), this.add(() => t.dispose()) }, add: t => (e.push(t), () => { let n = e.indexOf(t); if (n >= 0) for (let t of e.splice(n, 1)) t() }), dispose () { for (let t of e.splice(0)) t() } }; return t } function aW (e) { for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; e && n.length > 0 && e.classList.add(...n) } function aH (e) { for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; e && n.length > 0 && e.classList.remove(...n) } function aV (e, t) { let n = aU(); if (!e) return n.dispose; let { transitionDuration: r, transitionDelay: a } = getComputedStyle(e), [i, s] = [r, a].map(e => { let [t = 0] = e.split(",").filter(Boolean).map(e => e.includes("ms") ? parseFloat(e) : 1e3 * parseFloat(e)).sort((e, t) => t - e); return t }), o = i + s; if (0 !== o) { n.group(n => { n.setTimeout(() => { t(), n.dispose() }, o), n.addEventListener(e, "transitionrun", e => { e.target === e.currentTarget && n.dispose() }) }); let r = n.addEventListener(e, "transitionend", e => { e.target === e.currentTarget && (t(), r()) }) } else t(); return n.add(() => t()), n.dispose } function aB (e, t, n, r) { let a = n ? "enter" : "leave", i = aU(), s = void 0 !== r ? az(r) : () => { }; "enter" === a && (e.removeAttribute("hidden"), e.style.display = ""); let o = af(a, { enter: () => t.enter, leave: () => t.leave }), l = af(a, { enter: () => t.enterTo, leave: () => t.leaveTo }), u = af(a, { enter: () => t.enterFrom, leave: () => t.leaveFrom }); return aH(e, ...t.enter, ...t.enterTo, ...t.enterFrom, ...t.leave, ...t.leaveFrom, ...t.leaveTo, ...t.entered), aW(e, ...o, ...u), i.nextFrame(() => { aH(e, ...u), aW(e, ...l), aV(e, () => (aH(e, ...o), aW(e, ...t.entered), s())) }), i.dispose } function aG () { let [e] = (0, Q.useState)(aU); return (0, Q.useEffect)(() => () => e.dispose(), [e]), e } function aq (e) { let { container: t, direction: n, classes: r, onStart: a, onStop: i } = e, s = aP(), o = aG(), l = aM(n); aR(() => { let e = aU(); o.add(e.dispose); let n = t.current; if (n && "idle" !== l.current && s.current) return e.dispose(), a.current(l.current), e.add(aB(n, r.current, "enter" === l.current, () => { e.dispose(), i.current(l.current) })), e.dispose }, [n]) } function aK () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, [t, n] = (0, Q.useState)(e), r = (0, Q.useCallback)(e => n(t => t | e), [t]), a = (0, Q.useCallback)(e => !!(t & e), [t]); return { flags: t, addFlag: r, hasFlag: a, removeFlag: (0, Q.useCallback)(e => n(t => t & ~e), [n]), toggleFlag: (0, Q.useCallback)(e => n(t => t ^ e), [n]) } } function aQ () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""; return e.split(" ").filter(e => e.trim().length > 1) } let aY = (0, Q.createContext)(null); aY.displayName = "TransitionContext"; var aJ = ((o = aJ || {}).Visible = "visible", o.Hidden = "hidden", o); function aX () { let e = (0, Q.useContext)(aY); if (null === e) throw Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />."); return e } function a0 () { let e = (0, Q.useContext)(a1); if (null === e) throw Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />."); return e } let a1 = (0, Q.createContext)(null); function a2 (e) { return "children" in e ? a2(e.children) : e.current.filter(e => { let { el: t } = e; return null !== t.current }).filter(e => { let { state: t } = e; return "visible" === t }).length > 0 } function a4 (e, t) { let n = aM(e), r = (0, Q.useRef)([]), a = aP(), i = aG(), s = aZ(function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ax.Hidden, s = r.current.findIndex(t => { let { el: n } = t; return n === e }); -1 !== s && (af(t, { [ax.Unmount] () { r.current.splice(s, 1) }, [ax.Hidden] () { r.current[s].state = "hidden" } }), i.microTask(() => { var e; !a2(r) && a.current && (null == (e = n.current) || e.call(n)) })) }), o = aZ(e => { let t = r.current.find(t => { let { el: n } = t; return n === e }); return t ? "visible" !== t.state && (t.state = "visible") : r.current.push({ el: e, state: "visible" }), () => s(e, ax.Unmount) }), l = (0, Q.useRef)([]), u = (0, Q.useRef)(Promise.resolve()), c = (0, Q.useRef)({ enter: [], leave: [], idle: [] }), d = aZ((e, n, r) => { l.current.splice(0), t && (t.chains.current[n] = t.chains.current[n].filter(t => { let [n] = t; return n !== e })), null == t || t.chains.current[n].push([e, new Promise(e => { l.current.push(e) })]), null == t || t.chains.current[n].push([e, new Promise(e => { Promise.all(c.current[n].map(e => { let [t, n] = e; return n })).then(() => e()) })]), "enter" === n ? u.current = u.current.then(() => null == t ? void 0 : t.wait.current).then(() => r(n)) : r(n) }), h = aZ((e, t, n) => { Promise.all(c.current[t].splice(0).map(e => { let [t, n] = e; return n })).then(() => { var e; null == (e = l.current.shift()) || e() }).then(() => n(t)) }); return (0, Q.useMemo)(() => ({ children: r, register: o, unregister: s, onStart: d, onStop: h, wait: u, chains: c }), [o, s, r, d, h, c, u]) } function a3 () { } a1.displayName = "NestingContext"; let a5 = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"]; function a7 (e) { var t; let n = {}; for (let r of a5) n[r] = null != (t = e[r]) ? t : a3; return n } function a9 (e) { let t = (0, Q.useRef)(a7(e)); return (0, Q.useEffect)(() => { t.current = a7(e) }, [e]), t } let a6 = "div", a8 = am.RenderStrategy; function ie (e, t) { let { beforeEnter: n, afterEnter: r, beforeLeave: a, afterLeave: i, enter: s, enterFrom: o, enterTo: l, entered: u, leave: c, leaveFrom: d, leaveTo: h, ...p } = e, f = (0, Q.useRef)(null), m = aF(f, t), x = p.unmount ? ax.Unmount : ax.Hidden, { show: g, appear: v, initial: y } = aX(), [b, _] = (0, Q.useState)(g ? "visible" : "hidden"), w = a0(), { register: k, unregister: j } = w, E = (0, Q.useRef)(null); (0, Q.useEffect)(() => k(f), [k, f]), (0, Q.useEffect)(() => { if (x === ax.Hidden && f.current) { if (g && "visible" !== b) { _("visible"); return } return af(b, { hidden: () => j(f), visible: () => k(f) }) } }, [b, f, k, j, g, x]); let O = aM({ enter: aQ(s), enterFrom: aQ(o), enterTo: aQ(l), entered: aQ(u), leave: aQ(c), leaveFrom: aQ(d), leaveTo: aQ(h) }), T = a9({ beforeEnter: n, afterEnter: r, beforeLeave: a, afterLeave: i }), C = aL(); (0, Q.useEffect)(() => { if (C && "visible" === b && null === f.current) throw Error("Did you forget to passthrough the `ref` to the actual DOM node?") }, [f, b, C]); let S = y && !v, N = !C || S || E.current === g ? "idle" : g ? "enter" : "leave", I = aK(0), A = aZ(e => af(e, { enter: () => { I.addFlag(aE.Opening), T.current.beforeEnter() }, leave: () => { I.addFlag(aE.Closing), T.current.beforeLeave() }, idle: () => { } })), R = aZ(e => af(e, { enter: () => { I.removeFlag(aE.Opening), T.current.afterEnter() }, leave: () => { I.removeFlag(aE.Closing), T.current.afterLeave() }, idle: () => { } })), P = a4(() => { _("hidden"), j(f) }, w); aq({ container: f, classes: O, direction: N, onStart: aM(e => { P.onStart(f, e, A) }), onStop: aM(e => { P.onStop(f, e, R), "leave" !== e || a2(P) || (_("hidden"), j(f)) }) }), (0, Q.useEffect)(() => { S && (x === ax.Hidden ? E.current = null : E.current = g) }, [g, S, b]); let M = p, L = { ref: m }; return v && g && aA.isServer && (M = { ...M, className: ap(p.className, ...O.current.enter, ...O.current.enterFrom) }), Q.createElement(a1.Provider, { value: P }, Q.createElement(aT, { value: af(b, { visible: aE.Open, hidden: aE.Closed }) | I.flags }, ag({ ourProps: L, theirProps: M, defaultTag: a6, features: a8, visible: "visible" === b, name: "Transition.Child" }))) } function it (e, t) { let n = null !== (0, Q.useContext)(aY), r = null !== aO(); return Q.createElement(Q.Fragment, null, !n && r ? Q.createElement(ir, { ref: t, ...e }) : Q.createElement(ia, { ref: t, ...e })) } let ir = a_(function (e, t) { let { show: n, appear: r = !1, unmount: a, ...i } = e, s = (0, Q.useRef)(null), o = aF(s, t); aL(); let l = aO(); if (void 0 === n && null !== l && (n = (l & aE.Open) === aE.Open), ![!0, !1].includes(n)) throw Error("A <Transition /> is used but it is missing a `show={true | false}` prop."); let [u, c] = (0, Q.useState)(n ? "visible" : "hidden"), d = a4(() => { c("hidden") }), [h, p] = (0, Q.useState)(!0), f = (0, Q.useRef)([n]); aR(() => { !1 !== h && f.current[f.current.length - 1] !== n && (f.current.push(n), p(!1)) }, [f, n]); let m = (0, Q.useMemo)(() => ({ show: n, appear: r, initial: h }), [n, r, h]); (0, Q.useEffect)(() => { if (n) c("visible"); else if (a2(d)) { let e = s.current; if (!e) return; let t = e.getBoundingClientRect(); 0 === t.x && 0 === t.y && 0 === t.width && 0 === t.height && c("hidden") } else c("hidden") }, [n, d]); let x = { unmount: a }; return Q.createElement(a1.Provider, { value: d }, Q.createElement(aY.Provider, { value: m }, ag({ ourProps: { ...x, as: Q.Fragment, children: Q.createElement(ia, { ref: o, ...x, ...i }) }, theirProps: {}, defaultTag: Q.Fragment, features: a8, visible: "visible" === u, name: "Transition" }))) }), ia = a_(ie), ii = Object.assign(ir, { Child: a_(it), Root: ir }), is = null != (W = Q.useId) ? W : function () { let e = aL(), [t, n] = Q.useState(e ? () => aA.nextId() : null); return aR(() => { null === t && n(aA.nextId()) }, [t]), null != t ? "" + t : void 0 }; function io (e, t) { let [n, r] = (0, Q.useState)(e), a = aM(e); return aR(() => r(a.current), [a, r, ...t]), n } var il = ((l = il || {}).Space = " ", l.Enter = "Enter", l.Escape = "Escape", l.Backspace = "Backspace", l.Delete = "Delete", l.ArrowLeft = "ArrowLeft", l.ArrowUp = "ArrowUp", l.ArrowRight = "ArrowRight", l.ArrowDown = "ArrowDown", l.Home = "Home", l.End = "End", l.PageUp = "PageUp", l.PageDown = "PageDown", l.Tab = "Tab", l); function iu (e) { throw Error("Unexpected object: " + e) } var ic = ((u = ic || {})[u.First = 0] = "First", u[u.Previous = 1] = "Previous", u[u.Next = 2] = "Next", u[u.Last = 3] = "Last", u[u.Specific = 4] = "Specific", u[u.Nothing = 5] = "Nothing", u); function id (e, t) { let n = t.resolveItems(); if (n.length <= 0) return null; let r = t.resolveActiveIndex(), a = null != r ? r : -1, i = (() => { switch (e.focus) { case 0: return n.findIndex(e => !t.resolveDisabled(e)); case 1: { let e = n.slice().reverse().findIndex((e, n, r) => (-1 === a || !(r.length - n - 1 >= a)) && !t.resolveDisabled(e)); return -1 === e ? e : n.length - 1 - e } case 2: return n.findIndex((e, n) => !(n <= a) && !t.resolveDisabled(e)); case 3: { let e = n.slice().reverse().findIndex(e => !t.resolveDisabled(e)); return -1 === e ? e : n.length - 1 - e } case 4: return n.findIndex(n => t.resolveId(n) === e.id); case 5: return null; default: iu(e) } })(); return -1 === i ? r : i } function ih (e) { let t = e.parentElement, n = null; for (; t && !(t instanceof HTMLFieldSetElement);)t instanceof HTMLLegendElement && (n = t), t = t.parentElement; let r = (null == t ? void 0 : t.getAttribute("disabled")) === ""; return !(r && ip(n)) && r } function ip (e) { if (!e) return !1; let t = e.previousElementSibling; for (; null !== t;) { if (t instanceof HTMLLegendElement) return !1; t = t.previousElementSibling } return !0 } function im (e) { return aA.isServer ? null : e instanceof Node ? e.ownerDocument : null != e && e.hasOwnProperty("current") && e.current instanceof Node ? e.current.ownerDocument : document } let ix = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(e => "".concat(e, ":not([tabindex='-1'])")).join(","); var ig = ((c = ig || {})[c.First = 1] = "First", c[c.Previous = 2] = "Previous", c[c.Next = 4] = "Next", c[c.Last = 8] = "Last", c[c.WrapAround = 16] = "WrapAround", c[c.NoScroll = 32] = "NoScroll", c), iv = ((d = iv || {})[d.Error = 0] = "Error", d[d.Overflow = 1] = "Overflow", d[d.Success = 2] = "Success", d[d.Underflow = 3] = "Underflow", d), iy = ((h = iy || {})[h.Previous = -1] = "Previous", h[h.Next = 1] = "Next", h); function ib () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document.body; return null == e ? [] : Array.from(e.querySelectorAll(ix)).sort((e, t) => Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (t.tabIndex || Number.MAX_SAFE_INTEGER))) } var i_ = ((p = i_ || {})[p.Strict = 0] = "Strict", p[p.Loose = 1] = "Loose", p); function iw (e) { var t; let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; return e !== (null == (t = im(e)) ? void 0 : t.body) && af(n, { 0: () => e.matches(ix), 1 () { let t = e; for (; null !== t;) { if (t.matches(ix)) return !0; t = t.parentElement } return !1 } }) } function ik (e) { let t = im(e); aU().nextFrame(() => { t && !iw(t.activeElement, 0) && ij(e) }) } function ij (e) { null == e || e.focus({ preventScroll: !0 }) } let iE = "textarea,input"; function iO (e) { var t, n; return null != (n = null == (t = null == e ? void 0 : e.matches) ? void 0 : t.call(e, iE)) && n } function iT (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e => e; return e.slice().sort((e, n) => { let r = t(e), a = t(n); if (null === r || null === a) return 0; let i = r.compareDocumentPosition(a); return i & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : i & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0 }) } function iC (e, t) { return iS(ib(), t, { relativeTo: e }) } function iS (e, t) { let { sorted: n = !0, relativeTo: r = null, skipElements: a = [] } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = Array.isArray(e) ? e.length > 0 ? e[0].ownerDocument : document : e.ownerDocument, s = Array.isArray(e) ? n ? iT(e) : e : ib(e); a.length > 0 && s.length > 1 && (s = s.filter(e => !a.includes(e))), r = null != r ? r : i.activeElement; let o = (() => { if (5 & t) return 1; if (10 & t) return -1; throw Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), l = (() => { if (1 & t) return 0; if (2 & t) return Math.max(0, s.indexOf(r)) - 1; if (4 & t) return Math.max(0, s.indexOf(r)) + 1; if (8 & t) return s.length - 1; throw Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), u = 32 & t ? { preventScroll: !0 } : {}, c = 0, d = s.length, h; do { if (c >= d || c + d <= 0) return 0; let e = l + c; if (16 & t) e = (e + d) % d; else { if (e < 0) return 3; if (e >= d) return 1 } null == (h = s[e]) || h.focus(u), c += o } while (h !== i.activeElement); return 6 & t && iO(h) && h.select(), h.hasAttribute("tabindex") || h.setAttribute("tabindex", "0"), 2 } function iN (e) { var t; if (e.type) return e.type; let n = null != (t = e.as) ? t : "button"; if ("string" == typeof n && "button" === n.toLowerCase()) return "button" } function iI (e, t) { let [n, r] = (0, Q.useState)(() => iN(e)); return aR(() => { r(iN(e)) }, [e.type, e.as]), aR(() => { n || t.current && t.current instanceof HTMLButtonElement && !t.current.hasAttribute("type") && r("button") }, [n, t]), n } function iA (e, t, n) { let r = aM(t); (0, Q.useEffect)(() => { function t (e) { r.current(e) } return document.addEventListener(e, t, n), () => document.removeEventListener(e, t, n) }, [e, n]) } function iR (e, t) { let n = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2], r = (0, Q.useRef)(!1); function a (n, a) { if (!r.current || n.defaultPrevented) return; let i = function e (t) { return "function" == typeof t ? e(t()) : Array.isArray(t) || t instanceof Set ? t : [t] }(e), s = a(n); if (null !== s && s.getRootNode().contains(s)) { for (let e of i) { if (null === e) continue; let t = e instanceof HTMLElement ? e : e.current; if (null != t && t.contains(s) || n.composed && n.composedPath().includes(t)) return } return iw(s, i_.Loose) || -1 === s.tabIndex || n.preventDefault(), t(n, s) } } (0, Q.useEffect)(() => { requestAnimationFrame(() => { r.current = n }) }, [n]); let i = (0, Q.useRef)(null); iA("mousedown", e => { var t, n; r.current && (i.current = (null == (n = null == (t = e.composedPath) ? void 0 : t.call(e)) ? void 0 : n[0]) || e.target) }, !0), iA("click", e => { i.current && (a(e, () => i.current), i.current = null) }, !0), iA("blur", e => a(e, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0) } let iP = "div"; var iM = ((f = iM || {})[f.None = 1] = "None", f[f.Focusable = 2] = "Focusable", f[f.Hidden = 4] = "Hidden", f); let iL = a_(function (e, t) { let { features: n = 1, ...r } = e; return ag({ ourProps: { ref: t, "aria-hidden": (2 & n) == 2 || void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(4 & n) == 4 && (2 & n) != 2 && { display: "none" } } }, theirProps: r, slot: {}, defaultTag: iP, name: "Hidden" }) }); function iZ () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : []; for (let [r, a] of Object.entries(e)) iF(n, iD(t, r), a); return n } function iD (e, t) { return e ? e + "[" + t + "]" : t } function iF (e, t, n) { if (Array.isArray(n)) for (let [r, a] of n.entries()) iF(e, iD(t, r.toString()), a); else n instanceof Date ? e.push([t, n.toISOString()]) : "boolean" == typeof n ? e.push([t, n ? "1" : "0"]) : "string" == typeof n ? e.push([t, n]) : "number" == typeof n ? e.push([t, "".concat(n)]) : null == n ? e.push([t, ""]) : iZ(n, t, e) } function iz (e, t, n) { let [r, a] = (0, Q.useState)(n), i = void 0 !== e, s = (0, Q.useRef)(i), o = (0, Q.useRef)(!1), l = (0, Q.useRef)(!1); return !i || s.current || o.current ? i || !s.current || l.current || (l.current = !0, s.current = i, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")) : (o.current = !0, s.current = i, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")), [i ? e : r, aZ(e => (i || a(e), null == t ? void 0 : t(e)))] } function i$ (e) { return [e.screenX, e.screenY] } function iU () { let e = (0, Q.useRef)([-1, -1]); return { wasMoved (t) { let n = i$(t); return (e.current[0] !== n[0] || e.current[1] !== n[1]) && (e.current = n, !0) }, update (t) { e.current = i$(t) } } } var iW = ((m = iW || {})[m.Open = 0] = "Open", m[m.Closed = 1] = "Closed", m), iH = ((x = iH || {})[x.Single = 0] = "Single", x[x.Multi = 1] = "Multi", x), iV = ((g = iV || {})[g.Pointer = 0] = "Pointer", g[g.Other = 1] = "Other", g), iB = ((v = iB || {})[v.OpenListbox = 0] = "OpenListbox", v[v.CloseListbox = 1] = "CloseListbox", v[v.GoToOption = 2] = "GoToOption", v[v.Search = 3] = "Search", v[v.ClearSearch = 4] = "ClearSearch", v[v.RegisterOption = 5] = "RegisterOption", v[v.UnregisterOption = 6] = "UnregisterOption", v[v.RegisterLabel = 7] = "RegisterLabel", v); function iG (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e => e, n = null !== e.activeOptionIndex ? e.options[e.activeOptionIndex] : null, r = iT(t(e.options.slice()), e => e.dataRef.current.domRef.current), a = n ? r.indexOf(n) : null; return -1 === a && (a = null), { options: r, activeOptionIndex: a } } let iq = { 1: e => e.dataRef.current.disabled || 1 === e.listboxState ? e : { ...e, activeOptionIndex: null, listboxState: 1 }, 0 (e) { if (e.dataRef.current.disabled || 0 === e.listboxState) return e; let t = e.activeOptionIndex, { isSelected: n } = e.dataRef.current, r = e.options.findIndex(e => n(e.dataRef.current.value)); return -1 !== r && (t = r), { ...e, listboxState: 0, activeOptionIndex: t } }, 2 (e, t) { var n; if (e.dataRef.current.disabled || 1 === e.listboxState) return e; let r = iG(e), a = id(t, { resolveItems: () => r.options, resolveActiveIndex: () => r.activeOptionIndex, resolveId: e => e.id, resolveDisabled: e => e.dataRef.current.disabled }); return { ...e, ...r, searchQuery: "", activeOptionIndex: a, activationTrigger: null != (n = t.trigger) ? n : 1 } }, 3: (e, t) => { if (e.dataRef.current.disabled || 1 === e.listboxState) return e; let n = "" !== e.searchQuery ? 0 : 1, r = e.searchQuery + t.value.toLowerCase(), a = (null !== e.activeOptionIndex ? e.options.slice(e.activeOptionIndex + n).concat(e.options.slice(0, e.activeOptionIndex + n)) : e.options).find(e => { var t; return !e.dataRef.current.disabled && (null == (t = e.dataRef.current.textValue) ? void 0 : t.startsWith(r)) }), i = a ? e.options.indexOf(a) : -1; return -1 === i || i === e.activeOptionIndex ? { ...e, searchQuery: r } : { ...e, searchQuery: r, activeOptionIndex: i, activationTrigger: 1 } }, 4: e => e.dataRef.current.disabled || 1 === e.listboxState || "" === e.searchQuery ? e : { ...e, searchQuery: "" }, 5: (e, t) => { let n = { id: t.id, dataRef: t.dataRef }, r = iG(e, e => [...e, n]); return null === e.activeOptionIndex && e.dataRef.current.isSelected(t.dataRef.current.value) && (r.activeOptionIndex = r.options.indexOf(n)), { ...e, ...r } }, 6: (e, t) => { let n = iG(e, e => { let n = e.findIndex(e => e.id === t.id); return -1 !== n && e.splice(n, 1), e }); return { ...e, ...n, activationTrigger: 1 } }, 7: (e, t) => ({ ...e, labelId: t.id }) }, iK = (0, Q.createContext)(null); function iQ (e) { let t = (0, Q.useContext)(iK); if (null === t) { let t = Error("<".concat(e, " /> is missing a parent <Listbox /> component.")); throw Error.captureStackTrace && Error.captureStackTrace(t, iQ), t } return t } iK.displayName = "ListboxActionsContext"; let iY = (0, Q.createContext)(null); function iJ (e) { let t = (0, Q.useContext)(iY); if (null === t) { let t = Error("<".concat(e, " /> is missing a parent <Listbox /> component.")); throw Error.captureStackTrace && Error.captureStackTrace(t, iJ), t } return t } function iX (e, t) { return af(t.type, iq, e, t) } iY.displayName = "ListboxDataContext"; let i0 = Q.Fragment; function i1 (e, t) { let { value: n, defaultValue: r, name: a, onChange: i, by: s = (e, t) => e === t, disabled: o = !1, horizontal: l = !1, multiple: u = !1, ...c } = e, d = l ? "horizontal" : "vertical", h = aF(t), [p = u ? [] : void 0, f] = iz(n, i, r), [m, x] = (0, Q.useReducer)(iX, { dataRef: (0, Q.createRef)(), listboxState: 1, options: [], searchQuery: "", labelId: null, activeOptionIndex: null, activationTrigger: 1 }), g = (0, Q.useRef)({ static: !1, hold: !1 }), v = (0, Q.useRef)(null), y = (0, Q.useRef)(null), b = (0, Q.useRef)(null), _ = aZ("string" == typeof s ? (e, t) => { let n = s; return (null == e ? void 0 : e[n]) === (null == t ? void 0 : t[n]) } : s), w = (0, Q.useCallback)(e => af(k.mode, { 1: () => p.some(t => _(t, e)), 0: () => _(p, e) }), [p]), k = (0, Q.useMemo)(() => ({ ...m, value: p, disabled: o, mode: u ? 1 : 0, orientation: d, compare: _, isSelected: w, optionsPropsRef: g, labelRef: v, buttonRef: y, optionsRef: b }), [p, o, u, m]); aR(() => { m.dataRef.current = k }, [k]), iR([k.buttonRef, k.optionsRef], (e, t) => { var n; x({ type: 1 }), iw(t, i_.Loose) || (e.preventDefault(), null == (n = k.buttonRef.current) || n.focus()) }, 0 === k.listboxState); let j = (0, Q.useMemo)(() => ({ open: 0 === k.listboxState, disabled: o, value: p }), [k, o, p]), E = aZ(e => { let t = k.options.find(t => t.id === e); t && A(t.dataRef.current.value) }), O = aZ(() => { if (null !== k.activeOptionIndex) { let { dataRef: e, id: t } = k.options[k.activeOptionIndex]; A(e.current.value), x({ type: 2, focus: ic.Specific, id: t }) } }), T = aZ(() => x({ type: 0 })), C = aZ(() => x({ type: 1 })), S = aZ((e, t, n) => e === ic.Specific ? x({ type: 2, focus: ic.Specific, id: t, trigger: n }) : x({ type: 2, focus: e, trigger: n })), N = aZ((e, t) => (x({ type: 5, id: e, dataRef: t }), () => x({ type: 6, id: e }))), I = aZ(e => (x({ type: 7, id: e }), () => x({ type: 7, id: null }))), A = aZ(e => af(k.mode, { 0: () => null == f ? void 0 : f(e), 1 () { let t = k.value.slice(), n = t.findIndex(t => _(t, e)); return -1 === n ? t.push(e) : t.splice(n, 1), null == f ? void 0 : f(t) } })), R = aZ(e => x({ type: 3, value: e })), P = aZ(() => x({ type: 4 })), M = (0, Q.useMemo)(() => ({ onChange: A, registerOption: N, registerLabel: I, goToOption: S, closeListbox: C, openListbox: T, selectActiveOption: O, selectOption: E, search: R, clearSearch: P }), []), L = { ref: h }, Z = (0, Q.useRef)(null), D = aG(); return (0, Q.useEffect)(() => { Z.current && void 0 !== r && D.addEventListener(Z.current, "reset", () => { A(r) }) }, [Z, A]), Q.createElement(iK.Provider, { value: M }, Q.createElement(iY.Provider, { value: k }, Q.createElement(aT, { value: af(k.listboxState, { 0: aE.Open, 1: aE.Closed }) }, null != a && null != p && iZ({ [a]: p }).map((e, t) => { let [n, r] = e; return Q.createElement(iL, { features: iM.Hidden, ref: 0 === t ? e => { var t; Z.current = null != (t = null == e ? void 0 : e.closest("form")) ? t : null } : void 0, ...aw({ key: n, as: "input", type: "hidden", hidden: !0, readOnly: !0, name: n, value: r }) }) }), ag({ ourProps: L, theirProps: c, slot: j, defaultTag: i0, name: "Listbox" })))) } let i2 = "button"; function i4 (e, t) { var n; let r = is(), { id: a = "headlessui-listbox-button-".concat(r), ...i } = e, s = iJ("Listbox.Button"), o = iQ("Listbox.Button"), l = aF(s.buttonRef, t), u = aG(), c = aZ(e => { switch (e.key) { case il.Space: case il.Enter: case il.ArrowDown: e.preventDefault(), o.openListbox(), u.nextFrame(() => { s.value || o.goToOption(ic.First) }); break; case il.ArrowUp: e.preventDefault(), o.openListbox(), u.nextFrame(() => { s.value || o.goToOption(ic.Last) }) } }), d = aZ(e => { e.key === il.Space && e.preventDefault() }), h = aZ(e => { if (ih(e.currentTarget)) return e.preventDefault(); 0 === s.listboxState ? (o.closeListbox(), u.nextFrame(() => { var e; return null == (e = s.buttonRef.current) ? void 0 : e.focus({ preventScroll: !0 }) })) : (e.preventDefault(), o.openListbox()) }), p = io(() => { if (s.labelId) return [s.labelId, a].join(" ") }, [s.labelId, a]), f = (0, Q.useMemo)(() => ({ open: 0 === s.listboxState, disabled: s.disabled, value: s.value }), [s]); return ag({ ourProps: { ref: l, id: a, type: iI(e, s.buttonRef), "aria-haspopup": "listbox", "aria-controls": null == (n = s.optionsRef.current) ? void 0 : n.id, "aria-expanded": s.disabled ? void 0 : 0 === s.listboxState, "aria-labelledby": p, disabled: s.disabled, onKeyDown: c, onKeyUp: d, onClick: h }, theirProps: i, slot: f, defaultTag: i2, name: "Listbox.Button" }) } let i3 = "label"; function i5 (e, t) { let n = is(), { id: r = "headlessui-listbox-label-".concat(n), ...a } = e, i = iJ("Listbox.Label"), s = iQ("Listbox.Label"), o = aF(i.labelRef, t); return aR(() => s.registerLabel(r), [r]), ag({ ourProps: { ref: o, id: r, onClick: aZ(() => { var e; return null == (e = i.buttonRef.current) ? void 0 : e.focus({ preventScroll: !0 }) }) }, theirProps: a, slot: (0, Q.useMemo)(() => ({ open: 0 === i.listboxState, disabled: i.disabled }), [i]), defaultTag: i3, name: "Listbox.Label" }) } let i7 = "ul", i9 = am.RenderStrategy | am.Static; function i6 (e, t) { var n; let r = is(), { id: a = "headlessui-listbox-options-".concat(r), ...i } = e, s = iJ("Listbox.Options"), o = iQ("Listbox.Options"), l = aF(s.optionsRef, t), u = aG(), c = aG(), d = aO(), h = null !== d ? (d & aE.Open) === aE.Open : 0 === s.listboxState; (0, Q.useEffect)(() => { var e; let t = s.optionsRef.current; t && 0 === s.listboxState && t !== (null == (e = im(t)) ? void 0 : e.activeElement) && t.focus({ preventScroll: !0 }) }, [s.listboxState, s.optionsRef]); let p = aZ(e => { switch (c.dispose(), e.key) { case il.Space: if ("" !== s.searchQuery) return e.preventDefault(), e.stopPropagation(), o.search(e.key); case il.Enter: if (e.preventDefault(), e.stopPropagation(), null !== s.activeOptionIndex) { let { dataRef: e } = s.options[s.activeOptionIndex]; o.onChange(e.current.value) } 0 === s.mode && (o.closeListbox(), aU().nextFrame(() => { var e; return null == (e = s.buttonRef.current) ? void 0 : e.focus({ preventScroll: !0 }) })); break; case af(s.orientation, { vertical: il.ArrowDown, horizontal: il.ArrowRight }): return e.preventDefault(), e.stopPropagation(), o.goToOption(ic.Next); case af(s.orientation, { vertical: il.ArrowUp, horizontal: il.ArrowLeft }): return e.preventDefault(), e.stopPropagation(), o.goToOption(ic.Previous); case il.Home: case il.PageUp: return e.preventDefault(), e.stopPropagation(), o.goToOption(ic.First); case il.End: case il.PageDown: return e.preventDefault(), e.stopPropagation(), o.goToOption(ic.Last); case il.Escape: return e.preventDefault(), e.stopPropagation(), o.closeListbox(), u.nextFrame(() => { var e; return null == (e = s.buttonRef.current) ? void 0 : e.focus({ preventScroll: !0 }) }); case il.Tab: e.preventDefault(), e.stopPropagation(); break; default: 1 === e.key.length && (o.search(e.key), c.setTimeout(() => o.clearSearch(), 350)) } }), f = io(() => { var e, t, n; return null != (n = null == (e = s.labelRef.current) ? void 0 : e.id) ? n : null == (t = s.buttonRef.current) ? void 0 : t.id }, [s.labelRef.current, s.buttonRef.current]), m = (0, Q.useMemo)(() => ({ open: 0 === s.listboxState }), [s]); return ag({ ourProps: { "aria-activedescendant": null === s.activeOptionIndex || null == (n = s.options[s.activeOptionIndex]) ? void 0 : n.id, "aria-multiselectable": 1 === s.mode || void 0, "aria-labelledby": f, "aria-orientation": s.orientation, id: a, onKeyDown: p, role: "listbox", tabIndex: 0, ref: l }, theirProps: i, slot: m, defaultTag: i7, features: i9, visible: h, name: "Listbox.Options" }) } let i8 = "li"; function se (e, t) { let n = is(), { id: r = "headlessui-listbox-option-".concat(n), disabled: a = !1, value: i, ...s } = e, o = iJ("Listbox.Option"), l = iQ("Listbox.Option"), u = null !== o.activeOptionIndex && o.options[o.activeOptionIndex].id === r, c = o.isSelected(i), d = (0, Q.useRef)(null), h = aM({ disabled: a, value: i, domRef: d, get textValue () { var p, f; return null == (f = null == (p = d.current) ? void 0 : p.textContent) ? void 0 : f.toLowerCase() } }), m = aF(t, d); aR(() => { if (0 !== o.listboxState || !u || 0 === o.activationTrigger) return; let e = aU(); return e.requestAnimationFrame(() => { var e, t; null == (t = null == (e = d.current) ? void 0 : e.scrollIntoView) || t.call(e, { block: "nearest" }) }), e.dispose }, [d, u, o.listboxState, o.activationTrigger, o.activeOptionIndex]), aR(() => l.registerOption(r, h), [h, r]); let x = aZ(e => { if (a) return e.preventDefault(); l.onChange(i), 0 === o.mode && (l.closeListbox(), aU().nextFrame(() => { var e; return null == (e = o.buttonRef.current) ? void 0 : e.focus({ preventScroll: !0 }) })) }), g = aZ(() => { if (a) return l.goToOption(ic.Nothing); l.goToOption(ic.Specific, r) }), v = iU(), y = aZ(e => v.update(e)), b = aZ(e => { v.wasMoved(e) && (a || u || l.goToOption(ic.Specific, r, 0)) }), _ = aZ(e => { v.wasMoved(e) && (a || u && l.goToOption(ic.Nothing)) }), w = (0, Q.useMemo)(() => ({ active: u, selected: c, disabled: a }), [u, c, a]); return ag({ ourProps: { id: r, ref: m, role: "option", tabIndex: !0 === a ? void 0 : -1, "aria-disabled": !0 === a || void 0, "aria-selected": c, disabled: void 0, onClick: x, onFocus: g, onPointerEnter: y, onMouseEnter: y, onPointerMove: b, onMouseMove: b, onPointerLeave: _, onMouseLeave: _ }, theirProps: s, slot: w, defaultTag: i8, name: "Listbox.Option" }) } let st = Object.assign(a_(i1), { Button: a_(i4), Label: a_(i5), Options: a_(i6), Option: a_(se) }); var sn = n(967), sr = n(7631), sa = n(8225), si = n.n(sa); function ss () { return (ss = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }).apply(this, arguments) } function so (e, t) { if (null == e) return {}; var n, r, a = {}, i = Object.keys(e); for (r = 0; r < i.length; r++)n = i[r], t.indexOf(n) >= 0 || (a[n] = e[n]); return a } var sl = ["keyOverride"], su = ["crossOrigin"], sc = { templateTitle: "", noindex: !1, nofollow: !1, defaultOpenGraphImageWidth: 0, defaultOpenGraphImageHeight: 0, defaultOpenGraphVideoWidth: 0, defaultOpenGraphVideoHeight: 0 }, sd = function (e, t, n) { void 0 === t && (t = []); var r = void 0 === n ? {} : n, a = r.defaultWidth, i = r.defaultHeight; return t.reduce(function (t, n, r) { return t.push(Q.createElement("meta", { key: "og:" + e + ":0" + r, property: "og:" + e, content: n.url })), n.alt && t.push(Q.createElement("meta", { key: "og:" + e + ":alt0" + r, property: "og:" + e + ":alt", content: n.alt })), n.secureUrl && t.push(Q.createElement("meta", { key: "og:" + e + ":secure_url0" + r, property: "og:" + e + ":secure_url", content: n.secureUrl.toString() })), n.type && t.push(Q.createElement("meta", { key: "og:" + e + ":type0" + r, property: "og:" + e + ":type", content: n.type.toString() })), n.width ? t.push(Q.createElement("meta", { key: "og:" + e + ":width0" + r, property: "og:" + e + ":width", content: n.width.toString() })) : a && t.push(Q.createElement("meta", { key: "og:" + e + ":width0" + r, property: "og:" + e + ":width", content: a.toString() })), n.height ? t.push(Q.createElement("meta", { key: "og:" + e + ":height" + r, property: "og:" + e + ":height", content: n.height.toString() })) : i && t.push(Q.createElement("meta", { key: "og:" + e + ":height" + r, property: "og:" + e + ":height", content: i.toString() })), t }, []) }, sh = function (e) { var t, n, r, a, i, s = []; e.titleTemplate && (sc.templateTitle = e.titleTemplate); var o = ""; e.title ? (o = e.title, sc.templateTitle && (o = sc.templateTitle.replace(/%s/g, function () { return o }))) : e.defaultTitle && (o = e.defaultTitle), o && s.push(Q.createElement("title", { key: "title" }, o)); var l = void 0 === e.noindex ? sc.noindex || e.dangerouslySetAllPagesToNoIndex : e.noindex, u = void 0 === e.nofollow ? sc.nofollow || e.dangerouslySetAllPagesToNoFollow : e.nofollow, c = ""; if (e.robotsProps) { var d = e.robotsProps, h = d.nosnippet, p = d.maxSnippet, f = d.maxImagePreview, m = d.maxVideoPreview, x = d.noarchive, g = d.noimageindex, v = d.notranslate, y = d.unavailableAfter; c = (h ? ",nosnippet" : "") + (p ? ",max-snippet:" + p : "") + (f ? ",max-image-preview:" + f : "") + (x ? ",noarchive" : "") + (y ? ",unavailable_after:" + y : "") + (g ? ",noimageindex" : "") + (m ? ",max-video-preview:" + m : "") + (v ? ",notranslate" : "") } if (l || u ? (e.dangerouslySetAllPagesToNoIndex && (sc.noindex = !0), e.dangerouslySetAllPagesToNoFollow && (sc.nofollow = !0), s.push(Q.createElement("meta", { key: "robots", name: "robots", content: (l ? "noindex" : "index") + "," + (u ? "nofollow" : "follow") + c }))) : s.push(Q.createElement("meta", { key: "robots", name: "robots", content: "index,follow" + c })), e.description && s.push(Q.createElement("meta", { key: "description", name: "description", content: e.description })), e.themeColor && s.push(Q.createElement("meta", { key: "theme-color", name: "theme-color", content: e.themeColor })), e.mobileAlternate && s.push(Q.createElement("link", { rel: "alternate", key: "mobileAlternate", media: e.mobileAlternate.media, href: e.mobileAlternate.href })), e.languageAlternates && e.languageAlternates.length > 0 && e.languageAlternates.forEach(function (e) { s.push(Q.createElement("link", { rel: "alternate", key: "languageAlternate-" + e.hrefLang, hrefLang: e.hrefLang, href: e.href })) }), e.twitter && (e.twitter.cardType && s.push(Q.createElement("meta", { key: "twitter:card", name: "twitter:card", content: e.twitter.cardType })), e.twitter.site && s.push(Q.createElement("meta", { key: "twitter:site", name: "twitter:site", content: e.twitter.site })), e.twitter.handle && s.push(Q.createElement("meta", { key: "twitter:creator", name: "twitter:creator", content: e.twitter.handle }))), e.facebook && e.facebook.appId && s.push(Q.createElement("meta", { key: "fb:app_id", property: "fb:app_id", content: e.facebook.appId })), (null != (t = e.openGraph) && t.title || o) && s.push(Q.createElement("meta", { key: "og:title", property: "og:title", content: (null == (a = e.openGraph) ? void 0 : a.title) || o })), (null != (n = e.openGraph) && n.description || e.description) && s.push(Q.createElement("meta", { key: "og:description", property: "og:description", content: (null == (i = e.openGraph) ? void 0 : i.description) || e.description })), e.openGraph) { if ((e.openGraph.url || e.canonical) && s.push(Q.createElement("meta", { key: "og:url", property: "og:url", content: e.openGraph.url || e.canonical })), e.openGraph.type) { var b = e.openGraph.type.toLowerCase(); s.push(Q.createElement("meta", { key: "og:type", property: "og:type", content: b })), "profile" === b && e.openGraph.profile ? (e.openGraph.profile.firstName && s.push(Q.createElement("meta", { key: "profile:first_name", property: "profile:first_name", content: e.openGraph.profile.firstName })), e.openGraph.profile.lastName && s.push(Q.createElement("meta", { key: "profile:last_name", property: "profile:last_name", content: e.openGraph.profile.lastName })), e.openGraph.profile.username && s.push(Q.createElement("meta", { key: "profile:username", property: "profile:username", content: e.openGraph.profile.username })), e.openGraph.profile.gender && s.push(Q.createElement("meta", { key: "profile:gender", property: "profile:gender", content: e.openGraph.profile.gender }))) : "book" === b && e.openGraph.book ? (e.openGraph.book.authors && e.openGraph.book.authors.length && e.openGraph.book.authors.forEach(function (e, t) { s.push(Q.createElement("meta", { key: "book:author:0" + t, property: "book:author", content: e })) }), e.openGraph.book.isbn && s.push(Q.createElement("meta", { key: "book:isbn", property: "book:isbn", content: e.openGraph.book.isbn })), e.openGraph.book.releaseDate && s.push(Q.createElement("meta", { key: "book:release_date", property: "book:release_date", content: e.openGraph.book.releaseDate })), e.openGraph.book.tags && e.openGraph.book.tags.length && e.openGraph.book.tags.forEach(function (e, t) { s.push(Q.createElement("meta", { key: "book:tag:0" + t, property: "book:tag", content: e })) })) : "article" === b && e.openGraph.article ? (e.openGraph.article.publishedTime && s.push(Q.createElement("meta", { key: "article:published_time", property: "article:published_time", content: e.openGraph.article.publishedTime })), e.openGraph.article.modifiedTime && s.push(Q.createElement("meta", { key: "article:modified_time", property: "article:modified_time", content: e.openGraph.article.modifiedTime })), e.openGraph.article.expirationTime && s.push(Q.createElement("meta", { key: "article:expiration_time", property: "article:expiration_time", content: e.openGraph.article.expirationTime })), e.openGraph.article.authors && e.openGraph.article.authors.length && e.openGraph.article.authors.forEach(function (e, t) { s.push(Q.createElement("meta", { key: "article:author:0" + t, property: "article:author", content: e })) }), e.openGraph.article.section && s.push(Q.createElement("meta", { key: "article:section", property: "article:section", content: e.openGraph.article.section })), e.openGraph.article.tags && e.openGraph.article.tags.length && e.openGraph.article.tags.forEach(function (e, t) { s.push(Q.createElement("meta", { key: "article:tag:0" + t, property: "article:tag", content: e })) })) : ("video.movie" === b || "video.episode" === b || "video.tv_show" === b || "video.other" === b) && e.openGraph.video && (e.openGraph.video.actors && e.openGraph.video.actors.length && e.openGraph.video.actors.forEach(function (e, t) { e.profile && s.push(Q.createElement("meta", { key: "video:actor:0" + t, property: "video:actor", content: e.profile })), e.role && s.push(Q.createElement("meta", { key: "video:actor:role:0" + t, property: "video:actor:role", content: e.role })) }), e.openGraph.video.directors && e.openGraph.video.directors.length && e.openGraph.video.directors.forEach(function (e, t) { s.push(Q.createElement("meta", { key: "video:director:0" + t, property: "video:director", content: e })) }), e.openGraph.video.writers && e.openGraph.video.writers.length && e.openGraph.video.writers.forEach(function (e, t) { s.push(Q.createElement("meta", { key: "video:writer:0" + t, property: "video:writer", content: e })) }), e.openGraph.video.duration && s.push(Q.createElement("meta", { key: "video:duration", property: "video:duration", content: e.openGraph.video.duration.toString() })), e.openGraph.video.releaseDate && s.push(Q.createElement("meta", { key: "video:release_date", property: "video:release_date", content: e.openGraph.video.releaseDate })), e.openGraph.video.tags && e.openGraph.video.tags.length && e.openGraph.video.tags.forEach(function (e, t) { s.push(Q.createElement("meta", { key: "video:tag:0" + t, property: "video:tag", content: e })) }), e.openGraph.video.series && s.push(Q.createElement("meta", { key: "video:series", property: "video:series", content: e.openGraph.video.series }))) } e.defaultOpenGraphImageWidth && (sc.defaultOpenGraphImageWidth = e.defaultOpenGraphImageWidth), e.defaultOpenGraphImageHeight && (sc.defaultOpenGraphImageHeight = e.defaultOpenGraphImageHeight), e.openGraph.images && e.openGraph.images.length && s.push.apply(s, sd("image", e.openGraph.images, { defaultWidth: sc.defaultOpenGraphImageWidth, defaultHeight: sc.defaultOpenGraphImageHeight })), e.defaultOpenGraphVideoWidth && (sc.defaultOpenGraphVideoWidth = e.defaultOpenGraphVideoWidth), e.defaultOpenGraphVideoHeight && (sc.defaultOpenGraphVideoHeight = e.defaultOpenGraphVideoHeight), e.openGraph.videos && e.openGraph.videos.length && s.push.apply(s, sd("video", e.openGraph.videos, { defaultWidth: sc.defaultOpenGraphVideoWidth, defaultHeight: sc.defaultOpenGraphVideoHeight })), e.openGraph.audio && s.push.apply(s, sd("audio", e.openGraph.audio)), e.openGraph.locale && s.push(Q.createElement("meta", { key: "og:locale", property: "og:locale", content: e.openGraph.locale })), (e.openGraph.siteName || e.openGraph.site_name) && s.push(Q.createElement("meta", { key: "og:site_name", property: "og:site_name", content: e.openGraph.siteName || e.openGraph.site_name })) } return e.canonical && s.push(Q.createElement("link", { rel: "canonical", href: e.canonical, key: "canonical" })), e.additionalMetaTags && e.additionalMetaTags.length > 0 && e.additionalMetaTags.forEach(function (e) { var t, n, r = e.keyOverride, a = so(e, sl); s.push(Q.createElement("meta", ss({ key: "meta:" + (null != (t = null != (n = null != r ? r : a.name) ? n : a.property) ? t : a.httpEquiv) }, a))) }), null != (r = e.additionalLinkTags) && r.length && e.additionalLinkTags.forEach(function (e) { var t, n = e.crossOrigin, r = so(e, su), a = "anonymous" === n || "use-credentials" === n || "" === n ? n : void 0; s.push(Q.createElement("link", ss({ key: "link" + (null != (t = r.keyOverride) ? t : r.href) + r.rel }, r, { crossOrigin: a }))) }), s }, sp = function (e) { return Q.createElement(si(), null, sh(e)) }, sf = function (e) { var t = e.title, n = e.themeColor, r = e.noindex, a = e.nofollow, i = e.robotsProps, s = e.description, o = e.canonical, l = e.openGraph, u = e.facebook, c = e.twitter, d = e.additionalMetaTags, h = e.titleTemplate, p = e.defaultTitle, f = e.mobileAlternate, m = e.languageAlternates, x = e.additionalLinkTags; return Q.createElement(Q.Fragment, null, Q.createElement(sp, { title: t, themeColor: n, noindex: r, nofollow: a, robotsProps: i, description: s, canonical: o, facebook: u, openGraph: l, additionalMetaTags: d, twitter: c, titleTemplate: h, defaultTitle: p, mobileAlternate: f, languageAlternates: m, additionalLinkTags: x })) }; function sm (e) { let { container: t, accept: n, walk: r, enabled: a = !0 } = e, i = (0, Q.useRef)(n), s = (0, Q.useRef)(r); (0, Q.useEffect)(() => { i.current = n, s.current = r }, [n, r]), aR(() => { if (!t || !a) return; let e = im(t); if (!e) return; let n = i.current, r = s.current, o = Object.assign(e => n(e), { acceptNode: n }), l = e.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, o, !1); for (; l.nextNode();)r(l.currentNode) }, [t, a, i, s]) } function sx () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return (0, Q.useMemo)(() => im(...t), [...t]) } RegExp("[" + Object.keys(Object.freeze({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&apos;" })).join("") + "]", "g"); var sg = ((y = sg || {})[y.Open = 0] = "Open", y[y.Closed = 1] = "Closed", y), sv = ((b = sv || {})[b.Pointer = 0] = "Pointer", b[b.Other = 1] = "Other", b), sy = ((_ = sy || {})[_.OpenMenu = 0] = "OpenMenu", _[_.CloseMenu = 1] = "CloseMenu", _[_.GoToItem = 2] = "GoToItem", _[_.Search = 3] = "Search", _[_.ClearSearch = 4] = "ClearSearch", _[_.RegisterItem = 5] = "RegisterItem", _[_.UnregisterItem = 6] = "UnregisterItem", _); function sb (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e => e, n = null !== e.activeItemIndex ? e.items[e.activeItemIndex] : null, r = iT(t(e.items.slice()), e => e.dataRef.current.domRef.current), a = n ? r.indexOf(n) : null; return -1 === a && (a = null), { items: r, activeItemIndex: a } } let s_ = { 1: e => 1 === e.menuState ? e : { ...e, activeItemIndex: null, menuState: 1 }, 0: e => 0 === e.menuState ? e : { ...e, menuState: 0 }, 2: (e, t) => { var n; let r = sb(e), a = id(t, { resolveItems: () => r.items, resolveActiveIndex: () => r.activeItemIndex, resolveId: e => e.id, resolveDisabled: e => e.dataRef.current.disabled }); return { ...e, ...r, searchQuery: "", activeItemIndex: a, activationTrigger: null != (n = t.trigger) ? n : 1 } }, 3: (e, t) => { let n = "" !== e.searchQuery ? 0 : 1, r = e.searchQuery + t.value.toLowerCase(), a = (null !== e.activeItemIndex ? e.items.slice(e.activeItemIndex + n).concat(e.items.slice(0, e.activeItemIndex + n)) : e.items).find(e => { var t; return (null == (t = e.dataRef.current.textValue) ? void 0 : t.startsWith(r)) && !e.dataRef.current.disabled }), i = a ? e.items.indexOf(a) : -1; return -1 === i || i === e.activeItemIndex ? { ...e, searchQuery: r } : { ...e, searchQuery: r, activeItemIndex: i, activationTrigger: 1 } }, 4: e => "" === e.searchQuery ? e : { ...e, searchQuery: "", searchActiveItemIndex: null }, 5: (e, t) => { let n = sb(e, e => [...e, { id: t.id, dataRef: t.dataRef }]); return { ...e, ...n } }, 6: (e, t) => { let n = sb(e, e => { let n = e.findIndex(e => e.id === t.id); return -1 !== n && e.splice(n, 1), e }); return { ...e, ...n, activationTrigger: 1 } } }, sw = (0, Q.createContext)(null); function sk (e) { let t = (0, Q.useContext)(sw); if (null === t) { let t = Error("<".concat(e, " /> is missing a parent <Menu /> component.")); throw Error.captureStackTrace && Error.captureStackTrace(t, sk), t } return t } function sj (e, t) { return af(t.type, s_, e, t) } sw.displayName = "MenuContext"; let sE = Q.Fragment; function sO (e, t) { let n = (0, Q.useReducer)(sj, { menuState: 1, buttonRef: (0, Q.createRef)(), itemsRef: (0, Q.createRef)(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: r, itemsRef: a, buttonRef: i }, s] = n, o = aF(t); iR([i, a], (e, t) => { var n; s({ type: 1 }), iw(t, i_.Loose) || (e.preventDefault(), null == (n = i.current) || n.focus()) }, 0 === r); let l = aZ(() => { s({ type: 1 }) }), u = (0, Q.useMemo)(() => ({ open: 0 === r, close: l }), [r, l]), c = e, d = { ref: o }; return Q.createElement(sw.Provider, { value: n }, Q.createElement(aT, { value: af(r, { 0: aE.Open, 1: aE.Closed }) }, ag({ ourProps: d, theirProps: c, slot: u, defaultTag: sE, name: "Menu" }))) } let sT = "button"; function sC (e, t) { var n; let r = is(), { id: a = "headlessui-menu-button-".concat(r), ...i } = e, [s, o] = sk("Menu.Button"), l = aF(s.buttonRef, t), u = aG(), c = aZ(e => { switch (e.key) { case il.Space: case il.Enter: case il.ArrowDown: e.preventDefault(), e.stopPropagation(), o({ type: 0 }), u.nextFrame(() => o({ type: 2, focus: ic.First })); break; case il.ArrowUp: e.preventDefault(), e.stopPropagation(), o({ type: 0 }), u.nextFrame(() => o({ type: 2, focus: ic.Last })) } }), d = aZ(e => { e.key === il.Space && e.preventDefault() }), h = aZ(t => { if (ih(t.currentTarget)) return t.preventDefault(); e.disabled || (0 === s.menuState ? (o({ type: 1 }), u.nextFrame(() => { var e; return null == (e = s.buttonRef.current) ? void 0 : e.focus({ preventScroll: !0 }) })) : (t.preventDefault(), o({ type: 0 }))) }), p = (0, Q.useMemo)(() => ({ open: 0 === s.menuState }), [s]); return ag({ ourProps: { ref: l, id: a, type: iI(e, s.buttonRef), "aria-haspopup": "menu", "aria-controls": null == (n = s.itemsRef.current) ? void 0 : n.id, "aria-expanded": e.disabled ? void 0 : 0 === s.menuState, onKeyDown: c, onKeyUp: d, onClick: h }, theirProps: i, slot: p, defaultTag: sT, name: "Menu.Button" }) } let sS = "div", sN = am.RenderStrategy | am.Static; function sI (e, t) { var n, r; let a = is(), { id: i = "headlessui-menu-items-".concat(a), ...s } = e, [o, l] = sk("Menu.Items"), u = aF(o.itemsRef, t), c = sx(o.itemsRef), d = aG(), h = aO(), p = null !== h ? (h & aE.Open) === aE.Open : 0 === o.menuState; (0, Q.useEffect)(() => { let e = o.itemsRef.current; e && 0 === o.menuState && e !== (null == c ? void 0 : c.activeElement) && e.focus({ preventScroll: !0 }) }, [o.menuState, o.itemsRef, c]), sm({ container: o.itemsRef.current, enabled: 0 === o.menuState, accept: e => "menuitem" === e.getAttribute("role") ? NodeFilter.FILTER_REJECT : e.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT, walk (e) { e.setAttribute("role", "none") } }); let f = aZ(e => { var t, n; switch (d.dispose(), e.key) { case il.Space: if ("" !== o.searchQuery) return e.preventDefault(), e.stopPropagation(), l({ type: 3, value: e.key }); case il.Enter: if (e.preventDefault(), e.stopPropagation(), l({ type: 1 }), null !== o.activeItemIndex) { let { dataRef: e } = o.items[o.activeItemIndex]; null == (n = null == (t = e.current) ? void 0 : t.domRef.current) || n.click() } ik(o.buttonRef.current); break; case il.ArrowDown: return e.preventDefault(), e.stopPropagation(), l({ type: 2, focus: ic.Next }); case il.ArrowUp: return e.preventDefault(), e.stopPropagation(), l({ type: 2, focus: ic.Previous }); case il.Home: case il.PageUp: return e.preventDefault(), e.stopPropagation(), l({ type: 2, focus: ic.First }); case il.End: case il.PageDown: return e.preventDefault(), e.stopPropagation(), l({ type: 2, focus: ic.Last }); case il.Escape: e.preventDefault(), e.stopPropagation(), l({ type: 1 }), aU().nextFrame(() => { var e; return null == (e = o.buttonRef.current) ? void 0 : e.focus({ preventScroll: !0 }) }); break; case il.Tab: e.preventDefault(), e.stopPropagation(), l({ type: 1 }), aU().nextFrame(() => { iC(o.buttonRef.current, e.shiftKey ? ig.Previous : ig.Next) }); break; default: 1 === e.key.length && (l({ type: 3, value: e.key }), d.setTimeout(() => l({ type: 4 }), 350)) } }), m = aZ(e => { e.key === il.Space && e.preventDefault() }), x = (0, Q.useMemo)(() => ({ open: 0 === o.menuState }), [o]); return ag({ ourProps: { "aria-activedescendant": null === o.activeItemIndex || null == (n = o.items[o.activeItemIndex]) ? void 0 : n.id, "aria-labelledby": null == (r = o.buttonRef.current) ? void 0 : r.id, id: i, onKeyDown: f, onKeyUp: m, role: "menu", tabIndex: 0, ref: u }, theirProps: s, slot: x, defaultTag: sS, features: sN, visible: p, name: "Menu.Items" }) } let sA = Q.Fragment; function sR (e, t) { let n = is(), { id: r = "headlessui-menu-item-".concat(n), disabled: a = !1, ...i } = e, [s, o] = sk("Menu.Item"), l = null !== s.activeItemIndex && s.items[s.activeItemIndex].id === r, u = (0, Q.useRef)(null), c = aF(t, u); aR(() => { if (0 !== s.menuState || !l || 0 === s.activationTrigger) return; let e = aU(); return e.requestAnimationFrame(() => { var e, t; null == (t = null == (e = u.current) ? void 0 : e.scrollIntoView) || t.call(e, { block: "nearest" }) }), e.dispose }, [u, l, s.menuState, s.activationTrigger, s.activeItemIndex]); let d = (0, Q.useRef)({ disabled: a, domRef: u }); aR(() => { d.current.disabled = a }, [d, a]), aR(() => { var e, t; d.current.textValue = null == (t = null == (e = u.current) ? void 0 : e.textContent) ? void 0 : t.toLowerCase() }, [d, u]), aR(() => (o({ type: 5, id: r, dataRef: d }), () => o({ type: 6, id: r })), [d, r]); let h = aZ(() => { o({ type: 1 }) }), p = aZ(e => { if (a) return e.preventDefault(); o({ type: 1 }), ik(s.buttonRef.current) }), f = aZ(() => { if (a) return o({ type: 2, focus: ic.Nothing }); o({ type: 2, focus: ic.Specific, id: r }) }), m = iU(), x = aZ(e => m.update(e)), g = aZ(e => { m.wasMoved(e) && (a || l || o({ type: 2, focus: ic.Specific, id: r, trigger: 0 })) }), v = aZ(e => { m.wasMoved(e) && (a || l && o({ type: 2, focus: ic.Nothing })) }), y = (0, Q.useMemo)(() => ({ active: l, disabled: a, close: h }), [l, a, h]); return ag({ ourProps: { id: r, ref: c, role: "menuitem", tabIndex: !0 === a ? void 0 : -1, "aria-disabled": !0 === a || void 0, disabled: void 0, onClick: p, onFocus: f, onPointerEnter: x, onMouseEnter: x, onPointerMove: g, onMouseMove: g, onPointerLeave: v, onMouseLeave: v }, theirProps: i, slot: y, defaultTag: sA, name: "Menu.Item" }) } let sP = Object.assign(a_(sO), { Button: a_(sC), Items: a_(sI), Item: a_(sR) }), sM = e => "object" == typeof e && null != e && 1 === e.nodeType, sL = (e, t) => (!t || "hidden" !== e) && "visible" !== e && "clip" !== e, sZ = (e, t) => { if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) { let n = getComputedStyle(e, null); return sL(n.overflowY, t) || sL(n.overflowX, t) || (e => { let t = (e => { if (!e.ownerDocument || !e.ownerDocument.defaultView) return null; try { return e.ownerDocument.defaultView.frameElement } catch (e) { return null } })(e); return !!t && (t.clientHeight < e.scrollHeight || t.clientWidth < e.scrollWidth) })(e) } return !1 }, sD = (e, t, n, r, a, i, s, o) => i < e && s > t || i > e && s < t ? 0 : i <= e && o <= n || s >= t && o >= n ? i - e - r : s > t && o < n || i < e && o > n ? s - t + a : 0, sF = e => { let t = e.parentElement; return null == t ? e.getRootNode().host || null : t }; var sz = (e, t) => { var n, r, a, i, s, o; if ("undefined" == typeof document) return []; let { scrollMode: l, block: u, inline: c, boundary: d, skipOverflowHiddenElements: h } = t, p = "function" == typeof d ? d : e => e !== d; if (!sM(e)) throw TypeError("Invalid target"); let f = document.scrollingElement || document.documentElement, m = [], x = e; for (; sM(x) && p(x);) { if ((x = sF(x)) === f) { m.push(x); break } null != x && x === document.body && sZ(x) && !sZ(document.documentElement) || null != x && sZ(x, h) && m.push(x) } let g = null != (r = null == (n = window.visualViewport) ? void 0 : n.width) ? r : innerWidth, v = null != (i = null == (a = window.visualViewport) ? void 0 : a.height) ? i : innerHeight, y = null != (s = window.scrollX) ? s : pageXOffset, b = null != (o = window.scrollY) ? o : pageYOffset, { height: _, width: w, top: k, right: j, bottom: E, left: O } = e.getBoundingClientRect(), T = "start" === u || "nearest" === u ? k : "end" === u ? E : k + _ / 2, C = "center" === c ? O + w / 2 : "end" === c ? j : O, S = []; for (let e = 0; e < m.length; e++) { let t = m[e], { height: n, width: r, top: a, right: i, bottom: s, left: o } = t.getBoundingClientRect(); if ("if-needed" === l && k >= 0 && O >= 0 && E <= v && j <= g && k >= a && E <= s && O >= o && j <= i) break; let d = getComputedStyle(t), h = parseInt(d.borderLeftWidth, 10), p = parseInt(d.borderTopWidth, 10), x = parseInt(d.borderRightWidth, 10), N = parseInt(d.borderBottomWidth, 10), I = 0, A = 0, R = "offsetWidth" in t ? t.offsetWidth - t.clientWidth - h - x : 0, P = "offsetHeight" in t ? t.offsetHeight - t.clientHeight - p - N : 0, M = "offsetWidth" in t ? 0 === t.offsetWidth ? 0 : r / t.offsetWidth : 0, L = "offsetHeight" in t ? 0 === t.offsetHeight ? 0 : n / t.offsetHeight : 0; if (f === t) I = "start" === u ? T : "end" === u ? T - v : "nearest" === u ? sD(b, b + v, v, p, N, b + T, b + T + _, _) : T - v / 2, A = "start" === c ? C : "center" === c ? C - g / 2 : "end" === c ? C - g : sD(y, y + g, g, h, x, y + C, y + C + w, w), I = Math.max(0, I + b), A = Math.max(0, A + y); else { I = "start" === u ? T - a - p : "end" === u ? T - s + N + P : "nearest" === u ? sD(a, s, n, p, N + P, T, T + _, _) : T - (a + n / 2) + P / 2, A = "start" === c ? C - o - h : "center" === c ? C - (o + r / 2) + R / 2 : "end" === c ? C - i + x + R : sD(o, i, r, h, x + R, C, C + w, w); let { scrollLeft: e, scrollTop: l } = t; I = Math.max(0, Math.min(l + I / L, t.scrollHeight - n / L + P)), A = Math.max(0, Math.min(e + A / M, t.scrollWidth - r / M + R)), T += l - I, C += e - A } S.push({ el: t, top: I, left: A }) } return S }; let s$ = e => { let t; return !1 === e ? { block: "end", inline: "nearest" } : (t = e) === Object(t) && 0 !== Object.keys(t).length ? e : { block: "start", inline: "nearest" } }; function sU (e, t) { let n, r = e.isConnected || e.ownerDocument.documentElement.contains(e); if ("object" == typeof (n = t) && "function" == typeof n.behavior) return t.behavior(r ? sz(e, t) : []); if (!r) return; let a = s$(t), i = sz(e, a), s = "scrollBehavior" in document.body.style; i.forEach(e => { let { el: t, top: n, left: r } = e; t.scroll && s ? t.scroll({ top: n, left: r, behavior: a.behavior }) : (t.scrollTop = n, t.scrollLeft = r) }) } function sW (e) { let { onFocus: t } = e, [n, r] = (0, Q.useState)(!0); return n ? Q.createElement(iL, { as: "button", type: "button", features: iM.Focusable, onFocus: e => { e.preventDefault(); let n, a = 50; function i () { if (a-- <= 0) { n && cancelAnimationFrame(n); return } if (t()) { r(!1), cancelAnimationFrame(n); return } n = requestAnimationFrame(i) } n = requestAnimationFrame(i) } }) : null } let sH = Q.createContext(null); function sV () { return { groups: new Map, get (e, t) { var n; let r = this.groups.get(e); r || (r = new Map, this.groups.set(e, r)); let a = null != (n = r.get(t)) ? n : 0; function i () { let e = r.get(t); e > 1 ? r.set(t, e - 1) : r.delete(t) } return r.set(t, a + 1), [Array.from(r.keys()).indexOf(t), i] } } } function sB (e) { let { children: t } = e, n = Q.useRef(sV()); return Q.createElement(sH.Provider, { value: n }, t) } function sG (e) { let t = Q.useContext(sH); if (!t) throw Error("You must wrap your component in a <StableCollection>"); let n = sq(), [r, a] = t.current.get(e, n); return Q.useEffect(() => a, []), r } function sq () { var e, t, n; let r = null != (n = null == (t = null == (e = Q.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) ? void 0 : e.ReactCurrentOwner) ? void 0 : t.current) ? n : null; if (!r) return Symbol(); let a = [], i = r; for (; i;)a.push(i.index), i = i.return; return "$." + a.join(".") } var sK = ((w = sK || {})[w.Forwards = 0] = "Forwards", w[w.Backwards = 1] = "Backwards", w), sQ = ((k = sQ || {})[k.Less = -1] = "Less", k[k.Equal = 0] = "Equal", k[k.Greater = 1] = "Greater", k), sY = ((j = sY || {})[j.SetSelectedIndex = 0] = "SetSelectedIndex", j[j.RegisterTab = 1] = "RegisterTab", j[j.UnregisterTab = 2] = "UnregisterTab", j[j.RegisterPanel = 3] = "RegisterPanel", j[j.UnregisterPanel = 4] = "UnregisterPanel", j); let sJ = { 0 (e, t) { var n; let r = iT(e.tabs, e => e.current), a = iT(e.panels, e => e.current), i = r.filter(e => { var t; return !(null != (t = e.current) && t.hasAttribute("disabled")) }), s = { ...e, tabs: r, panels: a }; if (t.index < 0 || t.index > r.length - 1) { let n = af(Math.sign(t.index - e.selectedIndex), { [-1]: () => 1, 0: () => af(Math.sign(t.index), { [-1]: () => 0, 0: () => 0, 1: () => 1 }), 1: () => 0 }); return 0 === i.length ? s : { ...s, selectedIndex: af(n, { 0: () => r.indexOf(i[0]), 1: () => r.indexOf(i[i.length - 1]) }) } } let o = r.slice(0, t.index), l = [...r.slice(t.index), ...o].find(e => i.includes(e)); if (!l) return s; let u = null != (n = r.indexOf(l)) ? n : e.selectedIndex; return -1 === u && (u = e.selectedIndex), { ...s, selectedIndex: u } }, 1 (e, t) { var n; if (e.tabs.includes(t.tab)) return e; let r = e.tabs[e.selectedIndex], a = iT([...e.tabs, t.tab], e => e.current), i = null != (n = a.indexOf(r)) ? n : e.selectedIndex; return -1 === i && (i = e.selectedIndex), { ...e, tabs: a, selectedIndex: i } }, 2: (e, t) => ({ ...e, tabs: e.tabs.filter(e => e !== t.tab) }), 3: (e, t) => e.panels.includes(t.panel) ? e : { ...e, panels: iT([...e.panels, t.panel], e => e.current) }, 4: (e, t) => ({ ...e, panels: e.panels.filter(e => e !== t.panel) }) }, sX = (0, Q.createContext)(null); function s0 (e) { let t = (0, Q.useContext)(sX); if (null === t) { let t = Error("<".concat(e, " /> is missing a parent <Tab.Group /> component.")); throw Error.captureStackTrace && Error.captureStackTrace(t, s0), t } return t } sX.displayName = "TabsDataContext"; let s1 = (0, Q.createContext)(null); function s2 (e) { let t = (0, Q.useContext)(s1); if (null === t) { let t = Error("<".concat(e, " /> is missing a parent <Tab.Group /> component.")); throw Error.captureStackTrace && Error.captureStackTrace(t, s2), t } return t } function s4 (e, t) { return af(t.type, sJ, e, t) } s1.displayName = "TabsActionsContext"; let s3 = Q.Fragment; function s5 (e, t) { let { defaultIndex: n = 0, vertical: r = !1, manual: a = !1, onChange: i, selectedIndex: s = null, ...o } = e, l = r ? "vertical" : "horizontal", u = a ? "manual" : "auto", c = null !== s, d = aF(t), [h, p] = (0, Q.useReducer)(s4, { selectedIndex: null != s ? s : n, tabs: [], panels: [] }), f = (0, Q.useMemo)(() => ({ selectedIndex: h.selectedIndex }), [h.selectedIndex]), m = aM(i || (() => { })), x = aM(h.tabs), g = (0, Q.useMemo)(() => ({ orientation: l, activation: u, ...h }), [l, u, h]), v = aZ(e => (p({ type: 1, tab: e }), () => p({ type: 2, tab: e }))), y = aZ(e => (p({ type: 3, panel: e }), () => p({ type: 4, panel: e }))), b = aZ(e => { _.current !== e && m.current(e), c || p({ type: 0, index: e }) }), _ = aM(c ? e.selectedIndex : h.selectedIndex), w = (0, Q.useMemo)(() => ({ registerTab: v, registerPanel: y, change: b }), []); aR(() => { p({ type: 0, index: null != s ? s : n }) }, [s]), aR(() => { if (void 0 === _.current || h.tabs.length <= 0) return; let e = iT(h.tabs, e => e.current); e.some((e, t) => h.tabs[t] !== e) && b(e.indexOf(h.tabs[_.current])) }); let k = { ref: d }; return Q.createElement(sB, null, Q.createElement(s1.Provider, { value: w }, Q.createElement(sX.Provider, { value: g }, g.tabs.length <= 0 && Q.createElement(sW, { onFocus: () => { var e, t; for (let n of x.current) if ((null == (e = n.current) ? void 0 : e.tabIndex) === 0) return null == (t = n.current) || t.focus(), !0; return !1 } }), ag({ ourProps: k, theirProps: o, slot: f, defaultTag: s3, name: "Tabs" })))) } let s7 = "div"; function s9 (e, t) { let { orientation: n, selectedIndex: r } = s0("Tab.List"); return ag({ ourProps: { ref: aF(t), role: "tablist", "aria-orientation": n }, theirProps: e, slot: { selectedIndex: r }, defaultTag: s7, name: "Tabs.List" }) } let s6 = "button"; function s8 (e, t) { var n, r; let a = is(), { id: i = "headlessui-tabs-tab-".concat(a), ...s } = e, { orientation: o, activation: l, selectedIndex: u, tabs: c, panels: d } = s0("Tab"), h = s2("Tab"), p = s0("Tab"), f = (0, Q.useRef)(null), m = aF(f, t); aR(() => h.registerTab(f), [h, f]); let x = sG("tabs"), g = c.indexOf(f); -1 === g && (g = x); let v = g === u, y = aZ(e => { var t; let n = e(); if (n === iv.Success && "auto" === l) { let e = null == (t = im(f)) ? void 0 : t.activeElement, n = p.tabs.findIndex(t => t.current === e); -1 !== n && h.change(n) } return n }), b = aZ(e => { let t = c.map(e => e.current).filter(Boolean); if (e.key === il.Space || e.key === il.Enter) { e.preventDefault(), e.stopPropagation(), h.change(g); return } switch (e.key) { case il.Home: case il.PageUp: return e.preventDefault(), e.stopPropagation(), y(() => iS(t, ig.First)); case il.End: case il.PageDown: return e.preventDefault(), e.stopPropagation(), y(() => iS(t, ig.Last)) }if (y(() => af(o, { vertical: () => e.key === il.ArrowUp ? iS(t, ig.Previous | ig.WrapAround) : e.key === il.ArrowDown ? iS(t, ig.Next | ig.WrapAround) : iv.Error, horizontal: () => e.key === il.ArrowLeft ? iS(t, ig.Previous | ig.WrapAround) : e.key === il.ArrowRight ? iS(t, ig.Next | ig.WrapAround) : iv.Error })) === iv.Success) return e.preventDefault() }), _ = (0, Q.useRef)(!1), w = aZ(() => { var e; _.current || (_.current = !0, null == (e = f.current) || e.focus(), h.change(g), a$(() => { _.current = !1 })) }), k = aZ(e => { e.preventDefault() }), j = (0, Q.useMemo)(() => ({ selected: v }), [v]); return ag({ ourProps: { ref: m, onKeyDown: b, onMouseDown: k, onClick: w, id: i, role: "tab", type: iI(e, f), "aria-controls": null == (r = null == (n = d[g]) ? void 0 : n.current) ? void 0 : r.id, "aria-selected": v, tabIndex: v ? 0 : -1 }, theirProps: s, slot: j, defaultTag: s6, name: "Tabs.Tab" }) } let oe = "div"; function ot (e, t) { let { selectedIndex: n } = s0("Tab.Panels"); return ag({ ourProps: { ref: aF(t) }, theirProps: e, slot: (0, Q.useMemo)(() => ({ selectedIndex: n }), [n]), defaultTag: oe, name: "Tabs.Panels" }) } let on = "div", or = am.RenderStrategy | am.Static; function oa (e, t) { var n, r, a, i; let s = is(), { id: o = "headlessui-tabs-panel-".concat(s), tabIndex: l = 0, ...u } = e, { selectedIndex: c, tabs: d, panels: h } = s0("Tab.Panel"), p = s2("Tab.Panel"), f = (0, Q.useRef)(null), m = aF(f, t); aR(() => p.registerPanel(f), [p, f]); let x = sG("panels"), g = h.indexOf(f); -1 === g && (g = x); let v = g === c, y = (0, Q.useMemo)(() => ({ selected: v }), [v]), b = { ref: m, id: o, role: "tabpanel", "aria-labelledby": null == (r = null == (n = d[g]) ? void 0 : n.current) ? void 0 : r.id, tabIndex: v ? l : -1 }; return v || null != (a = u.unmount) && !a || null != (i = u.static) && i ? ag({ ourProps: b, theirProps: u, slot: y, defaultTag: on, features: or, visible: v, name: "Tabs.Panel" }) : Q.createElement(iL, { as: "span", ...b }) } let oi = Object.assign(a_(s8), { Group: a_(s5), List: a_(s9), Panels: a_(ot), Panel: a_(oa) }); !function (e) { function t (e) { } function n (e) { throw Error() } function r (e, t = " | ") { return e.map(e => "string" == typeof e ? `'${e}'` : e).join(t) } e.assertEqual = e => e, e.assertIs = t, e.assertNever = n, e.arrayToEnum = e => { let t = {}; for (let n of e) t[n] = n; return t }, e.getValidEnumValues = t => { let n = e.objectKeys(t).filter(e => "number" != typeof t[t[e]]), r = {}; for (let e of n) r[e] = t[e]; return e.objectValues(r) }, e.objectValues = t => e.objectKeys(t).map(function (e) { return t[e] }), e.objectKeys = "function" == typeof Object.keys ? e => Object.keys(e) : e => { let t = []; for (let n in e) Object.prototype.hasOwnProperty.call(e, n) && t.push(n); return t }, e.find = (e, t) => { for (let n of e) if (t(n)) return n }, e.isInteger = "function" == typeof Number.isInteger ? e => Number.isInteger(e) : e => "number" == typeof e && isFinite(e) && Math.floor(e) === e, e.joinValues = r, e.jsonStringifyReplacer = (e, t) => "bigint" == typeof t ? t.toString() : t }(H || (H = {})); let os = H.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), oo = e => { switch (typeof e) { case "undefined": return os.undefined; case "string": return os.string; case "number": return isNaN(e) ? os.nan : os.number; case "boolean": return os.boolean; case "function": return os.function; case "bigint": return os.bigint; case "symbol": return os.symbol; case "object": if (Array.isArray(e)) return os.array; if (null === e) return os.null; if (e.then && "function" == typeof e.then && e.catch && "function" == typeof e.catch) return os.promise; if ("undefined" != typeof Map && e instanceof Map) return os.map; if ("undefined" != typeof Set && e instanceof Set) return os.set; if ("undefined" != typeof Date && e instanceof Date) return os.date; return os.object; default: return os.unknown } }, ol = H.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]), ou = e => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"); class oc extends Error { constructor(e) { super(), this.issues = [], this.addIssue = e => { this.issues = [...this.issues, e] }, this.addIssues = (e = []) => { this.issues = [...this.issues, ...e] }; let t = new.target.prototype; Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e } get errors () { return this.issues } format (e) { let t = e || function (e) { return e.message }, n = { _errors: [] }, r = e => { for (let a of e.issues) if ("invalid_union" === a.code) a.unionErrors.map(r); else if ("invalid_return_type" === a.code) r(a.returnTypeError); else if ("invalid_arguments" === a.code) r(a.argumentsError); else if (0 === a.path.length) n._errors.push(t(a)); else { let e = n, r = 0; for (; r < a.path.length;) { let n = a.path[r]; r === a.path.length - 1 ? (e[n] = e[n] || { _errors: [] }, e[n]._errors.push(t(a))) : e[n] = e[n] || { _errors: [] }, e = e[n], r++ } } }; return r(this), n } toString () { return this.message } get message () { return JSON.stringify(this.issues, H.jsonStringifyReplacer, 2) } get isEmpty () { return 0 === this.issues.length } flatten (e = e => e.message) { let t = {}, n = []; for (let r of this.issues) r.path.length > 0 ? (t[r.path[0]] = t[r.path[0]] || [], t[r.path[0]].push(e(r))) : n.push(e(r)); return { formErrors: n, fieldErrors: t } } get formErrors () { return this.flatten() } } oc.create = e => new oc(e); let od = (e, t) => { let n; switch (e.code) { case ol.invalid_type: n = e.received === os.undefined ? "Required" : `Expected ${e.expected}, received ${e.received}`; break; case ol.invalid_literal: n = `Invalid literal value, expected ${JSON.stringify(e.expected, H.jsonStringifyReplacer)}`; break; case ol.unrecognized_keys: n = `Unrecognized key(s) in object: ${H.joinValues(e.keys, ", ")}`; break; case ol.invalid_union: n = "Invalid input"; break; case ol.invalid_union_discriminator: n = `Invalid discriminator value. Expected ${H.joinValues(e.options)}`; break; case ol.invalid_enum_value: n = `Invalid enum value. Expected ${H.joinValues(e.options)}, received '${e.received}'`; break; case ol.invalid_arguments: n = "Invalid function arguments"; break; case ol.invalid_return_type: n = "Invalid function return type"; break; case ol.invalid_date: n = "Invalid date"; break; case ol.invalid_string: "object" == typeof e.validation ? "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : H.assertNever(e.validation) : n = "regex" !== e.validation ? `Invalid ${e.validation}` : "Invalid"; break; case ol.too_small: n = "array" === e.type ? `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : "string" === e.type ? `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : "number" === e.type ? `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : "date" === e.type ? `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(e.minimum)}` : "Invalid input"; break; case ol.too_big: n = "array" === e.type ? `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : "string" === e.type ? `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : "number" === e.type ? `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : "date" === e.type ? `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(e.maximum)}` : "Invalid input"; break; case ol.custom: n = "Invalid input"; break; case ol.invalid_intersection_types: n = "Intersection results could not be merged"; break; case ol.not_multiple_of: n = `Number must be a multiple of ${e.multipleOf}`; break; case ol.not_finite: n = "Number must be finite"; break; default: n = t.defaultError, H.assertNever(e) }return { message: n } }, oh = od; function op (e) { oh = e } function of () { return oh } let om = e => { let { data: t, path: n, errorMaps: r, issueData: a } = e, i = [...n, ...a.path || []], s = { ...a, path: i }, o = ""; for (let e of r.filter(e => !!e).slice().reverse()) o = e(s, { data: t, defaultError: o }).message; return { ...a, path: i, message: a.message || o } }, ox = []; function og (e, t) { let n = om({ issueData: t, data: e.data, path: e.path, errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, of(), od].filter(e => !!e) }); e.common.issues.push(n) } class ov { constructor() { this.value = "valid" } dirty () { "valid" === this.value && (this.value = "dirty") } abort () { "aborted" !== this.value && (this.value = "aborted") } static mergeArray (e, t) { let n = []; for (let r of t) { if ("aborted" === r.status) return oy; "dirty" === r.status && e.dirty(), n.push(r.value) } return { status: e.value, value: n } } static async mergeObjectAsync (e, t) { let n = []; for (let e of t) n.push({ key: await e.key, value: await e.value }); return ov.mergeObjectSync(e, n) } static mergeObjectSync (e, t) { let n = {}; for (let r of t) { let { key: t, value: a } = r; if ("aborted" === t.status || "aborted" === a.status) return oy; "dirty" === t.status && e.dirty(), "dirty" === a.status && e.dirty(), (void 0 !== a.value || r.alwaysSet) && (n[t.value] = a.value) } return { status: e.value, value: n } } } let oy = Object.freeze({ status: "aborted" }), ob = e => ({ status: "dirty", value: e }), o_ = e => ({ status: "valid", value: e }), ow = e => "aborted" === e.status, ok = e => "dirty" === e.status, oj = e => "valid" === e.status, oE = e => e instanceof Promise; !function (e) { e.errToObj = e => "string" == typeof e ? { message: e } : e || {}, e.toString = e => "string" == typeof e ? e : null == e ? void 0 : e.message }(V || (V = {})); class oO { constructor(e, t, n, r) { this.parent = e, this.data = t, this._path = n, this._key = r } get path () { return this._path.concat(this._key) } } let oT = (e, t) => { if (oj(t)) return { success: !0, data: t.value }; if (!e.common.issues.length) throw Error("Validation failed but no issues detected."); return { success: !1, error: new oc(e.common.issues) } }; function oC (e) { if (!e) return {}; let { errorMap: t, invalid_type_error: n, required_error: r, description: a } = e; if (t && (n || r)) throw Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.'); return t ? { errorMap: t, description: a } : { errorMap: (e, t) => "invalid_type" !== e.code ? { message: t.defaultError } : void 0 === t.data ? { message: null != r ? r : t.defaultError } : { message: null != n ? n : t.defaultError }, description: a } } class oS { constructor(e) { this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this) } get description () { return this._def.description } _getType (e) { return oo(e.data) } _getOrReturnCtx (e, t) { return t || { common: e.parent.common, data: e.data, parsedType: oo(e.data), schemaErrorMap: this._def.errorMap, path: e.path, parent: e.parent } } _processInputParams (e) { return { status: new ov, ctx: { common: e.parent.common, data: e.data, parsedType: oo(e.data), schemaErrorMap: this._def.errorMap, path: e.path, parent: e.parent } } } _parseSync (e) { let t = this._parse(e); if (oE(t)) throw Error("Synchronous parse encountered promise."); return t } _parseAsync (e) { return Promise.resolve(this._parse(e)) } parse (e, t) { let n = this.safeParse(e, t); if (n.success) return n.data; throw n.error } safeParse (e, t) { var n; let r = { common: { issues: [], async: null !== (n = null == t ? void 0 : t.async) && void 0 !== n && n, contextualErrorMap: null == t ? void 0 : t.errorMap }, path: (null == t ? void 0 : t.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e, parsedType: oo(e) }, a = this._parseSync({ data: e, path: r.path, parent: r }); return oT(r, a) } async parseAsync (e, t) { let n = await this.safeParseAsync(e, t); if (n.success) return n.data; throw n.error } async safeParseAsync (e, t) { let n = { common: { issues: [], contextualErrorMap: null == t ? void 0 : t.errorMap, async: !0 }, path: (null == t ? void 0 : t.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e, parsedType: oo(e) }, r = this._parse({ data: e, path: n.path, parent: n }); return oT(n, await (oE(r) ? r : Promise.resolve(r))) } refine (e, t) { let n = e => "string" == typeof t || void 0 === t ? { message: t } : "function" == typeof t ? t(e) : t; return this._refinement((t, r) => { let a = e(t), i = () => r.addIssue({ code: ol.custom, ...n(t) }); return "undefined" != typeof Promise && a instanceof Promise ? a.then(e => !!e || (i(), !1)) : !!a || (i(), !1) }) } refinement (e, t) { return this._refinement((n, r) => !!e(n) || (r.addIssue("function" == typeof t ? t(n, r) : t), !1)) } _refinement (e) { return new lr({ schema: this, typeName: G.ZodEffects, effect: { type: "refinement", refinement: e } }) } superRefine (e) { return this._refinement(e) } optional () { return la.create(this) } nullable () { return li.create(this) } nullish () { return this.optional().nullable() } array () { return oG.create(this) } promise () { return ln.create(this) } or (e) { return oY.create([this, e]) } and (e) { return o1.create(this, e) } transform (e) { return new lr({ schema: this, typeName: G.ZodEffects, effect: { type: "transform", transform: e } }) } default (e) { return new ls({ innerType: this, defaultValue: "function" == typeof e ? e : () => e, typeName: G.ZodDefault }) } brand () { return new lc({ typeName: G.ZodBranded, type: this, ...oC(void 0) }) } catch (e) { return new lo({ innerType: this, defaultValue: "function" == typeof e ? e : () => e, typeName: G.ZodCatch }) } describe (e) { return new this.constructor({ ...this._def, description: e }) } pipe (e) { return ld.create(this, e) } isOptional () { return this.safeParse(void 0).success } isNullable () { return this.safeParse(null).success } } let oN = /^c[^\s-]{8,}$/i, oI = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, oA = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i, oR = e => e.precision ? e.offset ? RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}:\\d{2})|Z)$`) : RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : 0 === e.precision ? e.offset ? RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}:\\d{2})|Z)$") : RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}:\\d{2})|Z)$") : RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$"); class oP extends oS { constructor() { super(...arguments), this._regex = (e, t, n) => this.refinement(t => e.test(t), { validation: t, code: ol.invalid_string, ...V.errToObj(n) }), this.nonempty = e => this.min(1, V.errToObj(e)), this.trim = () => new oP({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] }) } _parse (e) { let t; if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== os.string) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.string, received: t.parsedType }), oy } let n = new ov; for (let r of this._def.checks) if ("min" === r.kind) e.data.length < r.value && (og(t = this._getOrReturnCtx(e, t), { code: ol.too_small, minimum: r.value, type: "string", inclusive: !0, exact: !1, message: r.message }), n.dirty()); else if ("max" === r.kind) e.data.length > r.value && (og(t = this._getOrReturnCtx(e, t), { code: ol.too_big, maximum: r.value, type: "string", inclusive: !0, exact: !1, message: r.message }), n.dirty()); else if ("length" === r.kind) { let a = e.data.length > r.value, i = e.data.length < r.value; (a || i) && (t = this._getOrReturnCtx(e, t), a ? og(t, { code: ol.too_big, maximum: r.value, type: "string", inclusive: !0, exact: !0, message: r.message }) : i && og(t, { code: ol.too_small, minimum: r.value, type: "string", inclusive: !0, exact: !0, message: r.message }), n.dirty()) } else if ("email" === r.kind) oA.test(e.data) || (og(t = this._getOrReturnCtx(e, t), { validation: "email", code: ol.invalid_string, message: r.message }), n.dirty()); else if ("uuid" === r.kind) oI.test(e.data) || (og(t = this._getOrReturnCtx(e, t), { validation: "uuid", code: ol.invalid_string, message: r.message }), n.dirty()); else if ("cuid" === r.kind) oN.test(e.data) || (og(t = this._getOrReturnCtx(e, t), { validation: "cuid", code: ol.invalid_string, message: r.message }), n.dirty()); else if ("url" === r.kind) try { new URL(e.data) } catch (a) { og(t = this._getOrReturnCtx(e, t), { validation: "url", code: ol.invalid_string, message: r.message }), n.dirty() } else "regex" === r.kind ? (r.regex.lastIndex = 0, r.regex.test(e.data) || (og(t = this._getOrReturnCtx(e, t), { validation: "regex", code: ol.invalid_string, message: r.message }), n.dirty())) : "trim" === r.kind ? e.data = e.data.trim() : "startsWith" === r.kind ? e.data.startsWith(r.value) || (og(t = this._getOrReturnCtx(e, t), { code: ol.invalid_string, validation: { startsWith: r.value }, message: r.message }), n.dirty()) : "endsWith" === r.kind ? e.data.endsWith(r.value) || (og(t = this._getOrReturnCtx(e, t), { code: ol.invalid_string, validation: { endsWith: r.value }, message: r.message }), n.dirty()) : "datetime" === r.kind ? oR(r).test(e.data) || (og(t = this._getOrReturnCtx(e, t), { code: ol.invalid_string, validation: "datetime", message: r.message }), n.dirty()) : H.assertNever(r); return { status: n.value, value: e.data } } _addCheck (e) { return new oP({ ...this._def, checks: [...this._def.checks, e] }) } email (e) { return this._addCheck({ kind: "email", ...V.errToObj(e) }) } url (e) { return this._addCheck({ kind: "url", ...V.errToObj(e) }) } uuid (e) { return this._addCheck({ kind: "uuid", ...V.errToObj(e) }) } cuid (e) { return this._addCheck({ kind: "cuid", ...V.errToObj(e) }) } datetime (e) { var t; return "string" == typeof e ? this._addCheck({ kind: "datetime", precision: null, offset: !1, message: e }) : this._addCheck({ kind: "datetime", precision: void 0 === (null == e ? void 0 : e.precision) ? null : null == e ? void 0 : e.precision, offset: null !== (t = null == e ? void 0 : e.offset) && void 0 !== t && t, ...V.errToObj(null == e ? void 0 : e.message) }) } regex (e, t) { return this._addCheck({ kind: "regex", regex: e, ...V.errToObj(t) }) } startsWith (e, t) { return this._addCheck({ kind: "startsWith", value: e, ...V.errToObj(t) }) } endsWith (e, t) { return this._addCheck({ kind: "endsWith", value: e, ...V.errToObj(t) }) } min (e, t) { return this._addCheck({ kind: "min", value: e, ...V.errToObj(t) }) } max (e, t) { return this._addCheck({ kind: "max", value: e, ...V.errToObj(t) }) } length (e, t) { return this._addCheck({ kind: "length", value: e, ...V.errToObj(t) }) } get isDatetime () { return !!this._def.checks.find(e => "datetime" === e.kind) } get isEmail () { return !!this._def.checks.find(e => "email" === e.kind) } get isURL () { return !!this._def.checks.find(e => "url" === e.kind) } get isUUID () { return !!this._def.checks.find(e => "uuid" === e.kind) } get isCUID () { return !!this._def.checks.find(e => "cuid" === e.kind) } get minLength () { let e = null; for (let t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value); return e } get maxLength () { let e = null; for (let t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value); return e } } function oM (e, t) { let n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, a = n > r ? n : r; return parseInt(e.toFixed(a).replace(".", "")) % parseInt(t.toFixed(a).replace(".", "")) / Math.pow(10, a) } oP.create = e => { var t; return new oP({ checks: [], typeName: G.ZodString, coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t, ...oC(e) }) }; class oL extends oS { constructor() { super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf } _parse (e) { let t; if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== os.number) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.number, received: t.parsedType }), oy } let n = new ov; for (let r of this._def.checks) "int" === r.kind ? H.isInteger(e.data) || (og(t = this._getOrReturnCtx(e, t), { code: ol.invalid_type, expected: "integer", received: "float", message: r.message }), n.dirty()) : "min" === r.kind ? (r.inclusive ? e.data < r.value : e.data <= r.value) && (og(t = this._getOrReturnCtx(e, t), { code: ol.too_small, minimum: r.value, type: "number", inclusive: r.inclusive, exact: !1, message: r.message }), n.dirty()) : "max" === r.kind ? (r.inclusive ? e.data > r.value : e.data >= r.value) && (og(t = this._getOrReturnCtx(e, t), { code: ol.too_big, maximum: r.value, type: "number", inclusive: r.inclusive, exact: !1, message: r.message }), n.dirty()) : "multipleOf" === r.kind ? 0 !== oM(e.data, r.value) && (og(t = this._getOrReturnCtx(e, t), { code: ol.not_multiple_of, multipleOf: r.value, message: r.message }), n.dirty()) : "finite" === r.kind ? Number.isFinite(e.data) || (og(t = this._getOrReturnCtx(e, t), { code: ol.not_finite, message: r.message }), n.dirty()) : H.assertNever(r); return { status: n.value, value: e.data } } gte (e, t) { return this.setLimit("min", e, !0, V.toString(t)) } gt (e, t) { return this.setLimit("min", e, !1, V.toString(t)) } lte (e, t) { return this.setLimit("max", e, !0, V.toString(t)) } lt (e, t) { return this.setLimit("max", e, !1, V.toString(t)) } setLimit (e, t, n, r) { return new oL({ ...this._def, checks: [...this._def.checks, { kind: e, value: t, inclusive: n, message: V.toString(r) }] }) } _addCheck (e) { return new oL({ ...this._def, checks: [...this._def.checks, e] }) } int (e) { return this._addCheck({ kind: "int", message: V.toString(e) }) } positive (e) { return this._addCheck({ kind: "min", value: 0, inclusive: !1, message: V.toString(e) }) } negative (e) { return this._addCheck({ kind: "max", value: 0, inclusive: !1, message: V.toString(e) }) } nonpositive (e) { return this._addCheck({ kind: "max", value: 0, inclusive: !0, message: V.toString(e) }) } nonnegative (e) { return this._addCheck({ kind: "min", value: 0, inclusive: !0, message: V.toString(e) }) } multipleOf (e, t) { return this._addCheck({ kind: "multipleOf", value: e, message: V.toString(t) }) } finite (e) { return this._addCheck({ kind: "finite", message: V.toString(e) }) } get minValue () { let e = null; for (let t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value); return e } get maxValue () { let e = null; for (let t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value); return e } get isInt () { return !!this._def.checks.find(e => "int" === e.kind) } } oL.create = e => new oL({ checks: [], typeName: G.ZodNumber, coerce: (null == e ? void 0 : e.coerce) || !1, ...oC(e) }); class oZ extends oS { _parse (e) { if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== os.bigint) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.bigint, received: t.parsedType }), oy } return o_(e.data) } } oZ.create = e => { var t; return new oZ({ typeName: G.ZodBigInt, coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t, ...oC(e) }) }; class oD extends oS { _parse (e) { if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== os.boolean) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.boolean, received: t.parsedType }), oy } return o_(e.data) } } oD.create = e => new oD({ typeName: G.ZodBoolean, coerce: (null == e ? void 0 : e.coerce) || !1, ...oC(e) }); class oF extends oS { _parse (e) { let t; if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== os.date) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.date, received: t.parsedType }), oy } if (isNaN(e.data.getTime())) return og(this._getOrReturnCtx(e), { code: ol.invalid_date }), oy; let n = new ov; for (let r of this._def.checks) "min" === r.kind ? e.data.getTime() < r.value && (og(t = this._getOrReturnCtx(e, t), { code: ol.too_small, message: r.message, inclusive: !0, exact: !1, minimum: r.value, type: "date" }), n.dirty()) : "max" === r.kind ? e.data.getTime() > r.value && (og(t = this._getOrReturnCtx(e, t), { code: ol.too_big, message: r.message, inclusive: !0, exact: !1, maximum: r.value, type: "date" }), n.dirty()) : H.assertNever(r); return { status: n.value, value: new Date(e.data.getTime()) } } _addCheck (e) { return new oF({ ...this._def, checks: [...this._def.checks, e] }) } min (e, t) { return this._addCheck({ kind: "min", value: e.getTime(), message: V.toString(t) }) } max (e, t) { return this._addCheck({ kind: "max", value: e.getTime(), message: V.toString(t) }) } get minDate () { let e = null; for (let t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value); return null != e ? new Date(e) : null } get maxDate () { let e = null; for (let t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value); return null != e ? new Date(e) : null } } oF.create = e => new oF({ checks: [], coerce: (null == e ? void 0 : e.coerce) || !1, typeName: G.ZodDate, ...oC(e) }); class oz extends oS { _parse (e) { if (this._getType(e) !== os.symbol) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.symbol, received: t.parsedType }), oy } return o_(e.data) } } oz.create = e => new oz({ typeName: G.ZodSymbol, ...oC(e) }); class o$ extends oS { _parse (e) { if (this._getType(e) !== os.undefined) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.undefined, received: t.parsedType }), oy } return o_(e.data) } } o$.create = e => new o$({ typeName: G.ZodUndefined, ...oC(e) }); class oU extends oS { _parse (e) { if (this._getType(e) !== os.null) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.null, received: t.parsedType }), oy } return o_(e.data) } } oU.create = e => new oU({ typeName: G.ZodNull, ...oC(e) }); class oW extends oS { constructor() { super(...arguments), this._any = !0 } _parse (e) { return o_(e.data) } } oW.create = e => new oW({ typeName: G.ZodAny, ...oC(e) }); class oH extends oS { constructor() { super(...arguments), this._unknown = !0 } _parse (e) { return o_(e.data) } } oH.create = e => new oH({ typeName: G.ZodUnknown, ...oC(e) }); class oV extends oS { _parse (e) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.never, received: t.parsedType }), oy } } oV.create = e => new oV({ typeName: G.ZodNever, ...oC(e) }); class oB extends oS { _parse (e) { if (this._getType(e) !== os.undefined) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.void, received: t.parsedType }), oy } return o_(e.data) } } oB.create = e => new oB({ typeName: G.ZodVoid, ...oC(e) }); class oG extends oS { _parse (e) { let { ctx: t, status: n } = this._processInputParams(e), r = this._def; if (t.parsedType !== os.array) return og(t, { code: ol.invalid_type, expected: os.array, received: t.parsedType }), oy; if (null !== r.exactLength) { let e = t.data.length > r.exactLength.value, a = t.data.length < r.exactLength.value; (e || a) && (og(t, { code: e ? ol.too_big : ol.too_small, minimum: a ? r.exactLength.value : void 0, maximum: e ? r.exactLength.value : void 0, type: "array", inclusive: !0, exact: !0, message: r.exactLength.message }), n.dirty()) } if (null !== r.minLength && t.data.length < r.minLength.value && (og(t, { code: ol.too_small, minimum: r.minLength.value, type: "array", inclusive: !0, exact: !1, message: r.minLength.message }), n.dirty()), null !== r.maxLength && t.data.length > r.maxLength.value && (og(t, { code: ol.too_big, maximum: r.maxLength.value, type: "array", inclusive: !0, exact: !1, message: r.maxLength.message }), n.dirty()), t.common.async) return Promise.all(t.data.map((e, n) => r.type._parseAsync(new oO(t, e, t.path, n)))).then(e => ov.mergeArray(n, e)); let a = t.data.map((e, n) => r.type._parseSync(new oO(t, e, t.path, n))); return ov.mergeArray(n, a) } get element () { return this._def.type } min (e, t) { return new oG({ ...this._def, minLength: { value: e, message: V.toString(t) } }) } max (e, t) { return new oG({ ...this._def, maxLength: { value: e, message: V.toString(t) } }) } length (e, t) { return new oG({ ...this._def, exactLength: { value: e, message: V.toString(t) } }) } nonempty (e) { return this.min(1, e) } } oG.create = (e, t) => new oG({ type: e, minLength: null, maxLength: null, exactLength: null, typeName: G.ZodArray, ...oC(t) }), function (e) { e.mergeShapes = (e, t) => ({ ...e, ...t }) }(B || (B = {})); let oq = e => t => new oQ({ ...e, shape: () => ({ ...e.shape(), ...t }) }); function oK (e) { if (e instanceof oQ) { let t = {}; for (let n in e.shape) { let r = e.shape[n]; t[n] = la.create(oK(r)) } return new oQ({ ...e._def, shape: () => t }) } return e instanceof oG ? oG.create(oK(e.element)) : e instanceof la ? la.create(oK(e.unwrap())) : e instanceof li ? li.create(oK(e.unwrap())) : e instanceof o2 ? o2.create(e.items.map(e => oK(e))) : e } class oQ extends oS { constructor() { super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = oq(this._def), this.extend = oq(this._def) } _getCached () { if (null !== this._cached) return this._cached; let e = this._def.shape(), t = H.objectKeys(e); return this._cached = { shape: e, keys: t } } _parse (e) { if (this._getType(e) !== os.object) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.object, received: t.parsedType }), oy } let { status: t, ctx: n } = this._processInputParams(e), { shape: r, keys: a } = this._getCached(), i = []; if (!(this._def.catchall instanceof oV && "strip" === this._def.unknownKeys)) for (let e in n.data) a.includes(e) || i.push(e); let s = []; for (let e of a) { let t = r[e], a = n.data[e]; s.push({ key: { status: "valid", value: e }, value: t._parse(new oO(n, a, n.path, e)), alwaysSet: e in n.data }) } if (this._def.catchall instanceof oV) { let e = this._def.unknownKeys; if ("passthrough" === e) for (let e of i) s.push({ key: { status: "valid", value: e }, value: { status: "valid", value: n.data[e] } }); else if ("strict" === e) i.length > 0 && (og(n, { code: ol.unrecognized_keys, keys: i }), t.dirty()); else if ("strip" === e); else throw Error("Internal ZodObject error: invalid unknownKeys value.") } else { let e = this._def.catchall; for (let t of i) { let r = n.data[t]; s.push({ key: { status: "valid", value: t }, value: e._parse(new oO(n, r, n.path, t)), alwaysSet: t in n.data }) } } return n.common.async ? Promise.resolve().then(async () => { let e = []; for (let t of s) { let n = await t.key; e.push({ key: n, value: await t.value, alwaysSet: t.alwaysSet }) } return e }).then(e => ov.mergeObjectSync(t, e)) : ov.mergeObjectSync(t, s) } get shape () { return this._def.shape() } strict (e) { return V.errToObj, new oQ({ ...this._def, unknownKeys: "strict", ...void 0 !== e ? { errorMap: (t, n) => { var r, a, i, s; let o = null !== (i = null === (a = (r = this._def).errorMap) || void 0 === a ? void 0 : a.call(r, t, n).message) && void 0 !== i ? i : n.defaultError; return "unrecognized_keys" === t.code ? { message: null !== (s = V.errToObj(e).message) && void 0 !== s ? s : o } : { message: o } } } : {} }) } strip () { return new oQ({ ...this._def, unknownKeys: "strip" }) } passthrough () { return new oQ({ ...this._def, unknownKeys: "passthrough" }) } setKey (e, t) { return this.augment({ [e]: t }) } merge (e) { return new oQ({ unknownKeys: e._def.unknownKeys, catchall: e._def.catchall, shape: () => B.mergeShapes(this._def.shape(), e._def.shape()), typeName: G.ZodObject }) } catchall (e) { return new oQ({ ...this._def, catchall: e }) } pick (e) { let t = {}; return H.objectKeys(e).map(e => { this.shape[e] && (t[e] = this.shape[e]) }), new oQ({ ...this._def, shape: () => t }) } omit (e) { let t = {}; return H.objectKeys(this.shape).map(n => { -1 === H.objectKeys(e).indexOf(n) && (t[n] = this.shape[n]) }), new oQ({ ...this._def, shape: () => t }) } deepPartial () { return oK(this) } partial (e) { let t = {}; if (e) H.objectKeys(this.shape).map(n => { -1 === H.objectKeys(e).indexOf(n) ? t[n] = this.shape[n] : t[n] = this.shape[n].optional() }); else for (let e in this.shape) { let n = this.shape[e]; t[e] = n.optional() } return new oQ({ ...this._def, shape: () => t }) } required (e) { let t = {}; if (e) H.objectKeys(this.shape).map(n => { if (-1 === H.objectKeys(e).indexOf(n)) t[n] = this.shape[n]; else { let e = this.shape[n]; for (; e instanceof la;)e = e._def.innerType; t[n] = e } }); else for (let e in this.shape) { let n = this.shape[e]; for (; n instanceof la;)n = n._def.innerType; t[e] = n } return new oQ({ ...this._def, shape: () => t }) } keyof () { return o8(H.objectKeys(this.shape)) } } oQ.create = (e, t) => new oQ({ shape: () => e, unknownKeys: "strip", catchall: oV.create(), typeName: G.ZodObject, ...oC(t) }), oQ.strictCreate = (e, t) => new oQ({ shape: () => e, unknownKeys: "strict", catchall: oV.create(), typeName: G.ZodObject, ...oC(t) }), oQ.lazycreate = (e, t) => new oQ({ shape: e, unknownKeys: "strip", catchall: oV.create(), typeName: G.ZodObject, ...oC(t) }); class oY extends oS { _parse (e) { let { ctx: t } = this._processInputParams(e), n = this._def.options; function r (e) { for (let t of e) if ("valid" === t.result.status) return t.result; for (let n of e) if ("dirty" === n.result.status) return t.common.issues.push(...n.ctx.common.issues), n.result; let n = e.map(e => new oc(e.ctx.common.issues)); return og(t, { code: ol.invalid_union, unionErrors: n }), oy } if (t.common.async) return Promise.all(n.map(async e => { let n = { ...t, common: { ...t.common, issues: [] }, parent: null }; return { result: await e._parseAsync({ data: t.data, path: t.path, parent: n }), ctx: n } })).then(r); { let e; let r = []; for (let a of n) { let n = { ...t, common: { ...t.common, issues: [] }, parent: null }, i = a._parseSync({ data: t.data, path: t.path, parent: n }); if ("valid" === i.status) return i; "dirty" !== i.status || e || (e = { result: i, ctx: n }), n.common.issues.length && r.push(n.common.issues) } if (e) return t.common.issues.push(...e.ctx.common.issues), e.result; let a = r.map(e => new oc(e)); return og(t, { code: ol.invalid_union, unionErrors: a }), oy } } get options () { return this._def.options } } oY.create = (e, t) => new oY({ options: e, typeName: G.ZodUnion, ...oC(t) }); let oJ = e => { if (e instanceof o9) return oJ(e.schema); if (e instanceof lr) return oJ(e.innerType()); if (e instanceof o6) return [e.value]; if (e instanceof le) return e.options; if (e instanceof lt) return Object.keys(e.enum); if (e instanceof ls) return oJ(e._def.innerType); if (e instanceof o$) return [void 0]; else if (e instanceof oU) return [null]; else return null }; class oX extends oS { _parse (e) { let { ctx: t } = this._processInputParams(e); if (t.parsedType !== os.object) return og(t, { code: ol.invalid_type, expected: os.object, received: t.parsedType }), oy; let n = this.discriminator, r = t.data[n], a = this.optionsMap.get(r); return a ? t.common.async ? a._parseAsync({ data: t.data, path: t.path, parent: t }) : a._parseSync({ data: t.data, path: t.path, parent: t }) : (og(t, { code: ol.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [n] }), oy) } get discriminator () { return this._def.discriminator } get options () { return this._def.options } get optionsMap () { return this._def.optionsMap } static create (e, t, n) { let r = new Map; for (let n of t) { let t = oJ(n.shape[e]); if (!t) throw Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`); for (let a of t) { if (r.has(a)) throw Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`); r.set(a, n) } } return new oX({ typeName: G.ZodDiscriminatedUnion, discriminator: e, options: t, optionsMap: r, ...oC(n) }) } } function o0 (e, t) { let n = oo(e), r = oo(t); if (e === t) return { valid: !0, data: e }; if (n === os.object && r === os.object) { let n = H.objectKeys(t), r = H.objectKeys(e).filter(e => -1 !== n.indexOf(e)), a = { ...e, ...t }; for (let n of r) { let r = o0(e[n], t[n]); if (!r.valid) return { valid: !1 }; a[n] = r.data } return { valid: !0, data: a } } if (n === os.array && r === os.array) { if (e.length !== t.length) return { valid: !1 }; let n = []; for (let r = 0; r < e.length; r++) { let a = o0(e[r], t[r]); if (!a.valid) return { valid: !1 }; n.push(a.data) } return { valid: !0, data: n } } return n === os.date && r === os.date && +e == +t ? { valid: !0, data: e } : { valid: !1 } } class o1 extends oS { _parse (e) { let { status: t, ctx: n } = this._processInputParams(e), r = (e, r) => { if (ow(e) || ow(r)) return oy; let a = o0(e.value, r.value); return a.valid ? ((ok(e) || ok(r)) && t.dirty(), { status: t.value, value: a.data }) : (og(n, { code: ol.invalid_intersection_types }), oy) }; return n.common.async ? Promise.all([this._def.left._parseAsync({ data: n.data, path: n.path, parent: n }), this._def.right._parseAsync({ data: n.data, path: n.path, parent: n })]).then(([e, t]) => r(e, t)) : r(this._def.left._parseSync({ data: n.data, path: n.path, parent: n }), this._def.right._parseSync({ data: n.data, path: n.path, parent: n })) } } o1.create = (e, t, n) => new o1({ left: e, right: t, typeName: G.ZodIntersection, ...oC(n) }); class o2 extends oS { _parse (e) { let { status: t, ctx: n } = this._processInputParams(e); if (n.parsedType !== os.array) return og(n, { code: ol.invalid_type, expected: os.array, received: n.parsedType }), oy; if (n.data.length < this._def.items.length) return og(n, { code: ol.too_small, minimum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), oy; !this._def.rest && n.data.length > this._def.items.length && (og(n, { code: ol.too_big, maximum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), t.dirty()); let r = n.data.map((e, t) => { let r = this._def.items[t] || this._def.rest; return r ? r._parse(new oO(n, e, n.path, t)) : null }).filter(e => !!e); return n.common.async ? Promise.all(r).then(e => ov.mergeArray(t, e)) : ov.mergeArray(t, r) } get items () { return this._def.items } rest (e) { return new o2({ ...this._def, rest: e }) } } o2.create = (e, t) => { if (!Array.isArray(e)) throw Error("You must pass an array of schemas to z.tuple([ ... ])"); return new o2({ items: e, typeName: G.ZodTuple, rest: null, ...oC(t) }) }; class o4 extends oS { get keySchema () { return this._def.keyType } get valueSchema () { return this._def.valueType } _parse (e) { let { status: t, ctx: n } = this._processInputParams(e); if (n.parsedType !== os.object) return og(n, { code: ol.invalid_type, expected: os.object, received: n.parsedType }), oy; let r = [], a = this._def.keyType, i = this._def.valueType; for (let e in n.data) r.push({ key: a._parse(new oO(n, e, n.path, e)), value: i._parse(new oO(n, n.data[e], n.path, e)) }); return n.common.async ? ov.mergeObjectAsync(t, r) : ov.mergeObjectSync(t, r) } get element () { return this._def.valueType } static create (e, t, n) { return new o4(t instanceof oS ? { keyType: e, valueType: t, typeName: G.ZodRecord, ...oC(n) } : { keyType: oP.create(), valueType: e, typeName: G.ZodRecord, ...oC(t) }) } } class o3 extends oS { _parse (e) { let { status: t, ctx: n } = this._processInputParams(e); if (n.parsedType !== os.map) return og(n, { code: ol.invalid_type, expected: os.map, received: n.parsedType }), oy; let r = this._def.keyType, a = this._def.valueType, i = [...n.data.entries()].map(([e, t], i) => ({ key: r._parse(new oO(n, e, n.path, [i, "key"])), value: a._parse(new oO(n, t, n.path, [i, "value"])) })); if (n.common.async) { let e = new Map; return Promise.resolve().then(async () => { for (let n of i) { let r = await n.key, a = await n.value; if ("aborted" === r.status || "aborted" === a.status) return oy; ("dirty" === r.status || "dirty" === a.status) && t.dirty(), e.set(r.value, a.value) } return { status: t.value, value: e } }) } { let e = new Map; for (let n of i) { let r = n.key, a = n.value; if ("aborted" === r.status || "aborted" === a.status) return oy; ("dirty" === r.status || "dirty" === a.status) && t.dirty(), e.set(r.value, a.value) } return { status: t.value, value: e } } } } o3.create = (e, t, n) => new o3({ valueType: t, keyType: e, typeName: G.ZodMap, ...oC(n) }); class o5 extends oS { _parse (e) { let { status: t, ctx: n } = this._processInputParams(e); if (n.parsedType !== os.set) return og(n, { code: ol.invalid_type, expected: os.set, received: n.parsedType }), oy; let r = this._def; null !== r.minSize && n.data.size < r.minSize.value && (og(n, { code: ol.too_small, minimum: r.minSize.value, type: "set", inclusive: !0, exact: !1, message: r.minSize.message }), t.dirty()), null !== r.maxSize && n.data.size > r.maxSize.value && (og(n, { code: ol.too_big, maximum: r.maxSize.value, type: "set", inclusive: !0, exact: !1, message: r.maxSize.message }), t.dirty()); let a = this._def.valueType; function i (e) { let n = new Set; for (let r of e) { if ("aborted" === r.status) return oy; "dirty" === r.status && t.dirty(), n.add(r.value) } return { status: t.value, value: n } } let s = [...n.data.values()].map((e, t) => a._parse(new oO(n, e, n.path, t))); return n.common.async ? Promise.all(s).then(e => i(e)) : i(s) } min (e, t) { return new o5({ ...this._def, minSize: { value: e, message: V.toString(t) } }) } max (e, t) { return new o5({ ...this._def, maxSize: { value: e, message: V.toString(t) } }) } size (e, t) { return this.min(e, t).max(e, t) } nonempty (e) { return this.min(1, e) } } o5.create = (e, t) => new o5({ valueType: e, minSize: null, maxSize: null, typeName: G.ZodSet, ...oC(t) }); class o7 extends oS { constructor() { super(...arguments), this.validate = this.implement } _parse (e) { let { ctx: t } = this._processInputParams(e); if (t.parsedType !== os.function) return og(t, { code: ol.invalid_type, expected: os.function, received: t.parsedType }), oy; function n (e, n) { return om({ data: e, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, of(), od].filter(e => !!e), issueData: { code: ol.invalid_arguments, argumentsError: n } }) } function r (e, n) { return om({ data: e, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, of(), od].filter(e => !!e), issueData: { code: ol.invalid_return_type, returnTypeError: n } }) } let a = { errorMap: t.common.contextualErrorMap }, i = t.data; return this._def.returns instanceof ln ? o_(async (...e) => { let t = new oc([]), s = await this._def.args.parseAsync(e, a).catch(r => { throw t.addIssue(n(e, r)), t }), o = await i(...s); return await this._def.returns._def.type.parseAsync(o, a).catch(e => { throw t.addIssue(r(o, e)), t }) }) : o_((...e) => { let t = this._def.args.safeParse(e, a); if (!t.success) throw new oc([n(e, t.error)]); let s = i(...t.data), o = this._def.returns.safeParse(s, a); if (!o.success) throw new oc([r(s, o.error)]); return o.data }) } parameters () { return this._def.args } returnType () { return this._def.returns } args (...e) { return new o7({ ...this._def, args: o2.create(e).rest(oH.create()) }) } returns (e) { return new o7({ ...this._def, returns: e }) } implement (e) { return this.parse(e) } strictImplement (e) { return this.parse(e) } static create (e, t, n) { return new o7({ args: e || o2.create([]).rest(oH.create()), returns: t || oH.create(), typeName: G.ZodFunction, ...oC(n) }) } } class o9 extends oS { get schema () { return this._def.getter() } _parse (e) { let { ctx: t } = this._processInputParams(e); return this._def.getter()._parse({ data: t.data, path: t.path, parent: t }) } } o9.create = (e, t) => new o9({ getter: e, typeName: G.ZodLazy, ...oC(t) }); class o6 extends oS { _parse (e) { return e.data !== this._def.value ? (og(this._getOrReturnCtx(e), { code: ol.invalid_literal, expected: this._def.value }), oy) : { status: "valid", value: e.data } } get value () { return this._def.value } } function o8 (e, t) { return new le({ values: e, typeName: G.ZodEnum, ...oC(t) }) } o6.create = (e, t) => new o6({ value: e, typeName: G.ZodLiteral, ...oC(t) }); class le extends oS { _parse (e) { if ("string" != typeof e.data) { let t = this._getOrReturnCtx(e), n = this._def.values; return og(t, { expected: H.joinValues(n), received: t.parsedType, code: ol.invalid_type }), oy } if (-1 === this._def.values.indexOf(e.data)) { let t = this._getOrReturnCtx(e), n = this._def.values; return og(t, { received: t.data, code: ol.invalid_enum_value, options: n }), oy } return o_(e.data) } get options () { return this._def.values } get enum () { let e = {}; for (let t of this._def.values) e[t] = t; return e } get Values () { let e = {}; for (let t of this._def.values) e[t] = t; return e } get Enum () { let e = {}; for (let t of this._def.values) e[t] = t; return e } } le.create = o8; class lt extends oS { _parse (e) { let t = H.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e); if (n.parsedType !== os.string && n.parsedType !== os.number) { let e = H.objectValues(t); return og(n, { expected: H.joinValues(e), received: n.parsedType, code: ol.invalid_type }), oy } if (-1 === t.indexOf(e.data)) { let e = H.objectValues(t); return og(n, { received: n.data, code: ol.invalid_enum_value, options: e }), oy } return o_(e.data) } get enum () { return this._def.values } } lt.create = (e, t) => new lt({ values: e, typeName: G.ZodNativeEnum, ...oC(t) }); class ln extends oS { _parse (e) { let { ctx: t } = this._processInputParams(e); return t.parsedType !== os.promise && !1 === t.common.async ? (og(t, { code: ol.invalid_type, expected: os.promise, received: t.parsedType }), oy) : o_((t.parsedType === os.promise ? t.data : Promise.resolve(t.data)).then(e => this._def.type.parseAsync(e, { path: t.path, errorMap: t.common.contextualErrorMap }))) } } ln.create = (e, t) => new ln({ type: e, typeName: G.ZodPromise, ...oC(t) }); class lr extends oS { innerType () { return this._def.schema } sourceType () { return this._def.schema._def.typeName === G.ZodEffects ? this._def.schema.sourceType() : this._def.schema } _parse (e) { let { status: t, ctx: n } = this._processInputParams(e), r = this._def.effect || null; if ("preprocess" === r.type) { let e = r.transform(n.data); return n.common.async ? Promise.resolve(e).then(e => this._def.schema._parseAsync({ data: e, path: n.path, parent: n })) : this._def.schema._parseSync({ data: e, path: n.path, parent: n }) } let a = { addIssue: e => { og(n, e), e.fatal ? t.abort() : t.dirty() }, get path () { return n.path } }; if (a.addIssue = a.addIssue.bind(a), "refinement" === r.type) { let e = e => { let t = r.refinement(e, a); if (n.common.async) return Promise.resolve(t); if (t instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead."); return e }; if (!1 !== n.common.async) return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then(n => "aborted" === n.status ? oy : ("dirty" === n.status && t.dirty(), e(n.value).then(() => ({ status: t.value, value: n.value })))); { let r = this._def.schema._parseSync({ data: n.data, path: n.path, parent: n }); return "aborted" === r.status ? oy : ("dirty" === r.status && t.dirty(), e(r.value), { status: t.value, value: r.value }) } } if ("transform" === r.type) { if (!1 !== n.common.async) return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then(e => oj(e) ? Promise.resolve(r.transform(e.value, a)).then(e => ({ status: t.value, value: e })) : e); { let e = this._def.schema._parseSync({ data: n.data, path: n.path, parent: n }); if (!oj(e)) return e; let i = r.transform(e.value, a); if (i instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."); return { status: t.value, value: i } } } H.assertNever(r) } } lr.create = (e, t, n) => new lr({ schema: e, typeName: G.ZodEffects, effect: t, ...oC(n) }), lr.createWithPreprocess = (e, t, n) => new lr({ schema: t, effect: { type: "preprocess", transform: e }, typeName: G.ZodEffects, ...oC(n) }); class la extends oS { _parse (e) { return this._getType(e) === os.undefined ? o_(void 0) : this._def.innerType._parse(e) } unwrap () { return this._def.innerType } } la.create = (e, t) => new la({ innerType: e, typeName: G.ZodOptional, ...oC(t) }); class li extends oS { _parse (e) { return this._getType(e) === os.null ? o_(null) : this._def.innerType._parse(e) } unwrap () { return this._def.innerType } } li.create = (e, t) => new li({ innerType: e, typeName: G.ZodNullable, ...oC(t) }); class ls extends oS { _parse (e) { let { ctx: t } = this._processInputParams(e), n = t.data; return t.parsedType === os.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({ data: n, path: t.path, parent: t }) } removeDefault () { return this._def.innerType } } ls.create = (e, t) => new ls({ innerType: e, typeName: G.ZodDefault, defaultValue: "function" == typeof t.default ? t.default : () => t.default, ...oC(t) }); class lo extends oS { _parse (e) { let { ctx: t } = this._processInputParams(e), n = this._def.innerType._parse({ data: t.data, path: t.path, parent: t }); return oE(n) ? n.then(e => ({ status: "valid", value: "valid" === e.status ? e.value : this._def.defaultValue() })) : { status: "valid", value: "valid" === n.status ? n.value : this._def.defaultValue() } } removeDefault () { return this._def.innerType } } lo.create = (e, t) => new lo({ innerType: e, typeName: G.ZodCatch, defaultValue: "function" == typeof t.default ? t.default : () => t.default, ...oC(t) }); class ll extends oS { _parse (e) { if (this._getType(e) !== os.nan) { let t = this._getOrReturnCtx(e); return og(t, { code: ol.invalid_type, expected: os.nan, received: t.parsedType }), oy } return { status: "valid", value: e.data } } } ll.create = e => new ll({ typeName: G.ZodNaN, ...oC(e) }); let lu = Symbol("zod_brand"); class lc extends oS { _parse (e) { let { ctx: t } = this._processInputParams(e), n = t.data; return this._def.type._parse({ data: n, path: t.path, parent: t }) } unwrap () { return this._def.type } } class ld extends oS { _parse (e) { let { status: t, ctx: n } = this._processInputParams(e); if (n.common.async) return (async () => { let e = await this._def.in._parseAsync({ data: n.data, path: n.path, parent: n }); return "aborted" === e.status ? oy : "dirty" === e.status ? (t.dirty(), ob(e.value)) : this._def.out._parseAsync({ data: e.value, path: n.path, parent: n }) })(); { let e = this._def.in._parseSync({ data: n.data, path: n.path, parent: n }); return "aborted" === e.status ? oy : "dirty" === e.status ? (t.dirty(), { status: "dirty", value: e.value }) : this._def.out._parseSync({ data: e.value, path: n.path, parent: n }) } } static create (e, t) { return new ld({ in: e, out: t, typeName: G.ZodPipeline }) } } let lh = (e, t = {}, n) => e ? oW.create().superRefine((r, a) => { if (!e(r)) { let e = "function" == typeof t ? t(r) : t, i = "string" == typeof e ? { message: e } : e; a.addIssue({ code: "custom", ...i, fatal: n }) } }) : oW.create(), lp = { object: oQ.lazycreate }; !function (e) { e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline" }(G || (G = {})); let lf = (e, t = { message: `Input not instance of ${e.name}` }) => lh(t => t instanceof e, t, !0), lm = oP.create, lx = oL.create, lg = ll.create, lv = oZ.create, ly = oD.create, lb = oF.create, l_ = oz.create, lw = o$.create, lk = oU.create, lj = oW.create, lE = oH.create, lO = oV.create, lT = oB.create, lC = oG.create, lS = oQ.create, lN = oQ.strictCreate, lI = oY.create, lA = oX.create, lR = o1.create, lP = o2.create, lM = o4.create, lL = o3.create, lZ = o5.create, lD = o7.create, lF = o9.create, lz = o6.create, l$ = le.create, lU = lt.create, lW = ln.create, lH = lr.create, lV = la.create, lB = li.create, lG = lr.createWithPreprocess, lq = ld.create, lK = () => lx().optional(), lQ = () => ly().optional(), lY = { string: e => oP.create({ ...e, coerce: !0 }), number: e => oL.create({ ...e, coerce: !0 }), boolean: e => oD.create({ ...e, coerce: !0 }), bigint: e => oZ.create({ ...e, coerce: !0 }), date: e => oF.create({ ...e, coerce: !0 }) }, lJ = oy; var lX = Object.freeze({ __proto__: null, defaultErrorMap: od, setErrorMap: op, getErrorMap: of, makeIssue: om, EMPTY_PATH: ox, addIssueToContext: og, ParseStatus: ov, INVALID: oy, DIRTY: ob, OK: o_, isAborted: ow, isDirty: ok, isValid: oj, isAsync: oE, get util () { return H }, ZodParsedType: os, getParsedType: oo, ZodType: oS, ZodString: oP, ZodNumber: oL, ZodBigInt: oZ, ZodBoolean: oD, ZodDate: oF, ZodSymbol: oz, ZodUndefined: o$, ZodNull: oU, ZodAny: oW, ZodUnknown: oH, ZodNever: oV, ZodVoid: oB, ZodArray: oG, get objectUtil () { return B }, ZodObject: oQ, ZodUnion: oY, ZodDiscriminatedUnion: oX, ZodIntersection: o1, ZodTuple: o2, ZodRecord: o4, ZodMap: o3, ZodSet: o5, ZodFunction: o7, ZodLazy: o9, ZodLiteral: o6, ZodEnum: le, ZodNativeEnum: lt, ZodPromise: ln, ZodEffects: lr, ZodTransformer: lr, ZodOptional: la, ZodNullable: li, ZodDefault: ls, ZodCatch: lo, ZodNaN: ll, BRAND: lu, ZodBranded: lc, ZodPipeline: ld, custom: lh, Schema: oS, ZodSchema: oS, late: lp, get ZodFirstPartyTypeKind () { return G }, coerce: lY, any: lj, array: lC, bigint: lv, boolean: ly, date: lb, discriminatedUnion: lA, effect: lH, enum: l$, function: lD, instanceof: lf, intersection: lR, lazy: lF, literal: lz, map: lL, nan: lg, nativeEnum: lU, never: lO, null: lk, nullable: lB, number: lx, object: lS, oboolean: lQ, onumber: lK, optional: lV, ostring: () => lm().optional(), pipeline: lq, preprocess: lG, promise: lW, record: lM, set: lZ, strictObject: lN, string: lm, symbol: l_, transformer: lH, tuple: lP, undefined: lw, union: lI, unknown: lE, void: lT, NEVER: lJ, ZodIssueCode: ol, quotelessJson: ou, ZodError: oc }); function l0 () { return (l0 = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }).apply(this, arguments) } var l1 = n(6593), l2 = n.n(l1), l4 = { CASE_SENSITIVE_EQUAL: 7, EQUAL: 6, STARTS_WITH: 5, WORD_STARTS_WITH: 4, CONTAINS: 3, ACRONYM: 2, MATCHES: 1, NO_MATCH: 0 }; l5.rankings = l4; var l3 = function (e, t) { return String(e.rankedValue).localeCompare(String(t.rankedValue)) }; function l5 (e, t, n) { void 0 === n && (n = {}); var r = n, a = r.keys, i = r.threshold, s = void 0 === i ? l4.MATCHES : i, o = r.baseSort, l = void 0 === o ? l3 : o, u = r.sorter; return (void 0 === u ? function (e) { return e.sort(function (e, t) { return ue(e, t, l) }) } : u)(e.reduce(c, [])).map(function (e) { return e.item }); function c (e, r, i) { var o = l7(r, a, t, n), l = o.rank, u = o.keyThreshold; return l >= (void 0 === u ? s : u) && e.push(l0({}, o, { item: r, index: i })), e } } function l7 (e, t, n, r) { if (!t) { var a = e; return { rankedValue: a, rank: l9(a, n, r), keyIndex: -1, keyThreshold: r.threshold } } return ua(e, t).reduce(function (e, t, a) { var i = e.rank, s = e.rankedValue, o = e.keyIndex, l = e.keyThreshold, u = t.itemValue, c = t.attributes, d = l9(u, n, r), h = s, p = c.minRanking, f = c.maxRanking, m = c.threshold; return d < p && d >= l4.MATCHES ? d = p : d > f && (d = f), d > i && (i = d, o = a, l = m, h = u), { rankedValue: h, rank: i, keyIndex: o, keyThreshold: l } }, { rankedValue: e, rank: l4.NO_MATCH, keyIndex: -1, keyThreshold: r.threshold }) } function l9 (e, t, n) { return (e = ut(e, n), (t = ut(t, n)).length > e.length) ? l4.NO_MATCH : e === t ? l4.CASE_SENSITIVE_EQUAL : (e = e.toLowerCase()) === (t = t.toLowerCase()) ? l4.EQUAL : e.startsWith(t) ? l4.STARTS_WITH : e.includes(" " + t) ? l4.WORD_STARTS_WITH : e.includes(t) ? l4.CONTAINS : 1 === t.length ? l4.NO_MATCH : l6(e).includes(t) ? l4.ACRONYM : l8(e, t) } function l6 (e) { var t = ""; return e.split(" ").forEach(function (e) { e.split("-").forEach(function (e) { t += e.substr(0, 1) }) }), t } function l8 (e, t) { var n = 0, r = 0; function a (e, t, r) { for (var a = r, i = t.length; a < i; a++)if (t[a] === e) return n += 1, a + 1; return -1 } function i (e) { var r = 1 / e, a = n / t.length; return l4.MATCHES + a * r } var s = a(t[0], e, 0); if (s < 0) return l4.NO_MATCH; r = s; for (var o = 1, l = t.length; o < l; o++)if (!((r = a(t[o], e, r)) > -1)) return l4.NO_MATCH; return i(r - s) } function ue (e, t, n) { var r = -1, a = 1, i = e.rank, s = e.keyIndex, o = t.rank, l = t.keyIndex; return i !== o ? i > o ? r : a : s === l ? n(e, t) : s < l ? r : a } function ut (e, t) { return e = "" + e, t.keepDiacritics || (e = l2()(e)), e } function un (e, t) { var n; if ("object" == typeof t && (t = t.key), "function" == typeof t) n = t(e); else if (null == e) n = null; else if (Object.hasOwnProperty.call(e, t)) n = e[t]; else { if (t.includes(".")) return ur(t, e); n = null } return null == n ? [] : Array.isArray(n) ? n : [String(n)] } function ur (e, t) { for (var n = e.split("."), r = [t], a = 0, i = n.length; a < i; a++) { for (var s = n[a], o = [], l = 0, u = r.length; l < u; l++) { var c = r[l]; if (null != c) { if (Object.hasOwnProperty.call(c, s)) { var d = c[s]; null != d && o.push(d) } else "*" === s && (o = o.concat(c)) } } r = o } if (Array.isArray(r[0])) { var h = []; return h.concat.apply(h, r) } return r } function ua (e, t) { for (var n = [], r = 0, a = t.length; r < a; r++)for (var i = t[r], s = us(i), o = un(e, i), l = 0, u = o.length; l < u; l++)n.push({ itemValue: o[l], attributes: s }); return n } var ui = { maxRanking: 1 / 0, minRanking: -1 / 0 }; function us (e) { return "string" == typeof e ? ui : l0({}, ui, e) } function uo (e) { var t, n, r = ""; if ("string" == typeof e || "number" == typeof e) r += e; else if ("object" == typeof e) { if (Array.isArray(e)) { var a = e.length; for (t = 0; t < a; t++)e[t] && (n = uo(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n) } return r } var ul = function () { for (var e, t, n = 0, r = "", a = arguments.length; n < a; n++)(e = arguments[n]) && (t = uo(e)) && (r && (r += " "), r += t); return r }, uu = ({ children: e, className: t, ...n }) => (0, eu.jsx)("button", { className: ul("nextra-button nx-transition-all active:nx-opacity-50", "nx-bg-primary-700/5 nx-border nx-border-black/5 nx-text-gray-600 hover:nx-text-gray-900 nx-rounded-md nx-p-1.5", "dark:nx-bg-primary-300/10 dark:nx-border-white/10 dark:nx-text-gray-400 dark:hover:nx-text-gray-50", t), ...n, children: e }); ul("nx-border-orange-100 nx-bg-orange-50 nx-text-orange-800 dark:nx-border-orange-400/30 dark:nx-bg-orange-400/20 dark:nx-text-orange-300"), ul("nx-border-red-200 nx-bg-red-100 nx-text-red-900 dark:nx-border-red-200/30 dark:nx-bg-red-900/30 dark:nx-text-red-200"), ul("nx-border-blue-200 nx-bg-blue-100 nx-text-blue-900 dark:nx-border-blue-200/30 dark:nx-bg-blue-900/30 dark:nx-text-blue-200"), ul("nx-border-yellow-100 nx-bg-yellow-50 nx-text-yellow-900 dark:nx-border-yellow-200/30 dark:nx-bg-yellow-700/30 dark:nx-text-yellow-200"); var uc = ({ getValue: e, ...t }) => { let [n, r] = (0, Q.useState)(!1); (0, Q.useEffect)(() => { if (!n) return; let e = setTimeout(() => { r(!1) }, 2e3); return () => { clearTimeout(e) } }, [n]); let a = (0, Q.useCallback)(async () => { r(!0), navigator?.clipboard || console.error("Access to clipboard rejected!"); try { await navigator.clipboard.writeText(e()) } catch { console.error("Failed to copy!") } }, [e]), i = n ? n$ : nU; return (0, eu.jsx)(uu, { onClick: a, title: "Copy code", tabIndex: 0, ...t, children: (0, eu.jsx)(i, { className: "nextra-copy-icon nx-pointer-events-none nx-h-4 nx-w-4" }) }) }, ud = ({ children: e, className: t, ...n }) => { let r = "data-line-numbers" in n; return (0, eu.jsx)("code", { className: ul("nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em]", "dark:nx-border-white/10 dark:nx-bg-white/10", r && "[counter-reset:line]", t), dir: "ltr", ...n, children: e }) }, uh = ({ children: e, className: t, hasCopyCode: n, filename: r, ...a }) => { let i = (0, Q.useRef)(null), s = (0, Q.useCallback)(() => { let e = document.documentElement.dataset; "nextraWordWrap" in e ? delete e.nextraWordWrap : e.nextraWordWrap = "" }, []); return (0, eu.jsxs)("div", { className: "nextra-code-block nx-relative nx-mt-6 first:nx-mt-0", children: [r && (0, eu.jsx)("div", { className: "nx-absolute nx-top-0 nx-z-[1] nx-w-full nx-truncate nx-rounded-t-xl nx-bg-primary-700/5 nx-py-2 nx-px-4 nx-text-xs nx-text-gray-700 dark:nx-bg-primary-300/10 dark:nx-text-gray-200", children: r }), (0, eu.jsx)("pre", { className: ul("nx-bg-primary-700/5 nx-mb-4 nx-overflow-x-auto nx-rounded-xl nx-subpixel-antialiased dark:nx-bg-primary-300/10 nx-text-[.9em]", "contrast-more:nx-border contrast-more:nx-border-primary-900/20 contrast-more:nx-contrast-150 contrast-more:dark:nx-border-primary-100/40", r ? "nx-pt-12 nx-pb-4" : "nx-py-4", t), ref: i, ...a, children: e }), (0, eu.jsxs)("div", { className: ul("nx-opacity-0 nx-transition [div:hover>&]:nx-opacity-100 focus-within:nx-opacity-100", "nx-flex nx-gap-1 nx-absolute nx-m-[11px] nx-right-0", r ? "nx-top-8" : "nx-top-0"), children: [(0, eu.jsx)(uu, { onClick: s, className: "md:nx-hidden", title: "Toggle word wrap", children: (0, eu.jsx)(nJ, { className: "nx-pointer-events-none nx-h-4 nx-w-4" }) }), n && (0, eu.jsx)(uc, { getValue: () => i.current?.querySelector("code")?.textContent || "" })] })] }) }, up = ((E = up || {}).Space = " ", E.Enter = "Enter", E.Escape = "Escape", E.Backspace = "Backspace", E.Delete = "Delete", E.ArrowLeft = "ArrowLeft", E.ArrowUp = "ArrowUp", E.ArrowRight = "ArrowRight", E.ArrowDown = "ArrowDown", E.Home = "Home", E.End = "End", E.PageUp = "PageUp", E.PageDown = "PageDown", E.Tab = "Tab", E), uf = Object.defineProperty, um = (e, t, n) => t in e ? uf(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, ux = (e, t, n) => (um(e, "symbol" != typeof t ? t + "" : t, n), n); class ug { set (e) { this.current !== e && (this.handoffState = "pending", this.currentId = 0, this.current = e) } reset () { this.set(this.detect()) } nextId () { return ++this.currentId } get isServer () { return "server" === this.current } get isClient () { return "client" === this.current } detect () { return "undefined" == typeof document ? "server" : "client" } handoff () { "pending" === this.handoffState && (this.handoffState = "complete") } get isHandoffComplete () { return "complete" === this.handoffState } constructor() { ux(this, "current", this.detect()), ux(this, "handoffState", "pending"), ux(this, "currentId", 0) } } let uv = new ug, uy = (e, t) => { uv.isServer ? (0, Q.useEffect)(e, t) : (0, Q.useLayoutEffect)(e, t) }; function ub (e) { let t = (0, Q.useRef)(e); return uy(() => { t.current = e }, [e]), t } let u_ = function (e) { let t = ub(e); return Q.useCallback(function () { for (var e = arguments.length, n = Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return t.current(...n) }, [t]) }; function uw () { let e = "undefined" == typeof document; return (0, Y.useSyncExternalStore)(() => () => { }, () => !1, () => !e) } function uk () { let e = uw(), [t, n] = Q.useState(uv.isHandoffComplete); return t && !1 === uv.isHandoffComplete && n(!1), Q.useEffect(() => { !0 !== t && n(!0) }, [t]), Q.useEffect(() => uv.handoff(), []), !e && t } let uj = null != (q = Q.useId) ? q : function () { let e = uk(), [t, n] = Q.useState(e ? () => uv.nextId() : null); return uy(() => { null === t && n(uv.nextId()) }, [t]), null != t ? "" + t : void 0 }; function uE (e) { var t; if (e.type) return e.type; let n = null != (t = e.as) ? t : "button"; if ("string" == typeof n && "button" === n.toLowerCase()) return "button" } function uO (e, t) { let [n, r] = (0, Q.useState)(() => uE(e)); return uy(() => { r(uE(e)) }, [e.type, e.as]), uy(() => { n || t.current && t.current instanceof HTMLButtonElement && !t.current.hasAttribute("type") && r("button") }, [n, t]), n } let uT = Symbol(); function uC () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; let r = (0, Q.useRef)(t); (0, Q.useEffect)(() => { r.current = t }, [t]); let a = u_(e => { for (let t of r.current) null != t && ("function" == typeof t ? t(e) : t.current = e) }); return t.every(e => null == e || (null == e ? void 0 : e[uT])) ? void 0 : a } function uS () { let e = (0, Q.useRef)(!1); return uy(() => (e.current = !0, () => { e.current = !1 }), []), e } function uN () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return Array.from(new Set(t.flatMap(e => "string" == typeof e ? e.split(" ") : []))).filter(Boolean).join(" ") } function uI (e, t) { for (var n = arguments.length, r = Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)r[a - 2] = arguments[a]; if (e in t) { let n = t[e]; return "function" == typeof n ? n(...r) : n } let i = Error('Tried to handle "'.concat(e, '" but there is no handler defined. Only defined handlers are: ').concat(Object.keys(t).map(e => '"'.concat(e, '"')).join(", "), ".")); throw Error.captureStackTrace && Error.captureStackTrace(i, uI), i } var uA = ((O = uA || {})[O.None = 0] = "None", O[O.RenderStrategy = 1] = "RenderStrategy", O[O.Static = 2] = "Static", O), uR = ((T = uR || {})[T.Unmount = 0] = "Unmount", T[T.Hidden = 1] = "Hidden", T); function uP (e) { let { ourProps: t, theirProps: n, slot: r, defaultTag: a, features: i, visible: s = !0, name: o, mergeRefs: l } = e; l = null != l ? l : uL; let u = uZ(n, t); if (s) return uM(u, r, a, o, l); let c = null != i ? i : 0; if (2 & c) { let { static: e = !1, ...t } = u; if (e) return uM(t, r, a, o, l) } if (1 & c) { let { unmount: e = !0, ...t } = u; return uI(e ? 0 : 1, { 0: () => null, 1: () => uM({ ...t, hidden: !0, style: { display: "none" } }, r, a, o, l) }) } return uM(u, r, a, o, l) } function uM (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0, r = arguments.length > 3 ? arguments[3] : void 0, a = arguments.length > 4 ? arguments[4] : void 0, { as: i = n, children: s, refName: o = "ref", ...l } = uz(e, ["unmount", "static"]), u = void 0 !== e.ref ? { [o]: e.ref } : {}, c = "function" == typeof s ? s(t) : s; "className" in l && l.className && "function" == typeof l.className && (l.className = l.className(t)); let d = {}; if (t) { let e = !1, n = []; for (let [r, a] of Object.entries(t)) "boolean" == typeof a && (e = !0), !0 === a && n.push(r); e && (d["data-headlessui-state"] = n.join(" ")) } if (i === Q.Fragment && Object.keys(uF(l)).length > 0) { if (!(0, Q.isValidElement)(c) || Array.isArray(c) && c.length > 1) throw Error(['Passing props on "Fragment"!', "", "The current component <".concat(r, ' /> is rendering a "Fragment".'), "However we need to passthrough the following props:", Object.keys(l).map(e => "  - ".concat(e)).join("\n"), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map(e => "  - ".concat(e)).join("\n")].join("\n")); let e = c.props, t = "function" == typeof (null == e ? void 0 : e.className) ? function () { for (var t = arguments.length, n = Array(t), r = 0; r < t; r++)n[r] = arguments[r]; return uN(null == e ? void 0 : e.className(...n), l.className) } : uN(null == e ? void 0 : e.className, l.className), n = t ? { className: t } : {}; return (0, Q.cloneElement)(c, Object.assign({}, uZ(c.props, uF(uz(l, ["ref"]))), d, u, { ref: a(c.ref, u.ref) }, n)) } return (0, Q.createElement)(i, Object.assign({}, uz(l, ["ref"]), i !== Q.Fragment && u, i !== Q.Fragment && d), c) } function uL () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return t.every(e => null == e) ? void 0 : e => { for (let n of t) null != n && ("function" == typeof n ? n(e) : n.current = e) } } function uZ () { for (var e, t = arguments.length, n = Array(t), r = 0; r < t; r++)n[r] = arguments[r]; if (0 === n.length) return {}; if (1 === n.length) return n[0]; let a = {}, i = {}; for (let t of n) for (let n in t) n.startsWith("on") && "function" == typeof t[n] ? (null != (e = i[n]) || (i[n] = []), i[n].push(t[n])) : a[n] = t[n]; if (a.disabled || a["aria-disabled"]) return Object.assign(a, Object.fromEntries(Object.keys(i).map(e => [e, void 0]))); for (let e in i) Object.assign(a, { [e] (t) { for (var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)r[a - 1] = arguments[a]; for (let n of i[e]) { if ((t instanceof Event || (null == t ? void 0 : t.nativeEvent) instanceof Event) && t.defaultPrevented) return; n(t, ...r) } } }); return a } function uD (e) { var t; return Object.assign((0, Q.forwardRef)(e), { displayName: null != (t = e.displayName) ? t : e.name }) } function uF (e) { let t = Object.assign({}, e); for (let e in t) void 0 === t[e] && delete t[e]; return t } function uz (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n = Object.assign({}, e); for (let e of t) e in n && delete n[e]; return n } let u$ = "div"; var uU = ((C = uU || {})[C.None = 1] = "None", C[C.Focusable = 2] = "Focusable", C[C.Hidden = 4] = "Hidden", C); let uW = uD(function (e, t) { var n; let { features: r = 1, ...a } = e; return uP({ ourProps: { ref: t, "aria-hidden": (2 & r) == 2 || (null != (n = a["aria-hidden"]) ? n : void 0), hidden: (4 & r) == 4 || void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(4 & r) == 4 && (2 & r) != 2 && { display: "none" } } }, theirProps: a, slot: {}, defaultTag: u$, name: "Hidden" }) }); function uH (e) { let { onFocus: t } = e, [n, r] = (0, Q.useState)(!0), a = uS(); return n ? Q.createElement(uW, { as: "button", type: "button", features: uU.Focusable, onFocus: e => { e.preventDefault(); let n, i = 50; function s () { if (i-- <= 0) { n && cancelAnimationFrame(n); return } if (t()) { if (cancelAnimationFrame(n), !a.current) return; r(!1); return } n = requestAnimationFrame(s) } n = requestAnimationFrame(s) } }) : null } let uV = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(e => "".concat(e, ":not([tabindex='-1'])")).join(","); var uB = ((S = uB || {})[S.First = 1] = "First", S[S.Previous = 2] = "Previous", S[S.Next = 4] = "Next", S[S.Last = 8] = "Last", S[S.WrapAround = 16] = "WrapAround", S[S.NoScroll = 32] = "NoScroll", S), uG = ((N = uG || {})[N.Error = 0] = "Error", N[N.Overflow = 1] = "Overflow", N[N.Success = 2] = "Success", N[N.Underflow = 3] = "Underflow", N), uq = ((I = uq || {})[I.Previous = -1] = "Previous", I[I.Next = 1] = "Next", I); function uK () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document.body; return null == e ? [] : Array.from(e.querySelectorAll(uV)).sort((e, t) => Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (t.tabIndex || Number.MAX_SAFE_INTEGER))) } var uQ = ((A = uQ || {})[A.Strict = 0] = "Strict", A[A.Loose = 1] = "Loose", A), uY = ((R = uY || {})[R.Keyboard = 0] = "Keyboard", R[R.Mouse = 1] = "Mouse", R); "undefined" != typeof document && (document.addEventListener("keydown", e => { e.metaKey || e.altKey || e.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "") }, !0), document.addEventListener("click", e => { 1 === e.detail ? delete document.documentElement.dataset.headlessuiFocusVisible : 0 === e.detail && (document.documentElement.dataset.headlessuiFocusVisible = "") }, !0)); let uJ = "textarea,input"; function uX (e) { var t, n; return null != (n = null == (t = null == e ? void 0 : e.matches) ? void 0 : t.call(e, uJ)) && n } function u0 (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e => e; return e.slice().sort((e, n) => { let r = t(e), a = t(n); if (null === r || null === a) return 0; let i = r.compareDocumentPosition(a); return i & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : i & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0 }) } function u1 (e, t) { let { sorted: n = !0, relativeTo: r = null, skipElements: a = [] } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = Array.isArray(e) ? e.length > 0 ? e[0].ownerDocument : document : e.ownerDocument, s = Array.isArray(e) ? n ? u0(e) : e : uK(e); a.length > 0 && s.length > 1 && (s = s.filter(e => !a.includes(e))), r = null != r ? r : i.activeElement; let o = (() => { if (5 & t) return 1; if (10 & t) return -1; throw Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), l = (() => { if (1 & t) return 0; if (2 & t) return Math.max(0, s.indexOf(r)) - 1; if (4 & t) return Math.max(0, s.indexOf(r)) + 1; if (8 & t) return s.length - 1; throw Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), u = 32 & t ? { preventScroll: !0 } : {}, c = 0, d = s.length, h; do { if (c >= d || c + d <= 0) return 0; let e = l + c; if (16 & t) e = (e + d) % d; else { if (e < 0) return 3; if (e >= d) return 1 } null == (h = s[e]) || h.focus(u), c += o } while (h !== i.activeElement); return 6 & t && uX(h) && h.select(), 2 } function u2 (e) { "function" == typeof queueMicrotask ? queueMicrotask(e) : Promise.resolve().then(e).catch(e => setTimeout(() => { throw e })) } function u4 (e) { return uv.isServer ? null : e instanceof Node ? e.ownerDocument : null != e && e.hasOwnProperty("current") && e.current instanceof Node ? e.current.ownerDocument : document } let u3 = Q.createContext(null); function u5 () { return { groups: new Map, get (e, t) { var n; let r = this.groups.get(e); r || (r = new Map, this.groups.set(e, r)); let a = null != (n = r.get(t)) ? n : 0; function i () { let e = r.get(t); e > 1 ? r.set(t, e - 1) : r.delete(t) } return r.set(t, a + 1), [Array.from(r.keys()).indexOf(t), i] } } } function u7 (e) { let { children: t } = e, n = Q.useRef(u5()); return Q.createElement(u3.Provider, { value: n }, t) } function u9 (e) { let t = Q.useContext(u3); if (!t) throw Error("You must wrap your component in a <StableCollection>"); let n = u6(), [r, a] = t.current.get(e, n); return Q.useEffect(() => a, []), r } function u6 () { var e, t, n; let r = null != (n = null == (t = null == (e = Q.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) ? void 0 : e.ReactCurrentOwner) ? void 0 : t.current) ? n : null; if (!r) return Symbol(); let a = [], i = r; for (; i;)a.push(i.index), i = i.return; return "$." + a.join(".") } var u8 = ((P = u8 || {})[P.Forwards = 0] = "Forwards", P[P.Backwards = 1] = "Backwards", P), ce = ((M = ce || {})[M.Less = -1] = "Less", M[M.Equal = 0] = "Equal", M[M.Greater = 1] = "Greater", M), ct = ((L = ct || {})[L.SetSelectedIndex = 0] = "SetSelectedIndex", L[L.RegisterTab = 1] = "RegisterTab", L[L.UnregisterTab = 2] = "UnregisterTab", L[L.RegisterPanel = 3] = "RegisterPanel", L[L.UnregisterPanel = 4] = "UnregisterPanel", L); let cn = { 0 (e, t) { var n; let r = u0(e.tabs, e => e.current), a = u0(e.panels, e => e.current), i = r.filter(e => { var t; return !(null != (t = e.current) && t.hasAttribute("disabled")) }), s = { ...e, tabs: r, panels: a }; if (t.index < 0 || t.index > r.length - 1) { let n = uI(Math.sign(t.index - e.selectedIndex), { [-1]: () => 1, 0: () => uI(Math.sign(t.index), { [-1]: () => 0, 0: () => 0, 1: () => 1 }), 1: () => 0 }); if (0 === i.length) return s; let a = uI(n, { 0: () => r.indexOf(i[0]), 1: () => r.indexOf(i[i.length - 1]) }); return { ...s, selectedIndex: -1 === a ? e.selectedIndex : a } } let o = r.slice(0, t.index), l = [...r.slice(t.index), ...o].find(e => i.includes(e)); if (!l) return s; let u = null != (n = r.indexOf(l)) ? n : e.selectedIndex; return -1 === u && (u = e.selectedIndex), { ...s, selectedIndex: u } }, 1 (e, t) { if (e.tabs.includes(t.tab)) return e; let n = e.tabs[e.selectedIndex], r = u0([...e.tabs, t.tab], e => e.current), a = e.selectedIndex; return e.info.current.isControlled || -1 === (a = r.indexOf(n)) && (a = e.selectedIndex), { ...e, tabs: r, selectedIndex: a } }, 2: (e, t) => ({ ...e, tabs: e.tabs.filter(e => e !== t.tab) }), 3: (e, t) => e.panels.includes(t.panel) ? e : { ...e, panels: u0([...e.panels, t.panel], e => e.current) }, 4: (e, t) => ({ ...e, panels: e.panels.filter(e => e !== t.panel) }) }, cr = (0, Q.createContext)(null); function ca (e) { let t = (0, Q.useContext)(cr); if (null === t) { let t = Error("<".concat(e, " /> is missing a parent <Tab.Group /> component.")); throw Error.captureStackTrace && Error.captureStackTrace(t, ca), t } return t } cr.displayName = "TabsDataContext"; let ci = (0, Q.createContext)(null); function cs (e) { let t = (0, Q.useContext)(ci); if (null === t) { let t = Error("<".concat(e, " /> is missing a parent <Tab.Group /> component.")); throw Error.captureStackTrace && Error.captureStackTrace(t, cs), t } return t } function co (e, t) { return uI(t.type, cn, e, t) } ci.displayName = "TabsActionsContext"; let cl = Q.Fragment; function cu (e, t) { let { defaultIndex: n = 0, vertical: r = !1, manual: a = !1, onChange: i, selectedIndex: s = null, ...o } = e, l = r ? "vertical" : "horizontal", u = a ? "manual" : "auto", c = null !== s, d = ub({ isControlled: c }), h = uC(t), [p, f] = (0, Q.useReducer)(co, { info: d, selectedIndex: null != s ? s : n, tabs: [], panels: [] }), m = (0, Q.useMemo)(() => ({ selectedIndex: p.selectedIndex }), [p.selectedIndex]), x = ub(i || (() => { })), g = ub(p.tabs), v = (0, Q.useMemo)(() => ({ orientation: l, activation: u, ...p }), [l, u, p]), y = u_(e => (f({ type: 1, tab: e }), () => f({ type: 2, tab: e }))), b = u_(e => (f({ type: 3, panel: e }), () => f({ type: 4, panel: e }))), _ = u_(e => { w.current !== e && x.current(e), c || f({ type: 0, index: e }) }), w = ub(c ? e.selectedIndex : p.selectedIndex), k = (0, Q.useMemo)(() => ({ registerTab: y, registerPanel: b, change: _ }), []); uy(() => { f({ type: 0, index: null != s ? s : n }) }, [s]), uy(() => { if (void 0 === w.current || p.tabs.length <= 0) return; let e = u0(p.tabs, e => e.current); e.some((e, t) => p.tabs[t] !== e) && _(e.indexOf(p.tabs[w.current])) }); let j = { ref: h }; return Q.createElement(u7, null, Q.createElement(ci.Provider, { value: k }, Q.createElement(cr.Provider, { value: v }, v.tabs.length <= 0 && Q.createElement(uH, { onFocus: () => { var e, t; for (let n of g.current) if ((null == (e = n.current) ? void 0 : e.tabIndex) === 0) return null == (t = n.current) || t.focus(), !0; return !1 } }), uP({ ourProps: j, theirProps: o, slot: m, defaultTag: cl, name: "Tabs" })))) } let cc = "div"; function cd (e, t) { let { orientation: n, selectedIndex: r } = ca("Tab.List"); return uP({ ourProps: { ref: uC(t), role: "tablist", "aria-orientation": n }, theirProps: e, slot: { selectedIndex: r }, defaultTag: cc, name: "Tabs.List" }) } let ch = "button"; function cp (e, t) { var n, r; let a = uj(), { id: i = "headlessui-tabs-tab-".concat(a), ...s } = e, { orientation: o, activation: l, selectedIndex: u, tabs: c, panels: d } = ca("Tab"), h = cs("Tab"), p = ca("Tab"), f = (0, Q.useRef)(null), m = uC(f, t); uy(() => h.registerTab(f), [h, f]); let x = u9("tabs"), g = c.indexOf(f); -1 === g && (g = x); let v = g === u, y = u_(e => { var t; let n = e(); if (n === uG.Success && "auto" === l) { let e = null == (t = u4(f)) ? void 0 : t.activeElement, n = p.tabs.findIndex(t => t.current === e); -1 !== n && h.change(n) } return n }), b = u_(e => { let t = c.map(e => e.current).filter(Boolean); if (e.key === up.Space || e.key === up.Enter) { e.preventDefault(), e.stopPropagation(), h.change(g); return } switch (e.key) { case up.Home: case up.PageUp: return e.preventDefault(), e.stopPropagation(), y(() => u1(t, uB.First)); case up.End: case up.PageDown: return e.preventDefault(), e.stopPropagation(), y(() => u1(t, uB.Last)) }if (y(() => uI(o, { vertical: () => e.key === up.ArrowUp ? u1(t, uB.Previous | uB.WrapAround) : e.key === up.ArrowDown ? u1(t, uB.Next | uB.WrapAround) : uG.Error, horizontal: () => e.key === up.ArrowLeft ? u1(t, uB.Previous | uB.WrapAround) : e.key === up.ArrowRight ? u1(t, uB.Next | uB.WrapAround) : uG.Error })) === uG.Success) return e.preventDefault() }), _ = (0, Q.useRef)(!1), w = u_(() => { var e; _.current || (_.current = !0, null == (e = f.current) || e.focus({ preventScroll: !0 }), h.change(g), u2(() => { _.current = !1 })) }), k = u_(e => { e.preventDefault() }), j = (0, Q.useMemo)(() => { var t; return { selected: v, disabled: null != (t = e.disabled) && t } }, [v, e.disabled]); return uP({ ourProps: { ref: m, onKeyDown: b, onMouseDown: k, onClick: w, id: i, role: "tab", type: uO(e, f), "aria-controls": null == (r = null == (n = d[g]) ? void 0 : n.current) ? void 0 : r.id, "aria-selected": v, tabIndex: v ? 0 : -1 }, theirProps: s, slot: j, defaultTag: ch, name: "Tabs.Tab" }) } let cf = "div"; function cm (e, t) { let { selectedIndex: n } = ca("Tab.Panels"); return uP({ ourProps: { ref: uC(t) }, theirProps: e, slot: (0, Q.useMemo)(() => ({ selectedIndex: n }), [n]), defaultTag: cf, name: "Tabs.Panels" }) } let cx = "div", cg = uA.RenderStrategy | uA.Static; function cv (e, t) { var n, r, a, i; let s = uj(), { id: o = "headlessui-tabs-panel-".concat(s), tabIndex: l = 0, ...u } = e, { selectedIndex: c, tabs: d, panels: h } = ca("Tab.Panel"), p = cs("Tab.Panel"), f = (0, Q.useRef)(null), m = uC(f, t); uy(() => p.registerPanel(f), [p, f, o]); let x = u9("panels"), g = h.indexOf(f); -1 === g && (g = x); let v = g === c, y = (0, Q.useMemo)(() => ({ selected: v }), [v]), b = { ref: m, id: o, role: "tabpanel", "aria-labelledby": null == (r = null == (n = d[g]) ? void 0 : n.current) ? void 0 : r.id, tabIndex: v ? l : -1 }; return v || null != (a = u.unmount) && !a || null != (i = u.static) && i ? uP({ ourProps: b, theirProps: u, slot: y, defaultTag: cx, features: cg, visible: v, name: "Tabs.Panel" }) : Q.createElement(uW, { as: "span", "aria-hidden": "true", ...b }) } let cy = Object.assign(uD(cp), { Group: uD(cu), List: uD(cd), Panels: uD(cm), Panel: uD(cv) }); function cb (e) { return !!e && "object" == typeof e && "label" in e } Object.assign(function ({ items: e, selectedIndex: t, defaultIndex: n = 0, onChange: r, children: a, storageKey: i }) { let [s, o] = (0, Q.useState)(n); (0, Q.useEffect)(() => { void 0 !== t && o(t) }, [t]), (0, Q.useEffect)(() => { if (!i) return; function e (e) { e.key === i && o(Number(e.newValue)) } let t = Number(localStorage.getItem(i)); return o(Number.isNaN(t) ? 0 : t), window.addEventListener("storage", e), () => { window.removeEventListener("storage", e) } }, []); let l = (0, Q.useCallback)(e => { if (i) { let t = String(e); localStorage.setItem(i, t), window.dispatchEvent(new StorageEvent("storage", { key: i, newValue: t })); return } o(e), r?.(e) }, []); return (0, eu.jsxs)(cy.Group, { selectedIndex: s, defaultIndex: n, onChange: l, children: [(0, eu.jsx)("div", { className: "nextra-scrollbar nx-overflow-x-auto nx-overflow-y-hidden nx-overscroll-x-contain", children: (0, eu.jsx)(cy.List, { className: "nx-mt-4 nx-flex nx-w-max nx-min-w-full nx-border-b nx-border-gray-200 nx-pb-px dark:nx-border-neutral-800", children: e.map((e, t) => { let n = cb(e) && e.disabled; return (0, eu.jsx)(cy, { disabled: n, className: ({ selected: e }) => ul("nx-mr-2 nx-rounded-t nx-p-2 nx-font-medium nx-leading-5 nx-transition-colors", "-nx-mb-0.5 nx-select-none nx-border-b-2", e ? "nx-border-primary-500 nx-text-primary-600" : "nx-border-transparent nx-text-gray-600 hover:nx-border-gray-200 hover:nx-text-black dark:nx-text-gray-200 dark:hover:nx-border-neutral-800 dark:hover:nx-text-white", n && "nx-pointer-events-none nx-text-gray-400 dark:nx-text-neutral-600"), children: cb(e) ? e.label : e }, t) }) }) }), (0, eu.jsx)(cy.Panels, { children: a })] }) }, { displayName: "Tabs", Tab: function ({ children: e, ...t }) { return (0, eu.jsx)(cy.Panel, { ...t, className: "nx-rounded nx-pt-6", children: e }) } }); var c_ = ({ className: e = "", ...t }) => (0, eu.jsx)("td", { className: ul("nx-m-0 nx-border nx-border-gray-300 nx-px-4 nx-py-2 dark:nx-border-gray-600", e), ...t }), cw = ({ className: e = "", ...t }) => (0, eu.jsx)("table", { className: ul("nx-block nx-overflow-x-scroll", e), ...t }), ck = ({ className: e = "", ...t }) => (0, eu.jsx)("th", { className: ul("nx-m-0 nx-border nx-border-gray-300 nx-px-4 nx-py-2 nx-font-semibold dark:nx-border-gray-600", e), ...t }), cj = ({ className: e = "", ...t }) => (0, eu.jsx)("tr", { className: ul("nx-m-0 nx-border-t nx-border-gray-300 nx-p-0 dark:nx-border-gray-600", "even:nx-bg-gray-100 even:dark:nx-bg-gray-600/20", e), ...t }), cE = { cards: ul("nextra-cards nx-mt-4 nx-gap-4 nx-grid", "nx-not-prose"), card: ul("nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200", "nx-text-current nx-no-underline dark:nx-shadow-none", "hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100", "active:nx-shadow-sm active:nx-shadow-gray-200", "nx-transition-all nx-duration-200 hover:nx-border-gray-300"), title: ul("nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900") }, cO = (0, eu.jsx)("span", { className: "nx-transition-transform nx-duration-75 group-hover:nx-translate-x-[2px]", children: "→" }); Object.assign(function ({ children: e, num: t = 3, className: n, style: r, ...a }) { return (0, eu.jsx)("div", { className: ul(cE.cards, n), ...a, style: { ...r, "--rows": t }, children: e }) }, { displayName: "Cards", Card: function ({ children: e, title: t, icon: n, image: r, arrow: a, href: i, ...s }) { let o = a ? cO : null; return r ? (0, eu.jsxs)(el(), { href: i, className: ul(cE.card, "nx-bg-gray-100 nx-shadow dark:nx-border-neutral-700 dark:nx-bg-neutral-800 dark:nx-text-gray-50 hover:nx-shadow-lg dark:hover:nx-border-neutral-500 dark:hover:nx-bg-neutral-700"), ...s, children: [e, (0, eu.jsxs)("span", { className: ul(cE.title, "dark:nx-text-gray-300 dark:hover:nx-text-gray-100"), children: [n, (0, eu.jsxs)("span", { className: "nx-flex nx-gap-1", children: [t, o] })] })] }) : (0, eu.jsx)(el(), { href: i, className: ul(cE.card, "nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900"), ...s, children: (0, eu.jsxs)("span", { className: ul(cE.title, "dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center"), children: [n, t, o] }) }) } }); var cT = (0, Q.createContext)(0); function cC () { return (0, Q.useContext)(cT) } function cS ({ children: e }) { return (0, eu.jsx)("div", { className: ul("nextra-filetree nx-mt-6 nx-select-none nx-text-sm nx-text-gray-800 dark:nx-text-gray-300", "nx-not-prose"), children: (0, eu.jsx)("div", { className: "nx-inline-block nx-rounded-lg nx-border nx-px-4 nx-py-2 dark:nx-border-neutral-800", children: e }) }) } function cN () { let e = cC(); return (0, eu.jsx)(eu.Fragment, { children: Array.from({ length: e }, (e, t) => (0, eu.jsx)("span", { className: "nx-w-5" }, t)) }) } var cI = (0, Q.memo)(({ label: e, name: t, open: n, children: r, defaultOpen: a = !1, onToggle: i }) => { let s = cC(), [o, l] = (0, Q.useState)(a), u = (0, Q.useCallback)(() => { i?.(!o), l(!o) }, [o, i]), c = void 0 === n ? o : n; return (0, eu.jsxs)("li", { className: "nx-flex nx-list-none nx-flex-col", children: [(0, eu.jsxs)("button", { onClick: u, title: t, className: "nx-inline-flex nx-cursor-pointer nx-items-center nx-py-1 hover:nx-opacity-60", children: [(0, eu.jsx)(cN, {}), (0, eu.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", children: (0, eu.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: c ? "M5 19a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h4l2 2h4a2 2 0 0 1 2 2v1M5 19h14a2 2 0 0 0 2-2v-5a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v5a2 2 0 0 1-2 2Z" : "M3 7v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-6l-2-2H5a2 2 0 0 0-2 2Z" }) }), (0, eu.jsx)("span", { className: "nx-ml-1", children: e ?? t })] }), c && (0, eu.jsx)("ul", { children: (0, eu.jsx)(cT.Provider, { value: s + 1, children: r }) })] }) }); cI.displayName = "Folder"; var cA = (0, Q.memo)(({ label: e, name: t, active: n }) => (0, eu.jsx)("li", { className: ul("nx-flex nx-list-none", n && "nx-text-primary-600 contrast-more:nx-underline"), children: (0, eu.jsxs)("span", { className: "nx-inline-flex nx-cursor-default nx-items-center nx-py-1", children: [(0, eu.jsx)(cN, {}), (0, eu.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", children: (0, eu.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12h6m-6 4h6m2 5H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5.586a1 1 0 0 1 .707.293l5.414 5.414a1 1 0 0 1 .293.707V19a2 2 0 0 1-2 2Z" }) }), (0, eu.jsx)("span", { className: "nx-ml-1", children: e ?? t })] }) })); cA.displayName = "File", Object.assign(cS, { Folder: cI, File: cA }); var cR = Object.defineProperty, cP = Object.defineProperties, cM = Object.getOwnPropertyDescriptors, cL = Object.getOwnPropertySymbols, cZ = Object.prototype.hasOwnProperty, cD = Object.prototype.propertyIsEnumerable, cF = (e, t, n) => t in e ? cR(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, cz = (e, t) => { for (var n in t || (t = {})) cZ.call(t, n) && cF(e, n, t[n]); if (cL) for (var n of cL(t)) cD.call(t, n) && cF(e, n, t[n]); return e }, c$ = (e, t) => cP(e, cM(t)), cU = (e, t) => { var n = {}; for (var r in e) cZ.call(e, r) && 0 > t.indexOf(r) && (n[r] = e[r]); if (null != e && cL) for (var r of cL(e)) 0 > t.indexOf(r) && cD.call(e, r) && (n[r] = e[r]); return n }, cW = (e, t, n) => new Promise((r, a) => { var i = e => { try { o(n.next(e)) } catch (e) { a(e) } }, s = e => { try { o(n.throw(e)) } catch (e) { a(e) } }, o = e => e.done ? r(e.value) : Promise.resolve(e.value).then(i, s); o((n = n.apply(e, t)).next()) }), cH = (0, Q.createContext)({}), cV = (0, Q.createContext)(e => e), cB = (0, Q.createContext)(null), cG = new WeakMap, cq = (0, Q.createContext)(cG), cK = () => (0, Q.useContext)(cH), cQ = () => (0, Q.useContext)(cV), cY = () => (0, Q.useContext)(cB), cJ = () => (0, Q.useContext)(cq), cX = ({ children: e }) => { let [t, n] = (0, Q.useState)({}), r = (0, Q.useRef)(null); return d6 && !r.current && (r.current = new IntersectionObserver(e => { n(t => { let n = cz({}, t); for (let t of e) if ((null == t ? void 0 : t.rootBounds) && cG.has(t.target)) { let [e, r] = cG.get(t.target), a = t.boundingClientRect.y + t.boundingClientRect.height <= t.rootBounds.y + t.rootBounds.height, i = t.intersectionRatio > 0; n[e] = { index: r, aboveHalfViewport: a, insideHalfViewport: i } } let r = "", a = 1 / 0, i = -1; for (let e in n) n[e].isActive = !1, n[e].insideHalfViewport && n[e].index < a && (a = n[e].index, r = e), a === 1 / 0 && n[e].aboveHalfViewport && n[e].index > i && (i = n[e].index, r = e); return n[r] && (n[r].isActive = !0), n }) }, { rootMargin: "0px 0px -50%", threshold: [0, 1] })), (0, eu.jsx)(cH.Provider, { value: t, children: (0, eu.jsx)(cV.Provider, { value: n, children: (0, eu.jsx)(cq.Provider, { value: cG, children: (0, eu.jsx)(cB.Provider, { value: r.current, children: e }) }) }) }) }, c0 = (0, Q.createContext)({ menu: !1, setMenu: () => !1 }), c1 = () => (0, Q.useContext)(c0), c2 = c0.Provider, c4 = (0, Q.createContext)(cz({ title: "", frontMatter: {} }, hi)); function c3 () { return (0, Q.useContext)(c4) } var c5 = ({ children: e, value: { themeConfig: t, pageOpts: n } }) => { let [r, a] = (0, Q.useState)(!1); K || (K = cz(cz({}, hi), Object.fromEntries(Object.entries(t).map(([e, t]) => [e, t && "object" == typeof t && hs.includes(e) ? cz(cz({}, hi[e]), t) : t])))); let i = c$(cz(c$(cz({}, K), { flexsearch: n.flexsearch }), "boolean" == typeof n.newNextLinkBehavior && { newNextLinkBehavior: n.newNextLinkBehavior }), { title: n.title, frontMatter: n.frontMatter }), { nextThemes: s } = i; return (0, eu.jsx)(ex, { attribute: "class", disableTransitionOnChange: !0, defaultTheme: s.defaultTheme, storageKey: s.storageKey, forcedTheme: s.forcedTheme, children: (0, eu.jsx)(c4.Provider, { value: i, children: (0, eu.jsx)(c2, { value: { menu: r, setMenu: a }, children: e }) }) }) }, c7 = (0, Q.createContext)(e => e), c9 = () => (0, Q.useContext)(c7), c6 = c7.Provider, c8 = Number(es.split(".")[0]), de = (0, Q.forwardRef)(function (e, t) { var n = e, { href: r = "", children: a, newWindow: i } = n, s = cU(n, ["href", "children", "newWindow"]); let o = c3(); return i ? (0, eu.jsxs)("a", c$(cz({ ref: t, href: r, target: "_blank", rel: "noreferrer" }, s), { children: [a, (0, eu.jsx)("span", { className: "nx-sr-only", children: " (opens in a new tab)" })] })) : r ? c8 > 12 || o.newNextLinkBehavior ? (0, eu.jsx)(el(), c$(cz({ ref: t, href: r }, s), { children: a })) : (0, eu.jsx)(el(), { href: r, passHref: !0, children: (0, eu.jsx)("a", c$(cz({ ref: t }, s), { children: a })) }) : (0, eu.jsx)("a", c$(cz({ ref: t }, s), { children: a })) }); de.displayName = "Anchor"; var dt = ({ repository: e = "", title: t, labels: n }) => { let r = n1()(e); if (!r) throw Error("Invalid `docsRepositoryBase` URL!"); return r.resource.includes("gitlab") ? `${r.protocol}://${r.resource}/${r.owner}/${r.name}/-/issues/new?issue[title]=${encodeURIComponent(t)}` : r.resource.includes("github") ? `${r.protocol}://${r.resource}/${r.owner}/${r.name}/issues/new?title=${encodeURIComponent(t)}&labels=${n || ""}` : "#" }; function dn (e, t) { return e ? "function" != typeof e ? e : (0, eu.jsx)(e, cz({}, t)) : null } function dr (e, t = {}) { return ("function" == typeof e ? e(t) : e) || "" } function da (e) { let t = (0, Q.useRef)(null), n = (0, Q.useRef)(null), r = (0, Q.useRef)(), a = (0, Q.useCallback)(() => { var a; t.current && n.current && (null == (a = r.current) || a.call(r), r.current = ac(t.current, n.current, e).destroy) }, [t, n, r, e]); return (0, Q.useMemo)(() => [e => { t.current = e, a() }, e => { n.current = e, a() }], [t, n, a]) } function di (e = "") { let t = c3(), n = n1()(t.docsRepositoryBase || ""); if (!n) throw Error("Invalid `docsRepositoryBase` URL!"); return `${n.href}/${e}` } function ds () { let { banner: e } = c3(); if (!e.text) return null; let t = `try{if(localStorage.getItem(${JSON.stringify(e.key)})==='0'){document.body.classList.add('nextra-banner-hidden')}}catch(e){}`; return (0, eu.jsxs)(eu.Fragment, { children: [(0, eu.jsx)("script", { dangerouslySetInnerHTML: { __html: t } }), (0, eu.jsxs)("div", { className: ee("nextra-banner-container nx-sticky nx-top-0 nx-z-20 nx-flex nx-items-center md:nx-relative", "nx-h-[var(--nextra-banner-height)] [body.nextra-banner-hidden_&]:nx-hidden", "nx-text-slate-50 dark:nx-text-white nx-bg-neutral-900 dark:nx-bg-[linear-gradient(1deg,#383838,#212121)]", "nx-px-2 ltr:nx-pl-10 rtl:nx-pr-10 print:nx-hidden"), children: [(0, eu.jsx)("div", { className: "nx-w-full nx-truncate nx-px-4 nx-text-center nx-font-medium nx-text-sm", children: dn(e.text) }), e.dismissible && (0, eu.jsx)("button", { type: "button", "aria-label": "Dismiss banner", className: "nx-w-8 nx-h-8 nx-opacity-80 hover:nx-opacity-100", onClick: () => { try { localStorage.setItem(e.key, "0") } catch (e) { } document.body.classList.add("nextra-banner-hidden") }, children: (0, eu.jsx)(nX, { className: "nx-mx-auto nx-h-4 nx-w-4" }) })] })] }) } function dl ({ full: e, children: t }) { return (0, eu.jsx)("div", { className: ee("nextra-bleed nx-relative -nx-mx-6 nx-mt-6 md:-nx-mx-8 2xl:-nx-mx-24", e && ["ltr:xl:nx-ml-[calc(50%-50vw+16rem)] ltr:xl:nx-mr-[calc(50%-50vw)]", "rtl:xl:nx-ml-[calc(50%-50vw)] rtl:xl:nx-mr-[calc(50%-50vw+16rem)]"]), children: t }) } function du ({ activePath: e }) { return (0, eu.jsx)("div", { className: "nextra-breadcrumb nx-mt-1.5 nx-flex nx-items-center nx-gap-1 nx-overflow-hidden nx-text-sm nx-text-gray-500 contrast-more:nx-text-current", children: e.map((t, n) => { let r = !t.children || t.withIndexPage, a = n === e.length - 1; return (0, eu.jsxs)(Q.Fragment, { children: [n > 0 && (0, eu.jsx)(nz, { className: "nx-w-3.5 nx-shrink-0" }), (0, eu.jsx)("div", { className: ee("nx-whitespace-nowrap nx-transition-colors", a ? "nx-font-medium nx-text-gray-700 contrast-more:nx-font-bold contrast-more:nx-text-current dark:nx-text-gray-400 contrast-more:dark:nx-text-current" : ["nx-min-w-[24px] nx-overflow-hidden nx-text-ellipsis", r && "hover:nx-text-gray-900 dark:hover:nx-text-gray-200"]), title: t.title, children: r && !a ? (0, eu.jsx)(de, { href: t.route, children: t.title }) : t.title })] }, t.route + t.name) }) }) } var dc = { default: "\uD83D\uDCA1", error: "\uD83D\uDEAB", info: (0, eu.jsx)(nG, { className: "nx-mt-1" }), warning: "⚠️" }, dd = { default: ee("nx-border-orange-100 nx-bg-orange-50 nx-text-orange-800 dark:nx-border-orange-400/30 dark:nx-bg-orange-400/20 dark:nx-text-orange-300"), error: ee("nx-border-red-200 nx-bg-red-100 nx-text-red-900 dark:nx-border-red-200/30 dark:nx-bg-red-900/30 dark:nx-text-red-200"), info: ee("nx-border-blue-200 nx-bg-blue-100 nx-text-blue-900 dark:nx-border-blue-200/30 dark:nx-bg-blue-900/30 dark:nx-text-blue-200"), warning: ee("nx-border-yellow-100 nx-bg-yellow-50 nx-text-yellow-900 dark:nx-border-yellow-200/30 dark:nx-bg-yellow-700/30 dark:nx-text-yellow-200") }; function dh ({ children: e, type: t = "default", emoji: n = dc[t] }) { return (0, eu.jsxs)("div", { className: ee("nextra-callout nx-overflow-x-auto nx-mt-6 nx-flex nx-rounded-lg nx-border nx-py-2 ltr:nx-pr-4 rtl:nx-pl-4", "contrast-more:nx-border-current contrast-more:dark:nx-border-current", dd[t]), children: [(0, eu.jsx)("div", { className: "nx-select-none nx-text-xl ltr:nx-pl-3 ltr:nx-pr-2 rtl:nx-pr-3 rtl:nx-pl-2", style: { fontFamily: '"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"' }, children: n }), (0, eu.jsx)("div", { className: "nx-w-full nx-min-w-0 nx-leading-7", children: e })] }) } function dp ({ children: e, className: t, isOpen: n, horizontal: r = !1 }) { let a = (0, Q.useRef)(null), i = (0, Q.useRef)(null), s = (0, Q.useRef)(0), o = (0, Q.useRef)(n), l = (0, Q.useRef)(!0); return (0, Q.useEffect)(() => { let e = a.current, t = i.current, o = s.current; o && clearTimeout(o), !l.current && e && t && (e.classList.toggle("nx-duration-500", !n), e.classList.toggle("nx-duration-300", n), r ? (t.style.width = `${t.clientWidth}px`, e.style.width = `${t.clientWidth}px`) : e.style.height = `${t.clientHeight}px`, n ? s.current = window.setTimeout(() => { e.style.removeProperty("height") }, 300) : setTimeout(() => { r ? e.style.width = "0px" : e.style.height = "0px" }, 0)) }, [r, n]), (0, Q.useEffect)(() => { l.current = !1 }, []), (0, eu.jsx)("div", { ref: a, className: "nx-transform-gpu nx-overflow-hidden nx-transition-all nx-ease-in-out motion-reduce:nx-transition-none", style: o.current || r ? void 0 : { height: 0 }, children: (0, eu.jsx)("div", { ref: i, className: ee("nx-transition-opacity nx-duration-500 nx-ease-in-out motion-reduce:nx-transition-none", n ? "nx-opacity-100" : "nx-opacity-0", t), children: e }) }) } ee("nextra-cards nx-mt-4 nx-gap-4 nx-grid"), ee("nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200", "nx-text-current nx-no-underline dark:nx-shadow-none", "hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100", "active:nx-shadow-sm active:nx-shadow-gray-200", "nx-transition-all nx-duration-200 hover:nx-border-gray-300"), ee("nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900"); var df = (0, Q.createContext)(0); function dm () { return (0, Q.useContext)(df) } var dx = ({ children: e }) => (0, eu.jsx)("div", { className: "nx-mt-6 nx-select-none nx-text-sm nx-text-gray-800 dark:nx-text-gray-300", children: (0, eu.jsx)("div", { className: "nx-inline-flex nx-flex-col nx-rounded-lg nx-border nx-px-4 nx-py-2 dark:nx-border-neutral-800", children: e }) }); function dg () { let e = dm(); return (0, eu.jsx)(eu.Fragment, { children: [...Array(e)].map((e, t) => (0, eu.jsx)("span", { className: "nx-inline-block nx-w-5" }, t)) }) } var dv = (0, Q.memo)(({ label: e, name: t, open: n, children: r, defaultOpen: a = !1, onToggle: i }) => { let s = dm(), [o, l] = (0, Q.useState)(a), u = (0, Q.useCallback)(() => { null == i || i(!o), l(!o) }, [o, i]), c = void 0 === n ? o : n; return (0, eu.jsxs)("li", { className: "nx-flex nx-list-none nx-flex-col", children: [(0, eu.jsxs)("a", { onClick: u, title: t, className: "nx-inline-flex nx-cursor-pointer nx-items-center nx-py-1 hover:nx-opacity-60", children: [(0, eu.jsx)(dg, {}), (0, eu.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", children: (0, eu.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: c ? "M5 19a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h4l2 2h4a2 2 0 0 1 2 2v1M5 19h14a2 2 0 0 0 2-2v-5a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v5a2 2 0 0 1-2 2Z" : "M3 7v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-6l-2-2H5a2 2 0 0 0-2 2Z" }) }), (0, eu.jsx)("span", { className: "nx-ml-1", children: null != e ? e : t })] }), c && (0, eu.jsx)("ul", { children: (0, eu.jsx)(df.Provider, { value: s + 1, children: r }) })] }) }); dv.displayName = "Folder"; var dy = (0, Q.memo)(({ label: e, name: t, active: n }) => (0, eu.jsx)("li", { className: ee("nx-flex nx-list-none", n && "nx-text-primary-600 contrast-more:nx-underline"), children: (0, eu.jsxs)("a", { className: "nx-inline-flex nx-cursor-default nx-items-center nx-py-1", children: [(0, eu.jsx)(dg, {}), (0, eu.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", children: (0, eu.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12h6m-6 4h6m2 5H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5.586a1 1 0 0 1 .707.293l5.414 5.414a1 1 0 0 1 .293.707V19a2 2 0 0 1-2 2Z" }) }), (0, eu.jsx)("span", { className: "nx-ml-1", children: null != e ? e : t })] }) })); dy.displayName = "File", Object.assign(dx, { Folder: dv, File: dy }); var db = (0, Q.forwardRef)((e, t) => { var n = e, { className: r, suffix: a } = n, i = cU(n, ["className", "suffix"]); return (0, eu.jsxs)("div", { className: "nx-relative nx-flex nx-items-center nx-text-gray-900 contrast-more:nx-text-gray-800 dark:nx-text-gray-300 contrast-more:dark:nx-text-gray-300", children: [(0, eu.jsx)("input", cz({ ref: t, spellCheck: !1, className: ee(r, "nx-block nx-w-full nx-appearance-none nx-rounded-lg nx-px-3 nx-py-2 nx-transition-colors", "nx-text-base nx-leading-tight md:nx-text-sm", "nx-bg-black/[.05] dark:nx-bg-gray-50/10", "focus:nx-bg-white dark:focus:nx-bg-dark", "placeholder:nx-text-gray-500 dark:placeholder:nx-text-gray-400", "contrast-more:nx-border contrast-more:nx-border-current") }, i)), a] }) }); db.displayName = "Input"; var d_ = ["input", "select", "button", "textarea"]; function dw ({ className: e, overlayClassName: t, value: n, onChange: r, onActive: a, loading: i, error: s, results: o }) { let [l, u] = (0, Q.useState)(!1), c = c3(), [d, h] = (0, Q.useState)(0), p = (0, J.useRouter)(), { setMenu: f } = c1(), m = (0, Q.useRef)(null), x = (0, Q.useRef)(null), [g, v] = (0, Q.useState)(!1); (0, Q.useEffect)(() => { h(0) }, [n]), (0, Q.useEffect)(() => { let e = e => { let t = document.activeElement, n = null == t ? void 0 : t.tagName.toLowerCase(); !m.current || !n || d_.includes(n) || null != t && t.isContentEditable || ("/" === e.key || "k" === e.key && (e.metaKey || e.ctrlKey) ? (e.preventDefault(), m.current.focus()) : "Escape" === e.key && (u(!1), m.current.blur())) }; return window.addEventListener("keydown", e), () => { window.removeEventListener("keydown", e) } }, []); let y = (0, Q.useCallback)(() => { var e; null == (e = m.current) || e.blur(), r(""), u(!1), f(!1) }, [r, f]), b = (0, Q.useCallback)(e => { let { index: t } = e.currentTarget.dataset; h(Number(t)) }, []), _ = (0, Q.useCallback)(function (e) { var t, n, r; switch (e.key) { case "ArrowDown": if (d + 1 < o.length) { let n = null == (t = x.current) ? void 0 : t.querySelector(`li:nth-of-type(${d + 2}) > a`); n && (e.preventDefault(), b({ currentTarget: n }), n.focus()) } break; case "ArrowUp": if (d - 1 >= 0) { let t = null == (n = x.current) ? void 0 : n.querySelector(`li:nth-of-type(${d}) > a`); t && (e.preventDefault(), b({ currentTarget: t }), t.focus()) } break; case "Enter": { let e = o[d]; e && (p.push(e.route), y()); break } case "Escape": u(!1), null == (r = m.current) || r.blur() } }, [d, o, p, y, b]), w = en(), k = l && !!n, j = (0, eu.jsx)(ii, { show: w && (!l || !!n), as: Q.Fragment, enter: "nx-transition-opacity", enterFrom: "nx-opacity-0", enterTo: "nx-opacity-100", leave: "nx-transition-opacity", leaveFrom: "nx-opacity-100", leaveTo: "nx-opacity-0", children: (0, eu.jsx)("kbd", { className: ee("nx-absolute nx-my-1.5 nx-select-none ltr:nx-right-1.5 rtl:nx-left-1.5", "nx-h-5 nx-rounded nx-bg-white nx-px-1.5 nx-font-mono nx-text-[10px] nx-font-medium nx-text-gray-500", "nx-border dark:nx-border-gray-100/20 dark:nx-bg-dark/50", "contrast-more:nx-border-current contrast-more:nx-text-current contrast-more:dark:nx-border-current", "nx-items-center nx-gap-1 nx-transition-opacity", n ? "nx-z-20 nx-flex nx-cursor-pointer hover:nx-opacity-70" : "nx-pointer-events-none nx-hidden sm:nx-flex"), title: n ? "Clear" : void 0, onClick: () => { r("") }, children: n && g ? "ESC" : w && (navigator.userAgent.includes("Macintosh") ? (0, eu.jsxs)(eu.Fragment, { children: [(0, eu.jsx)("span", { className: "nx-text-xs", children: "⌘" }), "K"] }) : "CTRL K") }) }); return (0, eu.jsxs)("div", { className: ee("nextra-search nx-relative md:nx-w-64", e), children: [k && (0, eu.jsx)("div", { className: "nx-fixed nx-inset-0 nx-z-10", onClick: () => u(!1) }), (0, eu.jsx)(db, { ref: m, value: n, onChange: e => { let { value: t } = e.target; r(t), u(!!t) }, onFocus: () => { null == a || a(!0), v(!0) }, onBlur: () => { v(!1) }, type: "search", placeholder: dr(c.search.placeholder), onKeyDown: _, suffix: j }), (0, eu.jsx)(ii, { show: k, as: ii.Child, leave: "nx-transition-opacity nx-duration-100", leaveFrom: "nx-opacity-100", leaveTo: "nx-opacity-0", children: (0, eu.jsx)("ul", { className: ee("nextra-scrollbar", "nx-border nx-border-gray-200 nx-bg-white nx-text-gray-100 dark:nx-border-neutral-800 dark:nx-bg-neutral-900", "nx-absolute nx-top-full nx-z-20 nx-mt-2 nx-overflow-auto nx-overscroll-contain nx-rounded-xl nx-py-2.5 nx-shadow-xl", "nx-max-h-[min(calc(50vh-11rem-env(safe-area-inset-bottom)),400px)]", "md:nx-max-h-[min(calc(100vh-5rem-env(safe-area-inset-bottom)),400px)]", "nx-inset-x-0 ltr:md:nx-left-auto rtl:md:nx-right-auto", "contrast-more:nx-border contrast-more:nx-border-gray-900 contrast-more:dark:nx-border-gray-50", t), ref: x, style: { transition: "max-height .2s ease" }, children: s ? (0, eu.jsxs)("span", { className: "nx-flex nx-select-none nx-justify-center nx-gap-2 nx-p-8 nx-text-center nx-text-sm nx-text-red-500", children: [(0, eu.jsx)(nG, { className: "nx-h-5 nx-w-5" }), dr(c.search.error)] }) : i ? (0, eu.jsxs)("span", { className: "nx-flex nx-select-none nx-justify-center nx-gap-2 nx-p-8 nx-text-center nx-text-sm nx-text-gray-400", children: [(0, eu.jsx)(nQ, { className: "nx-h-5 nx-w-5 nx-animate-spin" }), dr(c.search.loading)] }) : o.length > 0 ? o.map(({ route: e, prefix: t, children: n, id: r }, a) => (0, eu.jsxs)(Q.Fragment, { children: [t, (0, eu.jsx)("li", { className: ee("nx-mx-2.5 nx-break-words nx-rounded-md", "contrast-more:nx-border", a === d ? "nx-bg-primary-500/10 nx-text-primary-600 contrast-more:nx-border-primary-500" : "nx-text-gray-800 contrast-more:nx-border-transparent dark:nx-text-gray-300"), children: (0, eu.jsx)(de, { className: "nx-block nx-scroll-m-12 nx-px-2.5 nx-py-2", href: e, "data-index": a, onFocus: b, onMouseMove: b, onClick: y, onKeyDown: _, children: n }) })] }, r)) : dn(c.search.emptyResult) }) })] }) } var dk = (0, Q.memo)(function ({ value: e, match: t }) { let n; let r = e ? e.split("") : [], a = RegExp("(" + t.trim().replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll(" ", "|") + ")", "ig"), i = 0, s = 0, o = []; if (e) for (; null !== (n = a.exec(e));)o.push((0, eu.jsxs)(Q.Fragment, { children: [r.splice(0, n.index - s).join(""), (0, eu.jsx)("span", { className: "nx-text-primary-600", children: r.splice(0, a.lastIndex - n.index).join("") })] }, i++)), s = a.lastIndex; return (0, eu.jsxs)(eu.Fragment, { children: [o, r.join("")] }) }), dj = {}, dE = new Map, dO = (e, t) => { let n = e + "@" + t; if (dE.has(n)) return dE.get(n); let r = dT(e, t); return dE.set(n, r), r }, dT = (e, t) => cW(void 0, null, function* () { let n = yield fetch(`${e}/_next/static/chunks/nextra-data-${t}.json`), r = yield n.json(), a = new (ah()).Document({ cache: 100, tokenize: "full", document: { id: "id", index: "content", store: ["title"] }, context: { resolution: 9, depth: 2, bidirectional: !0 } }), i = new (ah()).Document({ cache: 100, tokenize: "full", document: { id: "id", index: "content", tag: "pageId", store: ["title", "content", "url", "display"] }, context: { resolution: 9, depth: 2, bidirectional: !0 } }), s = 0; for (let e in r) { let t = ""; for (let n in ++s, r[e].data) { let [a, o] = n.split("#"), l = e + (a ? "#" + a : ""), u = o || r[e].title, c = r[e].data[n] || "", d = c.split("\n").filter(Boolean); i.add(cz({ id: l, url: l, title: u, pageId: `page_${s}`, content: u }, d[0] && { display: d[0] })); for (let e = 0; e < d.length; e++)i.add({ id: `${l}_${e}`, url: l, title: u, pageId: `page_${s}`, content: d[e] }); t += ` ${u} ${c}` } a.add({ id: s, title: r[e].title, content: t }) } dj[t] = [a, i] }); function dC ({ className: e }) { let { locale: t = d9, basePath: n } = (0, J.useRouter)(), [r, a] = (0, Q.useState)(!1), [i, s] = (0, Q.useState)(!1), [o, l] = (0, Q.useState)([]), [u, c] = (0, Q.useState)(""), d = e => { var n, r; if (!e) return; let [a, i] = dj[t], s = (null == (n = a.search(e, 5, { enrich: !0, suggest: !0 })[0]) ? void 0 : n.result) || [], o = [], u = {}; for (let t = 0; t < s.length; t++) { let n = s[t]; u[t] = 0; let a = (null == (r = i.search(e, 5, { enrich: !0, suggest: !0, tag: `page_${n.id}` })[0]) ? void 0 : r.result) || [], l = !0, c = {}; for (let r = 0; r < a.length; r++) { let { doc: i } = a[r]; void 0 !== i.display && u[t]++; let { url: s, title: d } = i, h = i.display || i.content; c[s + "@" + h] || (c[s + "@" + h] = !0, o.push({ _page_rk: t, _section_rk: r, route: s, prefix: l && (0, eu.jsx)("div", { className: ee("nx-mx-2.5 nx-mb-2 nx-mt-6 nx-select-none nx-border-b nx-border-black/10 nx-px-2.5 nx-pb-1.5 nx-text-xs nx-font-semibold nx-uppercase nx-text-gray-500 first:nx-mt-0 dark:nx-border-white/20 dark:nx-text-gray-300", "contrast-more:nx-border-gray-600 contrast-more:nx-text-gray-900 contrast-more:dark:nx-border-gray-50 contrast-more:dark:nx-text-gray-50"), children: n.doc.title }), children: (0, eu.jsxs)(eu.Fragment, { children: [(0, eu.jsx)("div", { className: "nx-text-base nx-font-semibold nx-leading-5", children: (0, eu.jsx)(dk, { match: e, value: d }) }), h && (0, eu.jsx)("div", { className: "excerpt nx-mt-1 nx-text-sm nx-leading-[1.35rem] nx-text-gray-600 dark:nx-text-gray-400 contrast-more:dark:nx-text-gray-50", children: (0, eu.jsx)(dk, { match: e, value: h }) })] }) }), l = !1) } } l(o.sort((e, t) => e._page_rk === t._page_rk ? e._section_rk - t._section_rk : u[e._page_rk] !== u[t._page_rk] ? u[t._page_rk] - u[e._page_rk] : e._page_rk - t._page_rk).map(e => ({ id: `${e._page_rk}_${e._section_rk}`, route: e.route, prefix: e.prefix, children: e.children }))) }, h = (0, Q.useCallback)(e => cW(this, null, function* () { if (e && !dj[t]) { a(!0); try { yield dO(n, t) } catch (e) { s(!0) } a(!1) } }), [t, n]), p = e => cW(this, null, function* () { if (c(e), !r) { if (!dj[t]) { a(!0); try { yield dO(n, t) } catch (e) { s(!0) } a(!1) } d(e) } }); return (0, eu.jsx)(dw, { loading: r, error: i, value: u, onChange: p, onActive: h, className: e, overlayClassName: "nx-w-screen nx-min-h-[100px] nx-max-w-[min(calc(100vw-2rem),calc(100%+20rem))]", results: o }) } function dS ({ options: e, selected: t, onChange: n, title: r, className: a }) { let [i, s] = da({ strategy: "fixed", placement: "top-start", modifiers: [{ name: "offset", options: { offset: [0, 10] } }, { name: "sameWidth", enabled: !0, fn ({ state: e }) { e.styles.popper.minWidth = `${e.rects.reference.width}px` }, phase: "beforeWrite", requires: ["computeStyles"] }] }); return (0, eu.jsx)(st, { value: t, onChange: n, children: ({ open: n }) => (0, eu.jsxs)(st.Button, { ref: i, title: r, className: ee("nx-h-7 nx-rounded-md nx-px-2 nx-text-left nx-text-xs nx-font-medium nx-text-gray-600 nx-transition-colors dark:nx-text-gray-400", n ? "nx-bg-gray-200 nx-text-gray-900 dark:nx-bg-primary-100/10 dark:nx-text-gray-50" : "hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50", a), children: [t.name, (0, eu.jsx)(dN, { children: (0, eu.jsx)(ii, { ref: s, show: n, as: st.Options, className: "nx-z-20 nx-max-h-64 nx-overflow-auto nx-rounded-md nx-ring-1 nx-ring-black/5 nx-bg-white nx-py-1 nx-text-sm nx-shadow-lg dark:nx-ring-white/20 dark:nx-bg-neutral-800", leave: "nx-transition-opacity", leaveFrom: "nx-opacity-100", leaveTo: "nx-opacity-0", children: e.map(e => (0, eu.jsxs)(st.Option, { value: e, className: ({ active: e }) => ee(e ? "nx-bg-primary-50 nx-text-primary-600 dark:nx-bg-primary-500/10" : "nx-text-gray-800 dark:nx-text-gray-100", "nx-relative nx-cursor-pointer nx-whitespace-nowrap nx-py-1.5", "nx-transition-colors ltr:nx-pl-3 ltr:nx-pr-9 rtl:nx-pr-3 rtl:nx-pl-9"), children: [e.name, e.key === t.key && (0, eu.jsx)("span", { className: "nx-absolute nx-inset-y-0 nx-flex nx-items-center ltr:nx-right-3 rtl:nx-left-3", children: (0, eu.jsx)(n$, {}) })] }, e.key)) }) })] }) }) } function dN (e) { return en() ? (0, sn.createPortal)(e.children, document.body) : null } function dI ({ options: e, lite: t, className: n }) { let { locale: r, asPath: a } = (0, J.useRouter)(), i = e.find(e => r === e.locale); return (0, eu.jsx)(dS, { title: "Change language", className: n, onChange: e => { let t = new Date(Date.now() + 31536e6); document.cookie = `NEXT_LOCALE=${e.key}; expires=${t.toUTCString()}; path=/`, location.href = (0, sr.addBasePath)(a) }, selected: { key: (null == i ? void 0 : i.locale) || "", name: (0, eu.jsxs)("span", { className: "nx-flex nx-items-center nx-gap-2", children: [(0, eu.jsx)(nB, {}), (0, eu.jsx)("span", { className: t ? "nx-hidden" : "", children: null == i ? void 0 : i.text })] }) }, options: e.map(e => ({ key: e.locale, name: e.text })) }) } function dA ({ menu: e }) { let t = c3(); return (0, eu.jsxs)("footer", { className: "nx-bg-gray-100 nx-pb-[env(safe-area-inset-bottom)] dark:nx-bg-neutral-900 print:nx-bg-transparent", children: [(0, eu.jsxs)("div", { className: ee("nx-mx-auto nx-flex nx-max-w-[90rem] nx-gap-2 nx-py-2 nx-px-4", e && (t.i18n.length > 0 || t.darkMode) ? "nx-flex" : "nx-hidden"), children: [t.i18n.length > 0 && (0, eu.jsx)(dI, { options: t.i18n }), t.darkMode && dn(t.themeSwitch.component)] }), (0, eu.jsx)("hr", { className: "dark:nx-border-neutral-800" }), (0, eu.jsx)("div", { className: ee("nx-mx-auto nx-flex nx-max-w-[90rem] nx-justify-center nx-py-12 nx-text-gray-600 dark:nx-text-gray-400 md:nx-justify-start", "nx-pl-[max(env(safe-area-inset-left),1.5rem)] nx-pr-[max(env(safe-area-inset-right),1.5rem)]"), children: dn(t.footer.text) })] }) } function dR () {
      var e; let t = c3(), { resolvedTheme: n } = em(), r = en(), a = "function" == typeof t.head ? t.head({}) : t.head, i = t.primaryHue, { dark: s, light: o } = "number" == typeof i ? { dark: i, light: i } : i, l = t.frontMatter; return (0, eu.jsxs)(eu.Fragment, {
        children: [(0, eu.jsx)(sf, cz({ title: t.title, description: l.description, canonical: l.canonical, openGraph: l.openGraph }, null == (e = t.useNextSeoProps) ? void 0 : e.call(t))), (0, eu.jsxs)(si(), {
          children: [t.faviconGlyph ? (0, eu.jsx)("link", { rel: "icon", href: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text x='50' y='.9em' font-size='90' text-anchor='middle'>${t.faviconGlyph}</text><style>text{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";fill:black}@media(prefers-color-scheme:dark){text{fill:white}}</style></svg>` }) : null, r ? (0, eu.jsx)("meta", { name: "theme-color", content: "dark" === n ? "#111" : "#fff" }) : (0, eu.jsxs)(eu.Fragment, { children: [(0, eu.jsx)("meta", { name: "theme-color", content: "#fff", media: "(prefers-color-scheme: light)" }), (0, eu.jsx)("meta", { name: "theme-color", content: "#111", media: "(prefers-color-scheme: dark)" })] }), (0, eu.jsx)("meta", { name: "viewport", content: "width=device-width, initial-scale=1.0, viewport-fit=cover" }), (0, eu.jsx)("style", {
            children: `
        :root {
          --nextra-primary-hue: ${o}deg;
          --nextra-navbar-height: 4rem;
          --nextra-menu-height: 3.75rem;
          --nextra-banner-height: 2.5rem;
        }
        
        .dark {
          --nextra-primary-hue: ${s}deg;
        }
      `}), a]
        })]
      })
    } var dP = { link: ee("nx-flex nx-max-w-[50%] nx-items-center nx-gap-1 nx-py-4 nx-text-base nx-font-medium nx-text-gray-600 nx-transition-colors [word-break:break-word] hover:nx-text-primary-600 dark:nx-text-gray-300 md:nx-text-lg"), icon: ee("nx-inline nx-h-5 nx-shrink-0") }, dM = ({ flatDirectories: e, currentIndex: t }) => { let n = c3().navigation, r = "boolean" == typeof n ? { prev: n, next: n } : n, a = r.prev && e[t - 1], i = r.next && e[t + 1]; return (a && !a.isUnderCurrentDocsTree && (a = !1), i && !i.isUnderCurrentDocsTree && (i = !1), a || i) ? (0, eu.jsxs)("div", { className: ee("nx-mb-8 nx-flex nx-items-center nx-border-t nx-pt-8 dark:nx-border-neutral-800", "contrast-more:nx-border-neutral-400 dark:contrast-more:nx-border-neutral-400", "print:nx-hidden"), children: [a && (0, eu.jsxs)(de, { href: a.route, title: a.title, className: ee(dP.link, "ltr:nx-pr-4 rtl:nx-pl-4"), children: [(0, eu.jsx)(nz, { className: ee(dP.icon, "ltr:nx-rotate-180") }), a.title] }), i && (0, eu.jsxs)(de, { href: i.route, title: i.title, className: ee(dP.link, "ltr:nx-ml-auto ltr:nx-pl-4 ltr:nx-text-right rtl:nx-mr-auto rtl:nx-pr-4 rtl:nx-text-left"), children: [i.title, (0, eu.jsx)(nz, { className: ee(dP.icon, "rtl:nx-rotate-180") })] })] }) : null }, dL = { link: ee("nx-text-sm contrast-more:nx-text-gray-700 contrast-more:dark:nx-text-gray-100"), active: ee("nx-font-medium nx-subpixel-antialiased"), inactive: ee("nx-text-gray-600 hover:nx-text-gray-800 dark:nx-text-gray-400 dark:hover:nx-text-gray-200") }; function dZ ({ className: e, menu: t, children: n }) { let { items: r } = t, a = Object.fromEntries((t.children || []).map(e => [e.name, e])); return (0, eu.jsx)("div", { className: "nx-relative nx-inline-block", children: (0, eu.jsxs)(sP, { children: [(0, eu.jsx)(sP.Button, { className: ee(e, "-nx-ml-2 nx-hidden nx-items-center nx-whitespace-nowrap nx-rounded nx-p-2 md:nx-inline-flex", dL.inactive), children: n }), (0, eu.jsx)(ii, { leave: "nx-transition-opacity", leaveFrom: "nx-opacity-100", leaveTo: "nx-opacity-0", children: (0, eu.jsx)(sP.Items, { className: "nx-absolute nx-right-0 nx-z-20 nx-mt-1 nx-max-h-64 nx-min-w-full nx-overflow-auto nx-rounded-md nx-ring-1 nx-ring-black/5 nx-bg-white nx-py-1 nx-text-sm nx-shadow-lg dark:nx-ring-white/20 dark:nx-bg-neutral-800", tabIndex: 0, children: Object.entries(r || {}).map(([e, n]) => { var r; return (0, eu.jsx)(sP.Item, { children: (0, eu.jsx)(de, { href: n.href || (null == (r = a[e]) ? void 0 : r.route) || t.route + "/" + e, className: ee("nx-relative nx-hidden nx-w-full nx-select-none nx-whitespace-nowrap nx-text-gray-600 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-100 md:nx-inline-block", "nx-py-1.5 nx-transition-colors ltr:nx-pl-3 ltr:nx-pr-9 rtl:nx-pr-3 rtl:nx-pl-9"), newWindow: n.newWindow, children: n.title || e }) }, e) }) }) })] }) }) } function dD ({ flatDirectories: e, items: t }) { let n = c3(), r = ei(), { menu: a, setMenu: i } = c1(); return (0, eu.jsxs)("div", { className: "nextra-nav-container nx-sticky nx-top-0 nx-z-20 nx-w-full nx-bg-transparent print:nx-hidden", children: [(0, eu.jsx)("div", { className: ee("nextra-nav-container-blur", "nx-pointer-events-none nx-absolute nx-z-[-1] nx-h-full nx-w-full nx-bg-white dark:nx-bg-dark", "nx-shadow-[0_2px_4px_rgba(0,0,0,.02),0_1px_0_rgba(0,0,0,.06)] dark:nx-shadow-[0_-1px_0_rgba(255,255,255,.1)_inset]", "contrast-more:nx-shadow-[0_0_0_1px_#000] contrast-more:dark:nx-shadow-[0_0_0_1px_#fff]") }), (0, eu.jsxs)("nav", { className: "nx-mx-auto nx-flex nx-h-[var(--nextra-navbar-height)] nx-max-w-[90rem] nx-items-center nx-justify-end nx-gap-2 nx-pl-[max(env(safe-area-inset-left),1.5rem)] nx-pr-[max(env(safe-area-inset-right),1.5rem)]", children: [n.logoLink ? (0, eu.jsx)(de, { href: "string" == typeof n.logoLink ? n.logoLink : "/", className: "nx-flex nx-items-center hover:nx-opacity-75 ltr:nx-mr-auto rtl:nx-ml-auto", children: dn(n.logo) }) : (0, eu.jsx)("div", { className: "nx-flex nx-items-center ltr:nx-mr-auto rtl:nx-ml-auto", children: dn(n.logo) }), t.map(e => { if ("hidden" === e.display) return null; if ("menu" === e.type) { let t = e, n = t.route === r || r.startsWith(t.route + "/"); return (0, eu.jsxs)(dZ, { className: ee(dL.link, "nx-flex nx-gap-1", n ? dL.active : dL.inactive), menu: t, children: [t.title, (0, eu.jsx)(nz, { className: "nx-h-[18px] nx-min-w-[18px] nx-rounded-sm nx-p-0.5", pathClassName: "nx-origin-center nx-transition-transform nx-rotate-90" })] }, t.title) } let t = e, n = t.href || t.route || "#"; t.children && (n = (t.withIndexPage ? t.route : t.firstChildRoute) || n); let a = t.route === r || r.startsWith(t.route + "/"); return (0, eu.jsxs)(de, { href: n, className: ee(dL.link, "nx-relative -nx-ml-2 nx-hidden nx-whitespace-nowrap nx-p-2 md:nx-inline-block", !a || t.newWindow ? dL.inactive : dL.active), newWindow: t.newWindow, "aria-current": !t.newWindow && a, children: [(0, eu.jsx)("span", { className: "nx-absolute nx-inset-x-0 nx-text-center", children: t.title }), (0, eu.jsx)("span", { className: "nx-invisible nx-font-medium", children: t.title })] }, n) }), dn(n.search.component, { directories: e, className: "nx-hidden md:nx-inline-block mx-min-w-[200px]" }), n.project.link ? (0, eu.jsx)(de, { className: "nx-p-2 nx-text-current", href: n.project.link, newWindow: !0, children: dn(n.project.icon) }) : null, n.chat.link ? (0, eu.jsx)(de, { className: "nx-p-2 nx-text-current", href: n.chat.link, newWindow: !0, children: dn(n.chat.icon) }) : null, dn(n.navbar.extraContent), (0, eu.jsx)("button", { type: "button", "aria-label": "Menu", className: "nextra-hamburger -nx-mr-2 nx-rounded nx-p-2 active:nx-bg-gray-400/20 md:nx-hidden", onClick: () => i(!a), children: (0, eu.jsx)(nq, { className: ee({ open: a }) }) })] })] }) } var dF = Object.create(null), dz = (0, Q.createContext)(null), d$ = (0, Q.createContext)(null), dU = (0, Q.createContext)(0), dW = (0, Q.memo)(function (e) { let t = (0, Q.useContext)(dU); return (0, eu.jsx)(dU.Provider, { value: t + 1, children: (0, eu.jsx)(dV, cz({}, e)) }) }), dH = { link: ee("nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word]", "nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border"), inactive: ee("nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900", "dark:nx-text-neutral-500 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50", "contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50", "contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50"), active: ee("nx-bg-primary-100 nx-font-semibold nx-text-primary-800 dark:nx-bg-primary-400/10 dark:nx-text-primary-600", "contrast-more:nx-border-primary-500 contrast-more:dark:nx-border-primary-500"), list: ee("nx-flex nx-flex-col nx-gap-1"), border: ee("nx-relative before:nx-absolute before:nx-inset-y-1", 'before:nx-w-px before:nx-bg-gray-200 before:nx-content-[""] dark:before:nx-bg-neutral-800', "ltr:nx-pl-3 ltr:before:nx-left-0 rtl:nx-pr-3 rtl:before:nx-right-0") }; function dV ({ item: e, anchors: t }) { let [n] = ei().split("#"), r = [n, n + "/"].includes(e.route + "/"), a = r || n.startsWith(e.route + "/"), i = (0, Q.useContext)(dz), s = !!(null == i ? void 0 : i.startsWith(e.route + "/")), o = (0, Q.useContext)(dU), { setMenu: l } = c1(), u = c3(), { theme: c } = e, d = void 0 === dF[e.route] ? r || a || s || (c && "collapsed" in c ? !c.collapsed : o < u.sidebar.defaultMenuCollapseLevel) : dF[e.route] || s, h = (0, Q.useState)({})[1]; if ((0, Q.useEffect)(() => { (a || s) && (dF[e.route] = !0) }, [a, s, e.route]), "menu" === e.type) { let t = e, n = Object.fromEntries((t.children || []).map(e => [e.name, e])); e.children = Object.entries(t.items || {}).map(([e, r]) => { let a = n[e] || c$(cz({ name: e }, "locale" in t && { locale: t.locale }), { route: t.route + "/" + e }); return cz(cz({}, a), r) }) } let p = "withIndexPage" in e && e.withIndexPage, f = p ? de : "button"; return (0, eu.jsxs)("li", { className: ee({ open: d, active: r }), children: [(0, eu.jsxs)(f, { href: p ? e.route : void 0, className: ee("nx-items-center nx-justify-between nx-gap-2", !p && "nx-text-left nx-w-full", dH.link, r ? dH.active : dH.inactive), onClick: t => { let n = ["svg", "path"].includes(t.target.tagName.toLowerCase()); if (n && t.preventDefault(), p) { r || n ? dF[e.route] = !d : (dF[e.route] = !0, l(!1)), h({}); return } r || (dF[e.route] = !d, h({})) }, children: [dn(u.sidebar.titleComponent, { title: e.title, type: e.type, route: e.route }), (0, eu.jsx)(nz, { className: "nx-h-[18px] nx-min-w-[18px] nx-rounded-sm nx-p-0.5 hover:nx-bg-gray-800/5 dark:hover:nx-bg-gray-100/5", pathClassName: ee("nx-origin-center nx-transition-transform rtl:-nx-rotate-180", d && "ltr:nx-rotate-90 rtl:nx-rotate-[-270deg]") })] }), (0, eu.jsx)(dp, { className: "ltr:nx-pr-0 rtl:nx-pl-0 nx-pt-1", isOpen: d, children: Array.isArray(e.children) ? (0, eu.jsx)(dq, { className: ee(dH.border, "ltr:nx-ml-3 rtl:nx-mr-3"), directories: e.children, base: e.route, anchors: t }) : null })] }) } function dB ({ title: e }) { let t = c3(); return (0, eu.jsx)("li", { className: ee("[word-break:break-word]", e ? "nx-mt-5 nx-mb-2 nx-px-2 nx-py-1.5 nx-text-sm nx-font-semibold nx-text-gray-900 first:nx-mt-0 dark:nx-text-gray-100" : "nx-my-4"), children: e ? dn(t.sidebar.titleComponent, { title: e, type: "separator", route: "" }) : (0, eu.jsx)("hr", { className: "nx-mx-2 nx-border-t nx-border-gray-200 dark:nx-border-primary-100/10" }) }) } function dG ({ item: e, anchors: t }) { let n = ei(), r = (0, Q.useContext)(d$), a = e.route && [n, n + "/"].includes(e.route + "/"), i = cK(), { setMenu: s } = c1(), o = c3(); return "separator" === e.type ? (0, eu.jsx)(dB, { title: e.title }) : (0, eu.jsxs)("li", { className: ee(dH.list, { active: a }), children: [(0, eu.jsx)(de, { href: e.href || e.route, newWindow: e.newWindow, className: ee(dH.link, a ? dH.active : dH.inactive), onClick: () => { s(!1) }, onFocus: () => { null == r || r(e.route) }, onBlur: () => { null == r || r(null) }, children: dn(o.sidebar.titleComponent, { title: e.title, type: e.type, route: e.route }) }), a && t.length > 0 && (0, eu.jsx)("ul", { className: ee(dH.list, dH.border, "ltr:nx-ml-3 rtl:nx-mr-3"), children: t.map(({ id: e, value: t }) => { var n; return (0, eu.jsx)("li", { children: (0, eu.jsx)("a", { href: `#${e}`, className: ee(dH.link, 'nx-flex nx-gap-2 before:nx-opacity-25 before:nx-content-["#"]', (null == (n = i[e]) ? void 0 : n.isActive) ? dH.active : dH.inactive), onClick: () => { s(!1) }, children: t }) }, e) }) })] }) } function dq ({ directories: e, anchors: t, className: n, onlyCurrentDocs: r }) { return (0, eu.jsx)("ul", { className: ee(dH.list, n), children: e.map(e => !r || e.isUnderCurrentDocsTree ? "menu" === e.type || e.children && (e.children.length || !e.withIndexPage) ? (0, eu.jsx)(dW, { item: e, anchors: t }, e.name) : (0, eu.jsx)(dG, { item: e, anchors: t }, e.name) : null) }) } function dK ({ docsDirectories: e, flatDirectories: t, fullDirectories: n, asPopover: r = !1, headings: a, includePlaceholder: i }) { let s = c3(), { menu: o, setMenu: l } = c1(), u = (0, J.useRouter)(), [c, d] = (0, Q.useState)(null), [h, p] = (0, Q.useState)(!0), [f, m] = (0, Q.useState)(!1), x = (0, Q.useMemo)(() => a.filter(e => 2 === e.depth), [a]), g = (0, Q.useRef)(null), v = (0, Q.useRef)(null); (0, Q.useEffect)(() => { o ? document.body.classList.add("nx-overflow-hidden", "md:nx-overflow-auto") : document.body.classList.remove("nx-overflow-hidden", "md:nx-overflow-auto") }, [o]), (0, Q.useEffect)(() => { var e; let t = null == (e = g.current) ? void 0 : e.querySelector("li.active"); if (t && (window.innerWidth > 767 || o)) { let e = () => { sU(t, { block: "center", inline: "center", scrollMode: "always", boundary: v.current }) }; o ? setTimeout(e, 300) : e() } }, [o]), (0, Q.useEffect)(() => { l(!1) }, [u.asPath, l]); let y = s.i18n.length > 0, b = s.darkMode || y; return (0, eu.jsxs)(eu.Fragment, { children: [i && r ? (0, eu.jsx)("div", { className: "max-xl:nx-hidden nx-h-0 nx-w-64 nx-shrink-0" }) : null, (0, eu.jsx)("div", { className: ee("motion-reduce:nx-transition-none [transition:background-color_1.5s_ease]", o ? "nx-fixed nx-inset-0 nx-z-10 nx-bg-black/80 dark:nx-bg-black/60" : "nx-bg-transparent"), onClick: () => l(!1) }), (0, eu.jsxs)("aside", { className: ee("nextra-sidebar-container nx-flex nx-flex-col", "md:nx-top-16 md:nx-shrink-0 motion-reduce:nx-transform-none", "nx-transform-gpu nx-transition-all nx-ease-in-out", "print:nx-hidden", h ? "md:nx-w-64" : "md:nx-w-20", r ? "md:nx-hidden" : "md:nx-sticky md:nx-self-start", o ? "max-md:[transform:translate3d(0,0,0)]" : "max-md:[transform:translate3d(0,-100%,0)]"), ref: v, children: [(0, eu.jsx)("div", { className: "nx-px-4 nx-pt-4 md:nx-hidden", children: dn(s.search.component, { directories: t }) }), (0, eu.jsx)(dz.Provider, { value: c, children: (0, eu.jsx)(d$.Provider, { value: e => { d(e) }, children: (0, eu.jsxs)("div", { className: ee("nx-overflow-y-auto nx-overflow-x-hidden", "nx-p-4 nx-grow md:nx-h-[calc(100vh-var(--nextra-navbar-height)-var(--nextra-menu-height))]", h ? "nextra-scrollbar" : "no-scrollbar"), ref: g, children: [(!r || !h) && (0, eu.jsx)(dp, { isOpen: h, horizontal: !0, children: (0, eu.jsx)(dq, { className: "max-md:nx-hidden", directories: e, anchors: s.toc.float ? [] : x, onlyCurrentDocs: !0 }) }), (0, eu.jsx)(dq, { className: "md:nx-hidden", directories: n, anchors: x })] }) }) }), b && (0, eu.jsxs)("div", { className: ee("nx-sticky nx-bottom-0", "nx-bg-white dark:nx-bg-dark", "nx-mx-4 nx-py-4 nx-shadow-[0_-12px_16px_#fff]", "nx-flex nx-items-center nx-gap-2", "dark:nx-border-neutral-800 dark:nx-shadow-[0_-12px_16px_#111]", "contrast-more:nx-border-neutral-400 contrast-more:nx-shadow-none contrast-more:dark:nx-shadow-none", h ? ee(y && "nx-justify-end", "nx-border-t") : "nx-py-4 nx-flex-wrap nx-justify-center"), "data-toggle-animation": f ? h ? "show" : "hide" : "off", children: [y && (0, eu.jsx)(dI, { options: s.i18n, lite: !h, className: ee(h ? "nx-grow" : "max-md:nx-grow") }), s.darkMode && (0, eu.jsx)("div", { className: h && !y ? "nx-grow nx-flex nx-flex-col" : "", children: dn(s.themeSwitch.component, { lite: !h || y }) }), s.sidebar.toggleButton && (0, eu.jsx)("button", { title: h ? "Hide sidebar" : "Show sidebar", className: "max-md:nx-hidden nx-h-7 nx-rounded-md nx-transition-colors nx-text-gray-600 dark:nx-text-gray-400 nx-px-2 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50", onClick: () => { p(!h), m(!0) }, children: (0, eu.jsx)(nH, { isOpen: h }) })] })] })] }) } var dQ = "reach-skip-nav", dY = "Skip to content"; (0, Q.forwardRef)(function (e, t) { var n = e, { className: r, id: a, label: i = dY, styled: s } = n, o = cU(n, ["className", "id", "label", "styled"]); let l = void 0 === r ? s ? ee("nx-sr-only", "focus:nx-not-sr-only focus:nx-fixed focus:nx-z-50 focus:nx-m-3 focus:nx-ml-4 focus:nx-h-[calc(var(--nextra-navbar-height)-1.5rem)] focus:nx-rounded-lg focus:nx-border focus:nx-px-3 focus:nx-py-2 focus:nx-align-middle focus:nx-text-sm focus:nx-font-bold", "focus:nx-text-gray-900 focus:dark:nx-text-gray-100", "focus:nx-bg-white focus:dark:nx-bg-neutral-900", "focus:nx-border-neutral-400 focus:dark:nx-border-neutral-800") : "" : r; return (0, eu.jsx)("a", c$(cz({}, o), { ref: t, href: `#${a || dQ}`, className: l, "data-reach-skip-link": "", children: i })) }).displayName = "SkipNavLink"; var dJ = (0, Q.forwardRef)(function (e, t) { var n = e, { id: r } = n, a = cU(n, ["id"]); return (0, eu.jsx)("div", c$(cz({}, a), { ref: t, id: r || dQ })) }); function dX (e) { return !!e && "object" == typeof e && "label" in e } dJ.displayName = "SkipNavContent"; var d0 = e => dX(e) ? e.label : e; function d1 ({ items: e, selectedIndex: t, defaultIndex: n, onChange: r, children: a }) { return (0, eu.jsxs)(oi.Group, { selectedIndex: t, defaultIndex: n, onChange: r, children: [(0, eu.jsx)("div", { className: "nextra-scrollbar nx-overflow-x-auto nx-overflow-y-hidden nx-overscroll-x-contain", children: (0, eu.jsx)(oi.List, { className: "nx-mt-4 nx-flex nx-w-max nx-min-w-full nx-border-b nx-border-gray-200 nx-pb-px dark:nx-border-neutral-800", children: e.map((e, t) => { let n = !!(e && "object" == typeof e && "disabled" in e && e.disabled); return (0, eu.jsx)(oi, { disabled: n, className: ({ selected: e }) => ee("nx-mr-2 nx-rounded-t nx-p-2 nx-font-medium nx-leading-5 nx-transition-colors", "-nx-mb-0.5 nx-select-none nx-border-b-2", e ? "nx-border-primary-500 nx-text-primary-600" : "nx-border-transparent nx-text-gray-600 hover:nx-border-gray-200 hover:nx-text-black dark:nx-text-gray-200 dark:hover:nx-border-neutral-800 dark:hover:nx-text-white", n && "nx-pointer-events-none nx-text-gray-400 dark:nx-text-neutral-600"), children: d0(e) }, t) }) }) }), (0, eu.jsx)(oi.Panels, { children: a })] }) } function d2 (e) { var t = e, { children: n } = t, r = cU(t, ["children"]); return (0, eu.jsx)(oi.Panel, c$(cz({}, r), { className: "nx-rounded nx-pt-6", children: n })) } var d4 = lX.strictObject({ light: lX.string(), dark: lX.string(), system: lX.string() }); function d3 ({ lite: e, className: t }) { let { setTheme: n, resolvedTheme: r, theme: a = "" } = em(), i = en(), s = c3().themeSwitch, o = i && "dark" === r ? nK : nY, l = "function" == typeof s.useOptions ? s.useOptions() : s.useOptions; return (0, eu.jsx)(dS, { className: t, title: "Change theme", options: [{ key: "light", name: l.light }, { key: "dark", name: l.dark }, { key: "system", name: l.system }], onChange: e => { n(e.key) }, selected: { key: a, name: (0, eu.jsxs)("div", { className: "nx-flex nx-items-center nx-gap-2 nx-capitalize", children: [(0, eu.jsx)(o, {}), (0, eu.jsx)("span", { className: e ? "md:nx-hidden" : "", children: i ? l[a] : l.light })] }) } }) } function d5 ({ headings: e, filePath: t }) { var n; let r = cK(), a = c3(), i = (0, Q.useRef)(null), s = (0, Q.useMemo)(() => e.filter(e => e.depth > 1), [e]), o = s.length > 0, l = !!(a.feedback.content || a.editLink.component || a.toc.extraContent), u = null == (n = Object.entries(r).find(([, { isActive: e }]) => e)) ? void 0 : n[0]; (0, Q.useEffect)(() => { var e; if (!u) return; let t = null == (e = i.current) ? void 0 : e.querySelector(`li > a[href="#${u}"]`); t && sU(t, { behavior: "smooth", block: "center", inline: "center", scrollMode: "always", boundary: i.current }) }, [u]); let c = ee("nx-text-xs nx-font-medium nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-100", "contrast-more:nx-text-gray-800 contrast-more:dark:nx-text-gray-50"); return (0, eu.jsxs)("div", { ref: i, className: ee("nextra-scrollbar nx-sticky nx-top-16 nx-overflow-y-auto nx-pr-4 nx-pt-6 nx-text-sm [hyphens:auto]", "nx-max-h-[calc(100vh-var(--nextra-navbar-height)-env(safe-area-inset-bottom))] ltr:-nx-mr-4 rtl:-nx-ml-4"), children: [o && (0, eu.jsxs)(eu.Fragment, { children: [(0, eu.jsx)("p", { className: "nx-mb-4 nx-font-semibold nx-tracking-tight", children: dn(a.toc.title) }), (0, eu.jsx)("ul", { children: s.map(({ id: e, value: t, depth: n }) => { var i, s, o, l; return (0, eu.jsx)("li", { className: "nx-my-2 nx-scroll-my-6 nx-scroll-py-6", children: (0, eu.jsx)("a", { href: `#${e}`, className: ee({ 2: "nx-font-semibold", 3: "ltr:nx-pl-4 rtl:nx-pr-4", 4: "ltr:nx-pl-8 rtl:nx-pr-8", 5: "ltr:nx-pl-12 rtl:nx-pr-12", 6: "ltr:nx-pl-16 rtl:nx-pr-16" }[n], "nx-inline-block", (null == (i = r[e]) ? void 0 : i.isActive) ? "nx-text-primary-600 nx-subpixel-antialiased contrast-more:!nx-text-primary-600" : "nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300", "contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words"), children: null != (l = null == (o = (s = a.toc).headingComponent) ? void 0 : o.call(s, { id: e, children: t })) ? l : t }) }, e) }) })] }), l && (0, eu.jsxs)("div", { className: ee(o && "nx-mt-8 nx-border-t nx-bg-white nx-pt-8 nx-shadow-[0_-12px_16px_white] dark:nx-bg-dark dark:nx-shadow-[0_-12px_16px_#111]", "nx-sticky nx-bottom-0 nx-flex nx-flex-col nx-items-start nx-gap-2 nx-pb-8 dark:nx-border-neutral-800", "contrast-more:nx-border-t contrast-more:nx-border-neutral-400 contrast-more:nx-shadow-none contrast-more:dark:nx-border-neutral-400"), children: [a.feedback.content ? (0, eu.jsx)(de, { className: c, href: a.feedback.useLink(), newWindow: !0, children: dn(a.feedback.content) }) : null, dn(a.editLink.component, { filePath: t, className: c, children: dn(a.editLink.text) }), dn(a.toc.extraContent)] })] }) } function d7 ({ className: e, directories: t }) { let [n, r] = (0, Q.useState)(""), a = (0, Q.useMemo)(() => n ? l5(t, n, { keys: ["title"] }).map(({ route: e, title: t }) => ({ id: e + t, route: e, children: (0, eu.jsx)(dk, { value: t, match: n }) })) : [], [n, t]); return (0, eu.jsx)(dw, { value: n, onChange: r, className: e, overlayClassName: "nx-w-full", results: a }) } var d9 = "en-US", d6 = "undefined" != typeof window; function d8 (e) { return null == e || ht(e) || he(e) || (0, Q.isValidElement)(e) } function he (e) { return "function" == typeof e } function ht (e) { return "string" == typeof e } var hn = lX.array(lX.strictObject({ direction: lX.enum(["ltr", "rtl"]).optional(), locale: lX.string(), text: lX.string() })), hr = [d8, { message: "Must be React.ReactNode or React.FC" }], ha = [he, { message: "Must be React.FC" }]; lX.strictObject({ banner: lX.strictObject({ dismissible: lX.boolean(), key: lX.string(), text: lX.custom(...hr).optional() }), chat: lX.strictObject({ icon: lX.custom(...hr), link: lX.string().startsWith("https://").optional() }), components: lX.record(lX.custom(...ha)).optional(), darkMode: lX.boolean(), direction: lX.enum(["ltr", "rtl"]), docsRepositoryBase: lX.string().startsWith("https://"), editLink: lX.strictObject({ component: lX.custom(...ha), text: lX.custom(...hr) }), faviconGlyph: lX.string().optional(), feedback: lX.strictObject({ content: lX.custom(...hr), labels: lX.string(), useLink: lX.function().returns(lX.string()) }), footer: lX.strictObject({ component: lX.custom(...hr), text: lX.custom(...hr) }), gitTimestamp: lX.custom(...hr), head: lX.custom(...hr), i18n: hn, logo: lX.custom(...hr), logoLink: lX.boolean().or(lX.string()), main: lX.custom(...ha).optional(), navbar: lX.strictObject({ component: lX.custom(...hr), extraContent: lX.custom(...hr).optional() }), navigation: lX.boolean().or(lX.strictObject({ next: lX.boolean(), prev: lX.boolean() })), nextThemes: lX.strictObject({ defaultTheme: lX.string(), forcedTheme: lX.string().optional(), storageKey: lX.string() }), notFound: lX.strictObject({ content: lX.custom(...hr), labels: lX.string() }), primaryHue: lX.number().or(lX.strictObject({ dark: lX.number(), light: lX.number() })), project: lX.strictObject({ icon: lX.custom(...hr), link: lX.string().startsWith("https://").optional() }), search: lX.strictObject({ component: lX.custom(...hr), emptyResult: lX.custom(...hr), error: lX.string().or(lX.function().returns(lX.string())), loading: lX.string().or(lX.function().returns(lX.string())), placeholder: lX.string().or(lX.function().returns(lX.string())) }), serverSideError: lX.strictObject({ content: lX.custom(...hr), labels: lX.string() }), sidebar: lX.strictObject({ defaultMenuCollapseLevel: lX.number().min(1).int(), titleComponent: lX.custom(...hr), toggleButton: lX.boolean() }), themeSwitch: lX.strictObject({ component: lX.custom(...hr), useOptions: d4.or(lX.function().returns(d4)) }), toc: lX.strictObject({ component: lX.custom(...hr), extraContent: lX.custom(...hr), float: lX.boolean(), headingComponent: lX.custom(...ha).optional(), title: lX.custom(...hr) }), useNextSeoProps: lX.custom(he) }).deepPartial().extend({ i18n: hn.optional() }); var hi = { banner: { dismissible: !0, key: "nextra-banner" }, chat: { icon: (0, eu.jsxs)(eu.Fragment, { children: [(0, eu.jsx)(nW, {}), (0, eu.jsx)("span", { className: "nx-sr-only", children: "Discord" })] }) }, darkMode: !0, direction: "ltr", docsRepositoryBase: "https://github.com/shuding/nextra", editLink: { component: function ({ className: e, filePath: t, children: n }) { let r = di(t); return r ? (0, eu.jsx)(de, { className: e, href: r, children: n }) : null }, text: "Edit this page" }, feedback: { content: "Question? Give us feedback →", labels: "feedback", useLink () { let e = c3(); return dt({ labels: e.feedback.labels, repository: e.docsRepositoryBase, title: `Feedback for \u201C${e.title}\u201D` }) } }, footer: { component: dA, text: `MIT ${new Date().getFullYear()} \xa9 Nextra.` }, gitTimestamp: function ({ timestamp: e }) { let { locale: t = d9 } = (0, J.useRouter)(); return (0, eu.jsxs)(eu.Fragment, { children: ["Last updated on", " ", (0, eu.jsx)("time", { dateTime: e.toISOString(), children: e.toLocaleDateString(t, { day: "numeric", month: "long", year: "numeric" }) })] }) }, head: (0, eu.jsxs)(eu.Fragment, { children: [(0, eu.jsx)("meta", { name: "msapplication-TileColor", content: "#fff" }), (0, eu.jsx)("meta", { httpEquiv: "Content-Language", content: "en" }), (0, eu.jsx)("meta", { name: "description", content: "Nextra: the next docs builder" }), (0, eu.jsx)("meta", { name: "twitter:card", content: "summary_large_image" }), (0, eu.jsx)("meta", { name: "twitter:site", content: "@shuding_" }), (0, eu.jsx)("meta", { property: "og:title", content: "Nextra: the next docs builder" }), (0, eu.jsx)("meta", { property: "og:description", content: "Nextra: the next docs builder" }), (0, eu.jsx)("meta", { name: "apple-mobile-web-app-title", content: "Nextra" })] }), i18n: [], logo: (0, eu.jsxs)(eu.Fragment, { children: [(0, eu.jsx)("span", { className: "nx-font-extrabold", children: "Nextra" }), (0, eu.jsx)("span", { className: "nx-ml-2 nx-hidden nx-font-normal nx-text-gray-600 md:nx-inline", children: "The Next Docs Builder" })] }), logoLink: !0, navbar: { component: dD }, navigation: !0, nextThemes: { defaultTheme: "system", storageKey: "theme" }, notFound: { content: "Submit an issue about broken link →", labels: "bug" }, primaryHue: { dark: 204, light: 212 }, project: { icon: (0, eu.jsxs)(eu.Fragment, { children: [(0, eu.jsx)(nV, {}), (0, eu.jsx)("span", { className: "nx-sr-only", children: "GitHub" })] }) }, search: { component: function ({ className: e, directories: t }) { return c3().flexsearch ? (0, eu.jsx)(dC, { className: e }) : (0, eu.jsx)(d7, { className: e, directories: t }) }, emptyResult: (0, eu.jsx)("span", { className: "nx-block nx-select-none nx-p-8 nx-text-center nx-text-sm nx-text-gray-400", children: "No results found." }), error: "Failed to load search index.", loading: function () { let { locale: e } = (0, J.useRouter)(); return "zh-CN" === e ? "正在加载…" : "ru" === e ? "Загрузка…" : "fr" === e ? "Сhargement…" : "Loading…" }, placeholder: function () { let { locale: e } = (0, J.useRouter)(); return "zh-CN" === e ? "搜索文档…" : "ru" === e ? "Поиск документации…" : "fr" === e ? "Rechercher documents…" : "Search documentation…" } }, serverSideError: { content: "Submit an issue about error in url →", labels: "bug" }, sidebar: { defaultMenuCollapseLevel: 2, titleComponent: ({ title: e }) => (0, eu.jsx)(eu.Fragment, { children: e }), toggleButton: !1 }, themeSwitch: { component: d3, useOptions () { let { locale: e } = (0, J.useRouter)(); return "zh-CN" === e ? { dark: "深色主题", light: "浅色主题", system: "系统默认" } : { dark: "Dark", light: "Light", system: "System" } } }, toc: { component: d5, float: !0, title: "On This Page" }, useNextSeoProps: () => ({ titleTemplate: "%s – Nextra" }) }, hs = Object.entries(hi).map(([e, t]) => { if (t && "object" == typeof t && !Array.isArray(t) && !(0, Q.isValidElement)(t)) return e }).filter(Boolean); if (d6) { let e; let t = () => { document.body.classList.add("resizing"), clearTimeout(e), e = setTimeout(() => { document.body.classList.remove("resizing") }, 200) }; window.addEventListener("resize", t) } function ho (e) { var t = e, { tag: n, context: r, children: a, id: i } = t, s = cU(t, ["tag", "context", "children", "id"]); let o = cQ(), l = cJ(), u = cY(), c = (0, Q.useRef)(null); return (0, Q.useEffect)(() => { if (!i) return; let e = c.current; if (e) return l.set(e, [i, r.index += 1]), null == u || u.observe(e), () => { null == u || u.disconnect(), l.delete(e), o(e => { let t = cz({}, e); return delete t[i], t }) } }, [i, r, l, u, o]), (0, eu.jsxs)(n, c$(cz({ className: ee("nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100", { h2: "nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400", h3: "nx-mt-8 nx-text-2xl", h4: "nx-mt-8 nx-text-xl", h5: "nx-mt-8 nx-text-lg", h6: "nx-mt-8 nx-text-base" }[n]) }, s), { children: [a, (0, eu.jsx)("span", { className: "nx-absolute -nx-mt-20", id: i, ref: c }), (0, eu.jsx)("a", { href: `#${i}`, className: "subheading-anchor", "aria-label": "Permalink for this section" })] })) } var hl = e => { let t = null, n = []; return Q.Children.forEach(e, (e, r) => { var a; if (e && e.type === hc) { t || (t = e); return } let i = e; if (!t && e && "object" == typeof e && e.type !== hu && "props" in e && e.props) { let n = hl(e.props.children); t = n[0], i = (0, Q.cloneElement)(e, c$(cz({}, e.props), { children: (null == (a = n[1]) ? void 0 : a.length) ? n[1] : void 0, key: r })) } n.push(i) }), [t, n] }, hu = e => { var t = e, { children: n, open: r } = t, a = cU(t, ["children", "open"]); let [i, s] = (0, Q.useState)(!!r), [o, l] = hl(n), [u, c] = (0, Q.useState)(i); return (0, Q.useEffect)(() => { if (i) c(!0); else { let e = setTimeout(() => c(i), 500); return () => clearTimeout(e) } }, [i]), (0, eu.jsxs)("details", c$(cz(c$(cz({ className: "nx-my-4 nx-rounded nx-border nx-border-gray-200 nx-bg-white nx-p-2 nx-shadow-sm first:nx-mt-0 dark:nx-border-neutral-800 dark:nx-bg-neutral-900" }, a), { open: u }), i && { "data-expanded": !0 }), { children: [(0, eu.jsx)(c6, { value: s, children: o }), (0, eu.jsx)(dp, { isOpen: i, children: l })] })) }, hc = e => { let t = c9(); return (0, eu.jsx)("summary", c$(cz({ className: ee("nx-flex nx-items-center nx-cursor-pointer nx-list-none nx-p-1 nx-transition-colors hover:nx-bg-gray-100 dark:hover:nx-bg-neutral-800", "before:nx-mr-1 before:nx-inline-block before:nx-transition-transform before:nx-content-[''] dark:before:nx-invert", "rtl:before:nx-rotate-180 [[data-expanded]>&]:before:nx-rotate-90") }, e), { onClick: e => { e.preventDefault(), t(e => !e) } })) }, hd = /https?:\/\//, hh = e => { var t = e, { href: n = "", className: r } = t, a = cU(t, ["href", "className"]); return (0, eu.jsx)(de, cz({ href: n, newWindow: hd.test(n), className: ee("nx-text-primary-600 nx-underline nx-decoration-from-font [text-underline-position:from-font]", r) }, a)) }, hp = e => { var t = e, { href: n = "" } = t, r = cU(t, ["href"]); return (0, eu.jsx)(de, cz({ href: n, newWindow: hd.test(n) }, r)) }, hf = ({ isRawLayout: e, components: t }) => { if (e) return { a: hp }; let n = { index: 0 }; return cz({ h1: e => (0, eu.jsx)("h1", cz({ className: "nx-mt-2 nx-text-4xl nx-font-bold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100" }, e)), h2: e => (0, eu.jsx)(ho, cz({ tag: "h2", context: n }, e)), h3: e => (0, eu.jsx)(ho, cz({ tag: "h3", context: n }, e)), h4: e => (0, eu.jsx)(ho, cz({ tag: "h4", context: n }, e)), h5: e => (0, eu.jsx)(ho, cz({ tag: "h5", context: n }, e)), h6: e => (0, eu.jsx)(ho, cz({ tag: "h6", context: n }, e)), ul: e => (0, eu.jsx)("ul", cz({ className: "nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6" }, e)), ol: e => (0, eu.jsx)("ol", cz({ className: "nx-mt-6 nx-list-decimal first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6" }, e)), li: e => (0, eu.jsx)("li", cz({ className: "nx-my-2" }, e)), blockquote: e => (0, eu.jsx)("blockquote", cz({ className: ee("nx-mt-6 nx-border-gray-300 nx-italic nx-text-gray-700 dark:nx-border-gray-700 dark:nx-text-gray-400", "first:nx-mt-0 ltr:nx-border-l-2 ltr:nx-pl-6 rtl:nx-border-r-2 rtl:nx-pr-6") }, e)), hr: e => (0, eu.jsx)("hr", cz({ className: "nx-my-8 dark:nx-border-gray-900" }, e)), a: hh, table: e => (0, eu.jsx)(cw, cz({ className: "nextra-scrollbar nx-mt-6 nx-p-0 first:nx-mt-0" }, e)), p: e => (0, eu.jsx)("p", cz({ className: "nx-mt-6 nx-leading-7 first:nx-mt-0" }, e)), tr: cj, th: ck, td: c_, details: hu, summary: hc, pre: uh, code: ud }, t) }, hm = { toc: ee("nextra-toc nx-order-last nx-hidden nx-w-64 nx-shrink-0 xl:nx-block print:nx-hidden"), main: ee("nx-w-full nx-break-words") }, hx = ({ themeContext: e, breadcrumb: t, timestamp: n, navigation: r, children: a }) => { var i; let s = c3(), o = en(); if ("raw" === e.layout) return (0, eu.jsx)("div", { className: hm.main, children: a }); let l = e.timestamp && s.gitTimestamp && n ? new Date(n) : null, u = o && l ? (0, eu.jsx)("div", { className: "nx-mt-12 nx-mb-8 nx-block nx-text-xs nx-text-gray-500 ltr:nx-text-right rtl:nx-text-left dark:nx-text-gray-400", children: dn(s.gitTimestamp, { timestamp: l }) }) : (0, eu.jsx)("div", { className: "nx-mt-16" }), c = (0, eu.jsxs)(eu.Fragment, { children: [a, u, r] }), d = (null == (i = s.main) ? void 0 : i.call(s, { children: c })) || c; return "full" === e.layout ? (0, eu.jsx)("article", { className: ee(hm.main, "nextra-content nx-min-h-[calc(100vh-var(--nextra-navbar-height))] nx-pl-[max(env(safe-area-inset-left),1.5rem)] nx-pr-[max(env(safe-area-inset-right),1.5rem)]"), children: d }) : (0, eu.jsx)("article", { className: ee(hm.main, "nextra-content nx-flex nx-min-h-[calc(100vh-var(--nextra-navbar-height))] nx-min-w-0 nx-justify-center nx-pb-8 nx-pr-[calc(env(safe-area-inset-right)-1.5rem)]", "article" === e.typesetting && "nextra-body-typesetting-article"), children: (0, eu.jsxs)("main", { className: "nx-w-full nx-min-w-0 nx-max-w-6xl nx-px-6 nx-pt-4 md:nx-px-12", children: [t, d] }) }) }, hg = ({ filePath: e, pageMap: t, frontMatter: n, headings: r, timestamp: a, children: i }) => { let s = c3(), { locale: o = d9, defaultLocale: l } = (0, J.useRouter)(), u = ei(), { activeType: c, activeIndex: d, activeThemeContext: h, activePath: p, topLevelNavbarItems: f, docsDirectories: m, flatDirectories: x, flatDocsDirectories: g, directories: v } = (0, Q.useMemo)(() => nF({ list: t, locale: o, defaultLocale: l, route: u }), [t, o, l, u]), y = cz(cz({}, h), n), b = !y.sidebar || "raw" === y.layout || "page" === c, _ = "page" !== c && y.toc && "default" === y.layout ? (0, eu.jsx)("nav", { className: ee(hm.toc, "nx-px-4"), "aria-label": "table of contents", children: dn(s.toc.component, { headings: s.toc.float ? r : [], filePath: e }) }) : "full" !== y.layout && "raw" !== y.layout && (0, eu.jsx)("nav", { className: hm.toc, "aria-label": "table of contents" }), w = s.i18n.find(e => e.locale === o), k = (w ? "rtl" === w.direction : "rtl" === s.direction) ? "rtl" : "ltr"; return (0, eu.jsxs)("div", { dir: k, children: [(0, eu.jsx)("script", { dangerouslySetInnerHTML: { __html: `document.documentElement.setAttribute('dir','${k}')` } }), (0, eu.jsx)(dR, {}), (0, eu.jsx)(ds, {}), y.navbar && dn(s.navbar.component, { flatDirectories: x, items: f }), (0, eu.jsx)("div", { className: ee("nx-mx-auto nx-flex", "raw" !== y.layout && "nx-max-w-[90rem]"), children: (0, eu.jsxs)(cX, { children: [(0, eu.jsx)(dK, { docsDirectories: m, flatDirectories: x, fullDirectories: v, headings: r, asPopover: b, includePlaceholder: "default" === y.layout }), _, (0, eu.jsx)(dJ, {}), (0, eu.jsx)(hx, { themeContext: y, breadcrumb: "page" !== c && y.breadcrumb ? (0, eu.jsx)(du, { activePath: p }) : null, timestamp: a, navigation: "page" !== c && y.pagination ? (0, eu.jsx)(dM, { flatDirectories: g, currentIndex: d }) : null, children: (0, eu.jsx)(et.Z, { components: hf({ isRawLayout: "raw" === y.layout, components: s.components }), children: i }) })] }) }), y.footer && dn(s.footer.component, { menu: b })] }) }; function hv (e) { var t = e, { children: n } = t, r = cU(t, ["children"]); return (0, eu.jsx)(c5, { value: r, children: (0, eu.jsx)(hg, c$(cz({}, r.pageOpts), { children: n })) }) }
  }, 6952: function (e, t, n) { "use strict"; n.d(t, { Z: function () { return o }, a: function () { return d } }); var r = n(5271); let a = r.createContext({}); function i (e) { let t = r.useContext(a); return r.useMemo(() => "function" == typeof e ? e(t) : { ...t, ...e }, [t, e]) } let s = {}; function o ({ components: e, children: t, disableParentContext: n }) { let o; return o = n ? "function" == typeof e ? e({}) : e || s : i(e), r.createElement(a.Provider, { value: o }, t) } var l = n(9263), u = n.n(l), c = { img: e => (0, r.createElement)("object" == typeof e.src ? u() : "img", e) }, d = e => i({ ...c, ...e }) }, 5182: function (e, t, n) { "use strict"; var r = n(6097); function a (e) { var t = { protocols: [], protocol: null, port: null, resource: "", host: "", user: "", password: "", pathname: "", hash: "", search: "", href: e, query: {}, parse_failed: !1 }; try { var n = new URL(e); t.protocols = r(n), t.protocol = t.protocols[0], t.port = n.port, t.resource = n.hostname, t.host = n.host, t.user = n.username || "", t.password = n.password || "", t.pathname = n.pathname, t.hash = n.hash.slice(1), t.search = n.search.slice(1), t.href = n.href, t.query = Object.fromEntries(n.searchParams) } catch (n) { t.protocols = ["file"], t.protocol = t.protocols[0], t.port = "", t.resource = "", t.user = "", t.pathname = "", t.hash = "", t.search = "", t.href = e, t.query = {}, t.parse_failed = !0 } return t } e.exports = a }, 8593: function (e, t, n) { "use strict"; var r = function (e) { return e && "object" == typeof e && "default" in e ? e : { default: e } }(n(5182)); let a = "text/plain", i = "us-ascii", s = (e, t) => t.some(t => t instanceof RegExp ? t.test(e) : t === e), o = (e, { stripHash: t }) => { let n = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(e); if (!n) throw Error(`Invalid URL: ${e}`); let { type: r, data: s, hash: o } = n.groups, l = r.split(";"); o = t ? "" : o; let u = !1; "base64" === l[l.length - 1] && (l.pop(), u = !0); let c = (l.shift() || "").toLowerCase(), d = [...l.map(e => { let [t, n = ""] = e.split("=").map(e => e.trim()); return "charset" === t && (n = n.toLowerCase()) === i ? "" : `${t}${n ? `=${n}` : ""}` }).filter(Boolean)]; return u && d.push("base64"), (d.length > 0 || c && c !== a) && d.unshift(c), `data:${d.join(";")},${u ? s.trim() : s}${o ? `#${o}` : ""}` }; function l (e, t) { if (t = { defaultProtocol: "http:", normalizeProtocol: !0, forceHttp: !1, forceHttps: !1, stripAuthentication: !0, stripHash: !1, stripTextFragment: !0, stripWWW: !0, removeQueryParameters: [/^utm_\w+/i], removeTrailingSlash: !0, removeSingleSlash: !0, removeDirectoryIndex: !1, sortQueryParameters: !0, ...t }, e = e.trim(), /^data:/i.test(e)) return o(e, t); if (/^view-source:/i.test(e)) throw Error("`view-source:` is not supported as it is a non-standard protocol"); let n = e.startsWith("//"); !n && /^\.*\//.test(e) || (e = e.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, t.defaultProtocol)); let r = new URL(e); if (t.forceHttp && t.forceHttps) throw Error("The `forceHttp` and `forceHttps` options cannot be used together"); if (t.forceHttp && "https:" === r.protocol && (r.protocol = "http:"), t.forceHttps && "http:" === r.protocol && (r.protocol = "https:"), t.stripAuthentication && (r.username = "", r.password = ""), t.stripHash ? r.hash = "" : t.stripTextFragment && (r.hash = r.hash.replace(/#?:~:text.*?$/i, "")), r.pathname) { let e = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g, t = 0, n = ""; for (; ;) { let a = e.exec(r.pathname); if (!a) break; let i = a[0], s = a.index; n += r.pathname.slice(t, s).replace(/\/{2,}/g, "/") + i, t = s + i.length } n += r.pathname.slice(t, r.pathname.length).replace(/\/{2,}/g, "/"), r.pathname = n } if (r.pathname) try { r.pathname = decodeURI(r.pathname) } catch { } if (!0 === t.removeDirectoryIndex && (t.removeDirectoryIndex = [/^index\.[a-z]+$/]), Array.isArray(t.removeDirectoryIndex) && t.removeDirectoryIndex.length > 0) { let e = r.pathname.split("/"); s(e[e.length - 1], t.removeDirectoryIndex) && (e = e.slice(0, -1), r.pathname = e.slice(1).join("/") + "/") } if (r.hostname && (r.hostname = r.hostname.replace(/\.$/, ""), t.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(r.hostname) && (r.hostname = r.hostname.replace(/^www\./, ""))), Array.isArray(t.removeQueryParameters)) for (let e of [...r.searchParams.keys()]) s(e, t.removeQueryParameters) && r.searchParams.delete(e); if (!0 === t.removeQueryParameters && (r.search = ""), t.sortQueryParameters) { r.searchParams.sort(); try { r.search = decodeURIComponent(r.search) } catch { } } t.removeTrailingSlash && (r.pathname = r.pathname.replace(/\/$/, "")); let a = e; return e = r.toString(), t.removeSingleSlash || "/" !== r.pathname || a.endsWith("/") || "" !== r.hash || (e = e.replace(/\/$/, "")), (t.removeTrailingSlash || "/" === r.pathname) && "" === r.hash && t.removeSingleSlash && (e = e.replace(/\/$/, "")), n && !t.normalizeProtocol && (e = e.replace(/^http:\/\//, "//")), t.stripProtocol && (e = e.replace(/^(?:https?:)?\/\//, "")), e } let u = (e, t = !1) => { let n = /^(?:([a-z_][a-z0-9_-]{0,31})@|https?:\/\/)([\w\.\-@]+)[\/:]([\~,\.\w,\-,\_,\/]+?(?:\.git|\/)?)$/, a = t => { let n = Error(t); throw n.subject_url = e, n }; "string" == typeof e && e.trim() || a("Invalid url."), e.length > u.MAX_INPUT_LENGTH && a("Input exceeds maximum length. If needed, change the value of parseUrl.MAX_INPUT_LENGTH."), t && ("object" != typeof t && (t = { stripHash: !1 }), e = l(e, t)); let i = r.default(e); if (i.parse_failed) { let e = i.href.match(n); e ? (i.protocols = ["ssh"], i.protocol = "ssh", i.resource = e[2], i.host = e[2], i.user = e[1], i.pathname = `/${e[3]}`, i.parse_failed = !1) : a("URL parsing failed.") } return i }; u.MAX_INPUT_LENGTH = 2048, e.exports = u }, 6097: function (e) { "use strict"; e.exports = function (e, t) { !0 === t && (t = 0); var n = ""; if ("string" == typeof e) try { n = new URL(e).protocol } catch (e) { } else e && e.constructor === URL && (n = e.protocol); var r = n.split(/\:|\+/).filter(Boolean); return "number" == typeof t ? r[t] : r } }, 6593: function (e) { var t = { À: "A", Á: "A", Â: "A", Ã: "A", Ä: "A", Å: "A", Ấ: "A", Ắ: "A", Ẳ: "A", Ẵ: "A", Ặ: "A", Æ: "AE", Ầ: "A", Ằ: "A", Ȃ: "A", Ç: "C", Ḉ: "C", È: "E", É: "E", Ê: "E", Ë: "E", Ế: "E", Ḗ: "E", Ề: "E", Ḕ: "E", Ḝ: "E", Ȇ: "E", Ì: "I", Í: "I", Î: "I", Ï: "I", Ḯ: "I", Ȋ: "I", Ð: "D", Ñ: "N", Ò: "O", Ó: "O", Ô: "O", Õ: "O", Ö: "O", Ø: "O", Ố: "O", Ṍ: "O", Ṓ: "O", Ȏ: "O", Ù: "U", Ú: "U", Û: "U", Ü: "U", Ý: "Y", à: "a", á: "a", â: "a", ã: "a", ä: "a", å: "a", ấ: "a", ắ: "a", ẳ: "a", ẵ: "a", ặ: "a", æ: "ae", ầ: "a", ằ: "a", ȃ: "a", ç: "c", ḉ: "c", è: "e", é: "e", ê: "e", ë: "e", ế: "e", ḗ: "e", ề: "e", ḕ: "e", ḝ: "e", ȇ: "e", ì: "i", í: "i", î: "i", ï: "i", ḯ: "i", ȋ: "i", ð: "d", ñ: "n", ò: "o", ó: "o", ô: "o", õ: "o", ö: "o", ø: "o", ố: "o", ṍ: "o", ṓ: "o", ȏ: "o", ù: "u", ú: "u", û: "u", ü: "u", ý: "y", ÿ: "y", Ā: "A", ā: "a", Ă: "A", ă: "a", Ą: "A", ą: "a", Ć: "C", ć: "c", Ĉ: "C", ĉ: "c", Ċ: "C", ċ: "c", Č: "C", č: "c", C̆: "C", c̆: "c", Ď: "D", ď: "d", Đ: "D", đ: "d", Ē: "E", ē: "e", Ĕ: "E", ĕ: "e", Ė: "E", ė: "e", Ę: "E", ę: "e", Ě: "E", ě: "e", Ĝ: "G", Ǵ: "G", ĝ: "g", ǵ: "g", Ğ: "G", ğ: "g", Ġ: "G", ġ: "g", Ģ: "G", ģ: "g", Ĥ: "H", ĥ: "h", Ħ: "H", ħ: "h", Ḫ: "H", ḫ: "h", Ĩ: "I", ĩ: "i", Ī: "I", ī: "i", Ĭ: "I", ĭ: "i", Į: "I", į: "i", İ: "I", ı: "i", Ĳ: "IJ", ĳ: "ij", Ĵ: "J", ĵ: "j", Ķ: "K", ķ: "k", Ḱ: "K", ḱ: "k", K̆: "K", k̆: "k", Ĺ: "L", ĺ: "l", Ļ: "L", ļ: "l", Ľ: "L", ľ: "l", Ŀ: "L", ŀ: "l", Ł: "l", ł: "l", Ḿ: "M", ḿ: "m", M̆: "M", m̆: "m", Ń: "N", ń: "n", Ņ: "N", ņ: "n", Ň: "N", ň: "n", ŉ: "n", N̆: "N", n̆: "n", Ō: "O", ō: "o", Ŏ: "O", ŏ: "o", Ő: "O", ő: "o", Œ: "OE", œ: "oe", P̆: "P", p̆: "p", Ŕ: "R", ŕ: "r", Ŗ: "R", ŗ: "r", Ř: "R", ř: "r", R̆: "R", r̆: "r", Ȓ: "R", ȓ: "r", Ś: "S", ś: "s", Ŝ: "S", ŝ: "s", Ş: "S", Ș: "S", ș: "s", ş: "s", Š: "S", š: "s", Ţ: "T", ţ: "t", ț: "t", Ț: "T", Ť: "T", ť: "t", Ŧ: "T", ŧ: "t", T̆: "T", t̆: "t", Ũ: "U", ũ: "u", Ū: "U", ū: "u", Ŭ: "U", ŭ: "u", Ů: "U", ů: "u", Ű: "U", ű: "u", Ų: "U", ų: "u", Ȗ: "U", ȗ: "u", V̆: "V", v̆: "v", Ŵ: "W", ŵ: "w", Ẃ: "W", ẃ: "w", X̆: "X", x̆: "x", Ŷ: "Y", ŷ: "y", Ÿ: "Y", Y̆: "Y", y̆: "y", Ź: "Z", ź: "z", Ż: "Z", ż: "z", Ž: "Z", ž: "z", ſ: "s", ƒ: "f", Ơ: "O", ơ: "o", Ư: "U", ư: "u", Ǎ: "A", ǎ: "a", Ǐ: "I", ǐ: "i", Ǒ: "O", ǒ: "o", Ǔ: "U", ǔ: "u", Ǖ: "U", ǖ: "u", Ǘ: "U", ǘ: "u", Ǚ: "U", ǚ: "u", Ǜ: "U", ǜ: "u", Ứ: "U", ứ: "u", Ṹ: "U", ṹ: "u", Ǻ: "A", ǻ: "a", Ǽ: "AE", ǽ: "ae", Ǿ: "O", ǿ: "o", Þ: "TH", þ: "th", Ṕ: "P", ṕ: "p", Ṥ: "S", ṥ: "s", X́: "X", x́: "x", Ѓ: "Г", ѓ: "г", Ќ: "К", ќ: "к", A̋: "A", a̋: "a", E̋: "E", e̋: "e", I̋: "I", i̋: "i", Ǹ: "N", ǹ: "n", Ồ: "O", ồ: "o", Ṑ: "O", ṑ: "o", Ừ: "U", ừ: "u", Ẁ: "W", ẁ: "w", Ỳ: "Y", ỳ: "y", Ȁ: "A", ȁ: "a", Ȅ: "E", ȅ: "e", Ȉ: "I", ȉ: "i", Ȍ: "O", ȍ: "o", Ȑ: "R", ȑ: "r", Ȕ: "U", ȕ: "u", B̌: "B", b̌: "b", Č̣: "C", č̣: "c", Ê̌: "E", ê̌: "e", F̌: "F", f̌: "f", Ǧ: "G", ǧ: "g", Ȟ: "H", ȟ: "h", J̌: "J", ǰ: "j", Ǩ: "K", ǩ: "k", M̌: "M", m̌: "m", P̌: "P", p̌: "p", Q̌: "Q", q̌: "q", Ř̩: "R", ř̩: "r", Ṧ: "S", ṧ: "s", V̌: "V", v̌: "v", W̌: "W", w̌: "w", X̌: "X", x̌: "x", Y̌: "Y", y̌: "y", A̧: "A", a̧: "a", B̧: "B", b̧: "b", Ḑ: "D", ḑ: "d", Ȩ: "E", ȩ: "e", Ɛ̧: "E", ɛ̧: "e", Ḩ: "H", ḩ: "h", I̧: "I", i̧: "i", Ɨ̧: "I", ɨ̧: "i", M̧: "M", m̧: "m", O̧: "O", o̧: "o", Q̧: "Q", q̧: "q", U̧: "U", u̧: "u", X̧: "X", x̧: "x", Z̧: "Z", z̧: "z" }, n = Object.keys(t).join("|"), r = RegExp(n, "g"), a = RegExp(n, ""), i = function (e) { return e.replace(r, function (e) { return t[e] }) }, s = function (e) { return !!e.match(a) }; e.exports = i, e.exports.has = s, e.exports.remove = i }, 7441: function (e, t, n) { "use strict"; n.d(t, { Bi: function () { return s }, ZW: function () { return i }, eZ: function () { return l }, hV: function () { return u } }); var r = n(7442), a = n(2221), i = "en-US", s = "_meta.json", o = a.cwd(); r.join(o, "public"); var l = Symbol.for("__nextra_internal__"), u = new Set(["/404.html", "/500"]) }
}, function (e) { var t = function (t) { return e(e.s = t) }; e.O(0, [774, 179], function () { return t(5596), t(8040) }), _N_E = e.O() }])