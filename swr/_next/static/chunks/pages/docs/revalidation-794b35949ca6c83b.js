(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[878], { 4731: function (e, s, n) { (window.__NEXT_P = window.__NEXT_P || []).push(["/docs/revalidation.html", function () { return n(8288) }]) }, 8288: function (e, s, n) { "use strict"; n.r(s), n.d(s, { __toc: function () { return d } }); var r = n(2676), l = n(3017), i = n(6952), t = n(1621), o = n(4894), a = n(1530), c = n.n(a); let d = [{ depth: 2, value: "聚焦时重新请求", id: "revalidate-on-focus" }, { depth: 2, value: "定期重新请求", id: "revalidate-on-interval" }, { depth: 2, value: "重新连接时重新请求", id: "revalidate-on-reconnect" }, { depth: 2, value: "禁用自动重新请求", id: "disable-automatic-revalidations" }, { depth: 2, value: "挂载时重新请求", id: "revalidate-on-mount" }]; function h (e) { let s = Object.assign({ h1: "h1", p: "p", h2: "h2", strong: "strong", a: "a", code: "code", pre: "pre", span: "span", ul: "ul", li: "li" }, (0, i.a)(), e.components); return (0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)(s.h1, { children: "自动重新请求" }), "\n", (0, r.jsx)(o.UW, { children: (0, r.jsxs)(s.p, { children: ["如果你想手动重新请求数据，请查看 ", (0, r.jsx)(c(), { href: "/docs/mutation.html", children: "mutation" }), "。"] }) }), "\n", (0, r.jsx)(s.h2, { id: "revalidate-on-focus", children: "聚焦时重新请求" }), "\n", (0, r.jsx)(s.p, { children: "当你重新聚焦一个页面或在标签页之间切换时，SWR 会自动重新请求数据。" }), "\n", (0, r.jsxs)(s.p, { children: ["这个功能非常实用，可以保持网站同步到最新数据。对于在长时间位于后台的标签页，或 ", (0, r.jsx)(s.strong, { children: "休眠" }), " 的电脑等情况下刷新数据也很有帮助。"] }), "\n", (0, r.jsx)(o.zu, { children: (0, r.jsx)(t.Z, { src: "https://raw.githubusercontent.com/vercel/swr-site/master/.github/videos/focus-revalidate.mp4", caption: "视频：使用聚焦时重新验证在页面间自动同步登陆状态。", ratio: 307 / 768, className: "mx-8 2xl:mx-24" }) }), "\n", (0, r.jsxs)(s.p, { children: ["该特性默认是启用的。你可以通过 ", (0, r.jsx)(s.a, { href: "/docs/api.html", children: (0, r.jsx)(s.code, { children: "revalidateOnFocus" }) }), " 选项禁用它。"] }), "\n", (0, r.jsx)(s.h2, { id: "revalidate-on-interval", children: "定期重新请求" }), "\n", (0, r.jsx)(s.p, { children: "在很多情况下，数据会因为多个设备、多个用户、多个选项卡而发生改变。那么我们如何随着时间的推移更新屏幕上的数据呢？" }), "\n", (0, r.jsxs)(s.p, { children: ["SWR 会为你提供自动重新请求数据的选项。这很 ", (0, r.jsx)(s.strong, { children: "智能" }), "，意味着只有与 hook 相关的组件 ", (0, r.jsx)(s.strong, { children: "在屏幕上" }), " 时，才会重新请求。"] }), "\n", (0, r.jsx)(o.zu, { children: (0, r.jsx)(t.Z, { src: "https://raw.githubusercontent.com/vercel/swr-site/master/.github/videos/refetch-interval.mp4", caption: "视频：当用户进行更改时，两个会话最终将呈现相同的数据。", ratio: 307 / 768, className: "mx-8 2xl:mx-24" }) }), "\n", (0, r.jsxs)(s.p, { children: ["你可以通过设置 ", (0, r.jsx)(s.a, { href: "/docs/api.html", children: (0, r.jsx)(s.code, { children: "refreshInterval" }) }), " 值来启用它："] }), "\n", (0, r.jsx)(s.pre, { "data-language": "js", "data-theme": "default", hasCopyCode: !0, children: (0, r.jsx)(s.code, { "data-language": "js", "data-theme": "default", children: (0, r.jsxs)(s.span, { className: "line", children: [(0, r.jsx)(s.span, { style: { color: "var(--shiki-token-function)" }, children: "useSWR" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: "(" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-string-expression)" }, children: "'/api/todos'" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-punctuation)" }, children: "," }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " fetcher" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-punctuation)" }, children: "," }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " { refreshInterval" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-keyword)" }, children: ":" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " " }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-constant)" }, children: "1000" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " })" })] }) }) }), "\n", (0, r.jsxs)(s.p, { children: ["还有其他选项，例如 ", (0, r.jsx)(s.code, { children: "refreshWhenHidden" }), " 和 ", (0, r.jsx)(s.code, { children: "refreshWhenOffline" }), "。这两项默认都是禁用的，所以当网页不在屏幕上或没有网络连接时，SWR 不会请求。"] }), "\n", (0, r.jsx)(s.h2, { id: "revalidate-on-reconnect", children: "重新连接时重新请求" }), "\n", (0, r.jsx)(s.p, { children: "当用户重新联机时重新请求非常有用。这种情况经常发生在用户解锁了他们的计算机但网络还没有连上时。" }), "\n", (0, r.jsx)(s.p, { children: "为了确保数据始终是最新的，SWR 会在网络恢复时自动重新请求。" }), "\n", (0, r.jsxs)(s.p, { children: ["该特性默认是启用的。你可以通过 ", (0, r.jsx)(s.a, { href: "/docs/api.html", children: (0, r.jsx)(s.code, { children: "revalidateOnReconnect" }) }), " 选项禁用它。"] }), "\n", (0, r.jsx)(s.h2, { id: "disable-automatic-revalidations", children: "禁用自动重新请求" }), "\n", (0, r.jsxs)(s.p, { children: ["如果资源是", (0, r.jsx)(s.strong, { children: "不可变的" }), "，即使我们再怎么重新请求也永远不会发生任何改变，那么我们可以禁用它的所有的自动重新请求。"] }), "\n", (0, r.jsxs)(s.p, { children: ["从 1.0 版本开始，SWR 提供了一个辅助 hook ", (0, r.jsx)(s.code, { children: "useSWRImmutable" }), " 来标记资源为不可变的："] }), "\n", (0, r.jsx)(s.pre, { "data-language": "js", "data-theme": "default", hasCopyCode: !0, children: (0, r.jsxs)(s.code, { "data-language": "js", "data-theme": "default", children: [(0, r.jsxs)(s.span, { className: "line", children: [(0, r.jsx)(s.span, { style: { color: "var(--shiki-token-keyword)" }, children: "import" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " useSWRImmutable " }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-keyword)" }, children: "from" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " " }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-string-expression)" }, children: "'swr/immutable'" })] }), "\n", (0, r.jsx)(s.span, { className: "line", children: " " }), "\n", (0, r.jsx)(s.span, { className: "line", children: (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-comment)" }, children: "// ..." }) }), "\n", (0, r.jsxs)(s.span, { className: "line", children: [(0, r.jsx)(s.span, { style: { color: "var(--shiki-token-function)" }, children: "useSWRImmutable" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: "(key" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-punctuation)" }, children: "," }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " fetcher" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-punctuation)" }, children: "," }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " options)" })] })] }) }), "\n", (0, r.jsxs)(s.p, { children: ["它具有与普通 ", (0, r.jsx)(s.code, { children: "useSWR" }), " hook 相同的 API 接口。你还可以通过禁用以下重新请求​​选项来执行相同的操作："] }), "\n", (0, r.jsx)(s.pre, { "data-language": "js", "data-theme": "default", hasCopyCode: !0, children: (0, r.jsxs)(s.code, { "data-language": "js", "data-theme": "default", children: [(0, r.jsxs)(s.span, { className: "line", children: [(0, r.jsx)(s.span, { style: { color: "var(--shiki-token-function)" }, children: "useSWR" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: "(key" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-punctuation)" }, children: "," }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " fetcher" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-punctuation)" }, children: "," }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " {" })] }), "\n", (0, r.jsxs)(s.span, { className: "line", children: [(0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: "  revalidateIfStale" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-keyword)" }, children: ":" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " " }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-constant)" }, children: "false" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-punctuation)" }, children: "," })] }), "\n", (0, r.jsxs)(s.span, { className: "line", children: [(0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: "  revalidateOnFocus" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-keyword)" }, children: ":" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " " }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-constant)" }, children: "false" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-punctuation)" }, children: "," })] }), "\n", (0, r.jsxs)(s.span, { className: "line", children: [(0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: "  revalidateOnReconnect" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-keyword)" }, children: ":" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " " }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-constant)" }, children: "false" })] }), "\n", (0, r.jsx)(s.span, { className: "line", children: (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: "})" }) }), "\n", (0, r.jsx)(s.span, { className: "line", children: " " }), "\n", (0, r.jsx)(s.span, { className: "line", children: (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-comment)" }, children: "// 相当于" }) }), "\n", (0, r.jsxs)(s.span, { className: "line", children: [(0, r.jsx)(s.span, { style: { color: "var(--shiki-token-function)" }, children: "useSWRImmutable" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: "(key" }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-token-punctuation)" }, children: "," }), (0, r.jsx)(s.span, { style: { color: "var(--shiki-color-text)" }, children: " fetcher)" })] })] }) }), "\n", (0, r.jsxs)(s.p, { children: [(0, r.jsx)(s.code, { children: "revalidateIfStale" }), " 控制 SWR 在挂载并且存在陈旧数据时是否应重新请求。"] }), "\n", (0, r.jsxs)(s.p, { children: ["上面这两个 hook 做", (0, r.jsx)(s.strong, { children: "完全相同的" }), "事情。一旦数据被缓存，他们将永远不会再次请求它。"] }), "\n", (0, r.jsx)(s.h2, { id: "revalidate-on-mount", children: "挂载时重新请求" }), "\n", (0, r.jsxs)(s.p, { children: ["在组件挂载时，强制覆盖 SWR 的重新请求，这非常有用。默认情况下，", (0, r.jsx)(s.code, { children: "revalidateOnMount" }), "的值为", (0, r.jsx)(s.code, { children: "undefined" }), "。"] }), "\n", (0, r.jsx)(s.p, { children: "SWR hook 挂载过程如下:" }), "\n", (0, r.jsxs)(s.ul, { children: ["\n", (0, r.jsxs)(s.li, { children: ["首先，它检查是否定义了 ", (0, r.jsx)(s.code, { children: "revalidateOnMount" }), "。如果为 ", (0, r.jsx)(s.code, { children: "true" }), "，则开始请求，如果为 ", (0, r.jsx)(s.code, { children: "false" }), "，则停止请求。"] }), "\n"] }), "\n", (0, r.jsxs)(s.p, { children: [(0, r.jsx)(s.code, { children: "revalidateIfStale" }), " 有助于控制挂载行为。默认情况下，", (0, r.jsx)(s.code, { children: "revalidateIfStale" }), " 设置为 ", (0, r.jsx)(s.code, { children: "true" }), "。"] }), "\n", (0, r.jsxs)(s.p, { children: ["如果 ", (0, r.jsx)(s.code, { children: "revalidateIfStale" }), " 设置为 ", (0, r.jsx)(s.code, { children: "true" }), "，则只有存在缓存数据时才会重新获取数据，否则不会重新获取。"] })] }) } s.default = (0, l.j)({ MDXContent: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, { wrapper: s } = Object.assign({}, (0, i.a)(), e.components); return s ? (0, r.jsx)(s, { ...e, children: (0, r.jsx)(h, { ...e }) }) : h(e) }, pageOpts: { filePath: "pages/docs/revalidation.mdx.html", route: "/docs/revalidation.html", title: "自动重新请求", headings: d }, pageNextRoute: "/docs/revalidation.html" }) }, 1621: function (e, s, n) { "use strict"; n.d(s, { Z: function () { return i } }); var r = n(2676), l = n(5271); function i (e) { let { id: s } = e, [n, i] = (0, l.useState)(!1); return (0, r.jsx)("div", { className: "my-4 overflow-hidden relative rounded-xl", children: (0, r.jsx)("iframe", { className: "w-full aspect-video", src: "https://www.youtube.com/embed/".concat(s), title: "YouTube video player", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", onLoad: () => i(!0) }) }) } } }, function (e) { e.O(0, [17, 888, 774, 179], function () { return e(e.s = 4731) }), _N_E = e.O() }])